diff --git a/src/Main.hs b/src/Main.hs
index e3f9b98..dcd2c11 100644
--- a/src/Main.hs
+++ b/src/Main.hs
@@ -90,12 +90,13 @@ Filters are applicable to dataraces and deadlock analyses.
 Provers:
 A prover is an algorithm turns a history into a constraint.
 
-  said:      The prover used in [Said 2011].
-  free:      A prover that only uses must-happen-before constraints, and sequential
-             consistency.
   none:      No constraints except that the candidate has to be placed next to
              each other.
-  kalhauge:  The data flow sentisive control-flow consistency alogrithm [default].
+  free:      A prover that only uses must-happen-before constraints, and sequential
+             consistency.
+  said:      The prover used in Said et. al. 2011.
+  rvpredict: A prover based on Huang et. al. 2014.
+  dirk:      The data flow sentisive control-flow consistency alogrithm [default].
 |]
 
 data Config = Config
@@ -133,7 +134,7 @@ readConfig args = do
     { verbose = isPresent args $ longOption "verbose"
     , filters = splitOn ','
         $ getArgWithDefault args "unique,lockset" (longOption "filter")
-    , prover = getArgWithDefault args "kalhauge" (longOption "prover")
+    , prover = getArgWithDefault args "dirk" (longOption "prover")
     , outputProof = getLongOption "proof"
     , program = getLongOption "program"
     , history = getArgument "history"
@@ -387,10 +388,11 @@ proveCandidates config p generator toString events =
 
     getProver lm name =
       case name of
-        "said"     -> said
-        "kalhauge" -> kalhauge lm
-        "free"     -> free
-        "none"     -> none
+        "said"      -> said lm
+        "dirk"      -> dirk lm
+        "rvpredict" -> rvpredict lm
+        "free"      -> free lm
+        "none"      -> none
         _          -> error $ "Unknown prover: '" ++ name ++ "'"
 
 runAll :: (Monad m') => a -> [a -> m' a] -> m' a
diff --git a/src/Wiretap/Analysis/Permute.hs b/src/Wiretap/Analysis/Permute.hs
index 95cc8c1..6a35088 100644
--- a/src/Wiretap/Analysis/Permute.hs
+++ b/src/Wiretap/Analysis/Permute.hs
@@ -3,7 +3,8 @@
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE TemplateHaskell  #-}
 module Wiretap.Analysis.Permute
-  ( kalhauge
+  ( dirk
+  , rvpredict
   , said
   , free
   , none
@@ -176,59 +177,130 @@ controlFlow h u@(Unique _ e) =
 
 -- | Get all refs known by the event at the moment of execution.
 -- TODO: Fix problem with write
-knownRefs :: UE -> S.Set Ref
-knownRefs (Unique _ e) =
+valuesOf :: UE -> (S.Set Ref, Bool)
+valuesOf (Unique _ e) =
   case operation e of
-    Write l (Object v) ->
-      maybe S.empty S.singleton (ref l) `S.union` S.singleton (Ref v)
+    Write l _ ->
+      valueL l
     Read l _ ->
-      maybe S.empty S.singleton (ref l)
+      valueL l
     Acquire r ->
-      S.singleton r
+      (S.singleton r, False)
     Release r ->
-      S.singleton r
+      (S.singleton r, False)
     Request r ->
-      S.singleton r
-    Enter r _ ->
-      S.singleton r
+      (S.singleton r, False)
+    Branch ->
+      (S.empty, True)
+    Enter r _ | pointer r  /= 0->
+      (S.singleton r, False)
     _ ->
-      S.empty
+      (S.empty, False)
+  where
+    valueL :: Location -> (S.Set Ref, Bool)
+    valueL l =
+      case l of
+        Dynamic r _ -> (S.singleton r, False)
+        Array r _ -> (S.singleton r, True)
+        _ -> (S.empty, False)
+
+cfdFree
+  :: PartialHistory h
+  => h
+  -> (S.Set Ref, Bool)
+  -> UE
+  -> [UE]
+cfdFree h v u =
+  simulateReverse step [] (controlFlow h u)
+  where
+    step u'@(Unique _ e') events =
+      case operation e' of
+        Acquire r ->
+          u':events
+        _ ->
+          events
 
--- | For a given event, choose all the reads, and locks, that needs to be
--- | consistent for this event to also be consistent.
-controlFlowDependencies
+cfdSaid
   :: PartialHistory h
   => h
+  -> (S.Set Ref, Bool)
   -> UE
   -> [UE]
-controlFlowDependencies h u =
- simulateReverse step ([], knownRefs u, False) (controlFlow h u)  ^. _1
+cfdSaid h v u =
+  simulateReverse step [] (controlFlow h u)
   where
-    step u'@(Unique _ e') s@(events, refs, branch) =
+    step u'@(Unique _ e') events =
       case operation e' of
-        Read _ _ | branch ->
-          over _1 (u':) s
-        Read _ (Object v) | Ref v `S.member` refs  ->
-          over _1 (u':) s
+        Read _ _ ->
+          u':events
         Acquire r ->
-          (u':events, r `S.insert` refs, branch)
-        Branch ->
-          set _3 True s
-        Enter r _ | pointer r /= 0 ->
-          over _2 (S.insert r) s
+          u':events
         _ ->
-          s
+          events
+
+-- | For a given event, choose all the reads, and locks, that needs to be
+-- | consistent for this event to also be consistent.
+cfdDirk
+  :: PartialHistory h
+  => h
+  -> (S.Set Ref, Bool)
+  -> UE
+  -> [UE]
+cfdDirk h v u =
+  simulateReverse step ([], valuesOf u `join` v) (controlFlow h u)  ^. _1
+  where
+    step u'@(Unique _ e') s@(events, vs@(refs, branch)) =
+      let events' =
+            case operation e' of
+              Read _ _ | branch ->
+                u':events
+              Read _ (Object v) | Ref v `S.member` refs  ->
+                u':events
+              Acquire r ->
+                u':events
+              _ ->
+                events
+      in (events', valuesOf u' `join` vs)
+
+    join (r, b) (r2, b2) =
+      (r `S.union` r2, b || b2)
+
+-- | For a given event, choose all the reads, and locks, that needs to be
+-- | consistent for this event to also be consistent.
+cfdRVPredict
+  :: PartialHistory h
+  => h
+  -> (S.Set Ref, Bool)
+  -> UE
+  -> [UE]
+cfdRVPredict h v u =
+  simulateReverse step ([], (valuesOf u `join` (v `join` False))) (controlFlow h u)  ^. _1
+  where
+    step u'@(Unique _ e') s@(events, branch) =
+      let events' =
+            case operation e' of
+                Read _ _ | branch ->
+                  u':events
+                Acquire r ->
+                  u':events
+                _ ->
+                  events
+      in (events', valuesOf u' `join` branch)
+
+    join (r, b) b2 =
+      (not (S.null r)) || b || b2
 
 controlFlowConsistency
   :: PartialHistory h
   => LockMap
+  -> (h -> (S.Set Ref, Bool) -> UE -> [UE])
   -> S.Set UE
   -> h
   -> LIA UE
-controlFlowConsistency lm us h =
-  consistent (S.empty) (S.unions [ cfc u | u <- S.toList us ])
+controlFlowConsistency lm cfd us h =
+  consistent (S.empty) (S.unions [ cfc (S.empty, False) u | u <- S.toList us ])
   where
-  cfc u = S.fromAscList (controlFlowDependencies h u)
+  cfc v u = S.fromAscList (cfd h v u)
 
   consistent visited deps =
     And [ And $ onReads readConsitency depends
@@ -258,13 +330,17 @@ controlFlowConsistency lm us h =
               And [ r ~> w' | (_, w') <- rwrites ]
             rvwrites ->
               Or
-              [ And $ consistent visited' (cfc w) : w ~> r :
+              [ And $ consistent visited' (cfc (val v) w) : w ~> r :
                 [ Or [ w' ~> w, r ~> w']
                 | (_, w') <- rwrites
                 , w' /= w , w' ~/> w, r ~/> w'
                 ]
               | w <- rvwrites
               ]
+    val v =
+      case v of
+        Object r -> (S.singleton (Ref r), False)
+        _ -> (S.empty, True)
 
     lockConsitency a ref' =
       -- Any acquire we test is already controlFlowConsistent, covered by the
@@ -273,7 +349,7 @@ controlFlowConsistency lm us h =
         Just r ->
           And $
           [ Or
-            [ r' ~> a
+            [ And [ r' ~> a, consistent visited' (cfc (S.empty, False) r') ]
               -- ^ Either the other pair has to come before the the current pair
             , r ~> a'
               -- ^ Or it happened afterwards
@@ -352,20 +428,25 @@ permute prover h a = do
     es = (candidateSet a)
     cnts = prover h es
 
-said :: Prover
-said h es =
+said :: LockMap -> Prover
+said lm h es =
+  And $ (equate es):
+    ([ sc, mhb, controlFlowConsistency lm cfdSaid es] <*> [h])
+
+dirk :: LockMap -> Prover
+dirk lm h es =
   And $ (equate es):
-    ([ sc, mhb, lc, rwc ] <*> [h])
+    ([ sc, mhb, controlFlowConsistency lm cfdDirk es] <*> [h])
 
-kalhauge :: LockMap -> Prover
-kalhauge lm h es =
+rvpredict :: LockMap -> Prover
+rvpredict lm h es =
   And $ (equate es):
-    ([ sc, mhb, controlFlowConsistency lm es] <*> [h])
+    ([ sc, mhb, controlFlowConsistency lm cfdRVPredict es] <*> [h])
 
-free :: Prover
-free h es =
+free :: LockMap -> Prover
+free lm h es =
   And $ (equate es) :
-    ([ sc, mhb ] <*> [h])
+    ([ sc, mhb, controlFlowConsistency lm cfdFree es] <*> [h])
 
 none :: h -> CandidateSet -> LIA UE
 none _ es =
