diff -Nur jchord/README.md jchord/README.md
--- jchord/README.md	2015-11-18 15:48:06.000000000 -0800
+++ jchord/README.md	2015-11-02 22:26:25.000000000 -0800
@@ -1,8 +1,3 @@
-# Introduction
 Chord is a program analysis platform that enables users to productively design, implement, combine, and evaluate a broad variety of static and dynamic program analyses for Java bytecode.
 
-Visit the [Chord project website](http://pag.gatech.edu/chord.html) for more information.
-
-# Discussions
-
-Chord uses Google Groups for discussion. You can find the discussions [here](http://groups.google.com/group/chord-discuss).
+Visit the [Chord project website](http://pag.gatech.edu/chord.html) for more information.
\ No newline at end of file
diff -Nur jchord/extra/runner.pl jchord/extra/runner.pl
--- jchord/extra/runner.pl	2015-11-18 15:48:06.000000000 -0800
+++ jchord/extra/runner.pl	2015-11-02 22:26:25.000000000 -0800
@@ -360,7 +360,7 @@
     "bytecode-count-app" =>
     	[
 		"-Dchord.run.analyses=cipa-0cfa-dlog,src-files-java",
-		"-Dchord.check.exclude=java.,com.,sun.,sunw.,javax.,launcher.",
+		"-Dchord.check.exclude=java.,com.,sun.,sunw.,javax.,launcher.,org.",
 		"-Dchord.scope.reuse=false",
 		"-Dchord.reflect.kind=dynamic",
 	],
diff -Nur jchord/extra/src/chord/analyses/inficfa/alloc/AllocEnvCFAAnalysis.java jchord/extra/src/chord/analyses/inficfa/alloc/AllocEnvCFAAnalysis.java
--- jchord/extra/src/chord/analyses/inficfa/alloc/AllocEnvCFAAnalysis.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/extra/src/chord/analyses/inficfa/alloc/AllocEnvCFAAnalysis.java	2015-11-02 22:26:25.000000000 -0800
@@ -724,6 +724,11 @@
 		jq_Type[] paramTypes = m.getParamTypes();
 		for (int i = 0; i < args.length(); i++) {
 			Register actualReg = args.get(i).getRegister();
+			Register formalReg = rf.get(i);
+			BitSet paramVarPtsTo;
+			if(i == 0 && ((!isStatic && useExtraFilters)  || isReflect)){
+				paramVarPtsTo = callerVarPtsToFiltered;
+			}else if(i == 1 && isReflect && conNewInstIMMap.get(q)!=null){
 			BitSet paramVarPtsTo;
 			if(i == 0 && ((!isStatic && useExtraFilters)  || isReflect)){
 				paramVarPtsTo = callerVarPtsToFiltered;
diff -Nur jchord/main/build.xml jchord/main/build.xml
--- jchord/main/build.xml	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/build.xml	2015-11-02 22:26:25.000000000 -0800
@@ -153,6 +153,7 @@
 				<include name="**/*.txt"/>
 				<include name="**/*.dlog"/>
 				<include name="**/*.datalog"/>
+				<include name="**/*.logic"/>
 				<include name="**/*.xsl"/>
 				<include name="**/*.xml"/>
 				<include name="**/*.dtd"/>
diff -Nur jchord/main/scripts/convert.py jchord/main/scripts/convert.py
--- jchord/main/scripts/convert.py	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/scripts/convert.py	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,108 @@
+#!/usr/bin/env python
+from __future__ import print_function
+import sys
+import re
+import datetime
+from collections import OrderedDict
+import argparse
+
+
+def convert(dlog_path, logic_path=None, verbose=0):
+    v = verbose >= 1; vv = verbose >= 2
+    if logic_path is None:
+        logic_path = re.sub(r'\.dlog$', '.logic', dlog_path)
+    if logic_path == dlog_path:
+        print('Skipping file: {}'.format(dlog_path), file=sys.stderr)
+        return
+    print('Converting {} to {}'.format(dlog_path, logic_path))
+
+    with open(dlog_path) as dfile, open(logic_path, 'w') as lfile:
+        def output(msg, *args, **kwargs):
+            if args or kwargs:
+                msg = msg.format(*args, **kwargs)
+            if vv:
+                print('Output: {}'.format(msg))
+            print(msg, file=lfile)
+
+        output('// Created by convert.py from {} on {}'.format(dlog_path, datetime.datetime.now()))
+        for line in dfile:
+            # skip var order
+            if line.startswith('.bddvarorder'):
+                continue
+            # pass comments through, but catch special name comment
+            m = re.search(r'^\s*#( name=(?P<name>.+))?', line)
+            if m:
+                name = m.group('name')
+                if name:
+                    output('// :name: {}'.format(name))
+                else:
+                    output('// {}'.format(line.rstrip('\n')))
+                continue
+
+            # convert domain includes
+            m = re.search(r'\.include "(?P<dom>\w+)\.dom"', line)
+            if m:
+                if v: print('Found domains: {}'.format(line.rstrip()))
+                output('// :domains: {}'.format(m.group('dom')))
+                continue
+
+            # convert input, output and intermediate relation declarations
+            m = re.search(r'^(?P<relname>[^(]+)\((?P<relsig>[^)]+)\) ?(?P<type>input|output|)\s*(#|$)', line)
+            if m:
+                if v: print('Found relation: {}'.format(line.rstrip()))
+                rtype = m.group('type')
+                if not rtype:
+                    output('// convert.py: following intermediate relation converted to output relation')
+                    rtype = 'output'
+                relname = m.group('relname')
+                sig = m.group('relsig')
+                varToDom = OrderedDict(parseSigParts(sig))
+                output('// :{}s: {}({})'.format(rtype, relname, ','.join(varToDom.itervalues())))
+
+                if rtype == 'output':
+                    reldoms = ', '.join([ dom + '(' + var + ')' for var, dom in varToDom.iteritems() ])
+                    relvars = ','.join(varToDom.iterkeys())
+                    typesig = '{relname}({relvars}) -> {reldoms}.'.format(relname=relname, relvars=relvars, reldoms=reldoms)
+                    output(typesig)
+                continue
+
+            # everything else assumed to be a rule definition or blank
+            outline = line.replace(':-', '<-').rstrip()
+            if outline.endswith('. split'):
+                outline = outline[:-len('split')]
+            output(outline)
+
+
+
+def parseSigParts(relsig):
+    parts = [s.strip().split(':') for s in relsig.split(',')]
+    parts = [[p[0], re.sub(r'[0-9]+$', '', p[1])] for p in parts]
+
+    # can't assume variable names are unique in input file, make sure they are in the output
+    suffixes = {}
+    for i, part in enumerate(parts):
+        var, dom = part
+        if var not in suffixes:
+            suffixes[var] = 1
+        else:
+            suffix = suffixes[var]
+            parts[i][0] = var + str(suffix)
+            suffixes[var] = suffix + 1
+
+    return parts
+
+def _parser():
+    p = argparse.ArgumentParser(description='Convert BDD-style datalog files to LogicBlox format.')
+    p.add_argument('files', nargs='+')
+    p.add_argument('--verbose', '-v', action='count')
+    return p
+
+def main(args=None):
+    if args is None:
+        args = sys.argv[1:]
+    args = _parser().parse_args(args)
+    for arg in args.files:
+        convert(arg, verbose=args.verbose)
+
+if __name__ == '__main__':
+    main()
diff -Nur jchord/main/scripts/fixsigs.sh jchord/main/scripts/fixsigs.sh
--- jchord/main/scripts/fixsigs.sh	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/scripts/fixsigs.sh	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,32 @@
+#!/bin/bash
+
+SCRIPTDIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
+case $OSTYPE in 
+	darwin*)
+		sedcmd=gsed
+		if [ -z "$(type -Pf gsed)" ]; then
+			echo "gsed is required to run on OS X, please install with e.g. MacPorts" >&2
+			exit 1
+		fi
+		;;
+	*)
+		sedcmd=sed
+		;;
+esac
+
+if [ -n "$1" ]; then
+	searchdir="$1"
+	shift
+else
+	searchdir=$(cd "$SCRIPTDIR/../src" && pwd)
+fi
+
+find "$searchdir" -name '*.logic' -print0 | xargs -0 \
+	$sedcmd \
+		-e 's/:inputs: IinvkArg0(I,V)/:inputs: IinvkArg0(I0,V1)/g' \
+		-e 's/:inputs: IinvkArg(I,Z,V)/:inputs: IinvkArg(I0,Z0,V1)/g' \
+		-e 's/:inputs: sub(T,T)/:inputs: sub(T1,T0)/g' \
+		-e 's/:inputs: cha(M,T,M)/:inputs: cha(M1,T1,M0)/g' \
+		-e 's/:inputs: HT(H,T)/:inputs: HT(H0,T1)/g' \
+		-e 's/:inputs: MmethRet(M,Z,V)/:inputs: MmethRet(M0,Z0,V1)/g' \
+		-i  
diff -Nur jchord/main/src/chord/analyses/alias/VCfilter.logic jchord/main/src/chord/analyses/alias/VCfilter.logic
--- jchord/main/src/chord/analyses/alias/VCfilter.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/VCfilter.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,30 @@
+// Created by convert.py from ./src/chord/analyses/alias/VCfilter.dlog on 2015-04-20 13:08:42.230972
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: VCfilter-dlog
+
+// :domains: H
+// :domains: V
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: VHfilter(V,H)
+// :inputs: CH(C,H)
+
+// :outputs: VCfilter(V,C)
+VCfilter(v,c) -> V(v), C(c).
+
+// ###
+// # Constraints
+// ###
+
+VCfilter(v,c) <- VHfilter(v,h), CH(c,h).
+
diff -Nur jchord/main/src/chord/analyses/alias/argCopy.logic jchord/main/src/chord/analyses/alias/argCopy.logic
--- jchord/main/src/chord/analyses/alias/argCopy.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/argCopy.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,47 @@
+// Created by convert.py from ./src/chord/analyses/alias/argCopy.dlog on 2015-04-20 13:08:42.209645
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: argCopy-dlog
+
+// :domains: I
+// :domains: M
+// :domains: V
+// :domains: Z
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: IM(I,M)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: kobjSenM(M)
+// :inputs: epsilonV(V)
+
+// :outputs: MspcMethArg(M,V)
+MspcMethArg(m,v) -> M(m), V(v).
+// :outputs: MordMethArg(M,Z,V)
+MordMethArg(m,z,v) -> M(m), Z(z), V(v).
+
+// :outputs: argCopy(I,V,M,V)
+argCopy(i,u,m,v) -> I(i), V(u), M(m), V(v).
+
+// ###
+// # Constraints
+// ###
+
+//MspcMethArg(m,v)   <- MmethArg(m,0,v), kobjSenM(m), !epsilonV(v).
+//MordMethArg(m,0,v) <- MmethArg(m,0,v), !MspcMethArg(m,v).
+//MordMethArg(m,z,v) <- MmethArg(m,z,v), z!=0.
+
+MspcMethArg(m,v)   <- MmethArg(m,z0,v), Z_index[z0] = 0, kobjSenM(m), !epsilonV(v).
+MordMethArg(m,z0,v) <- MmethArg(m,z0,v), Z_index[z0] = 0, !MspcMethArg(m,v).
+MordMethArg(m,z,v) <- MmethArg(m,z,v), Z_index[z] != 0.
+
+argCopy(i,u,m,v) <- IM(i,m), IinvkArg(i,z,u), MordMethArg(m,z,v).
+
diff -Nur jchord/main/src/chord/analyses/alias/cipa_0cfa.logic jchord/main/src/chord/analyses/alias/cipa_0cfa.logic
--- jchord/main/src/chord/analyses/alias/cipa_0cfa.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/cipa_0cfa.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,202 @@
+// Created by convert.py from src/chord/analyses/alias/cipa_0cfa.dlog on 2015-05-05 12:08:41.912473
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Context-insensitive may-alias/call-graph analysis.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: cipa-0cfa-dlog
+
+// :domains: T
+// :domains: F
+// :domains: M
+// :domains: I
+// :domains: H
+// :domains: V
+// :domains: Z
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: VT(V,T)
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: MmethRet(M0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+
+// #MclsValAsgnInst(m:M0,v:V0,t:T0) input
+// #MgetClassInvkInst(m:M0,i:I0) input
+// #clsTH(t:T0,h:H0) input
+// #objTH(t:T0,h:H0) input
+
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: VV(V,V)
+VV(v1,v2) -> V(v1), V(v2).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: specIMV(I,M,V)
+specIMV(i,m,v) -> I(i), M(m), V(v).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: objValAsgnInst(V,H)
+objValAsgnInst(l,h) -> V(l), H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: objVarAsgnInst(V,V)
+objVarAsgnInst(l,r) -> V(l), V(r).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: getInstFldInst(V,V,F)
+getInstFldInst(l,b,f) -> V(l), V(b), F(f).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: putInstFldInst(V,F,V)
+putInstFldInst(b,f,r) -> V(b), F(f), V(r).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: getStatFldInst(V,F)
+getStatFldInst(l,f) -> V(l), F(f).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: putStatFldInst(F,V)
+putStatFldInst(f,r) -> F(f), V(r).
+
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+// :outputs: VHfilter(V,H)
+VHfilter(v,h) -> V(v), H(h).
+// :outputs: VH(V,H)
+VH(v,h) -> V(v), H(h).
+// :outputs: FH(F,H)
+FH(f,h) -> F(f), H(h).
+// :outputs: HFH(H,F,H)
+HFH(h1,f,h2) -> H(h1), F(f), H(h2).
+// :outputs: rootM(M)
+rootM(m) -> M(m).
+// :outputs: reachableI(I)
+reachableI(i) -> I(i).
+// :outputs: reachableM(M)
+reachableM(m) -> M(m).
+// :outputs: IM(I,M)
+IM(i,m) -> I(i), M(m).
+// :outputs: MM(M,M)
+MM(m,n) -> M(m), M(n).
+
+// ###
+// # Constraints
+// ###
+
+VHfilter(v,h) <- VT(v,t), HT(h,s), sub(s,t).
+//VHfilter(_,0).
+VHfilter(v,h) <- V(v), H_index[h] = 0.
+
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+
+// # base cases: each root method and each class initializer is reachable
+//reachableM(0).
+reachableM(m0) <- M_index[m0] = 0.
+reachableM(m) <- reachableT(t), clinitTM(t,m).
+// # inductive case
+reachableM(m) <- IM(_,m).
+
+reachableI(i) <- MI(m,i), reachableM(m).
+
+// # possibly-multiple-target call sites
+IM(i,m) <- reachableI(i), IinvkArg0(i,v), VH(v,h), IHM(i,h,m).
+// # definitely-single-target call sites
+specIMV(i,m,v) <- specIM(i,m), IinvkArg0(i,v).
+
+IM(i,m) <- reachableI(i), specIMV(i,m,v), VH(v,_).
+IM(i,m) <- reachableI(i), statIM(i,m).
+
+// # arguments and return/throw variables
+VV(v,u) <- IinvkArg(i,z,u), IM(i,m), MmethArg(m,z,v).
+VV(u,v) <- IinvkRet(i,z,u), IM(i,m), MmethRet(m,z,v).
+
+VH(u,h) <- VV(u,v), VH(v,h), VHfilter(u,h).
+
+objValAsgnInst(l,h)   <- reachableM(m), MobjValAsgnInst(m,l,h).
+objVarAsgnInst(l,r)   <- reachableM(m), MobjVarAsgnInst(m,l,r).
+getInstFldInst(l,b,f) <- reachableM(m), MgetInstFldInst(m,l,b,f).
+putInstFldInst(b,f,r) <- reachableM(m), MputInstFldInst(m,b,f,r).
+getStatFldInst(l,f)   <- reachableM(m), MgetStatFldInst(m,l,f).
+putStatFldInst(f,r)   <- reachableM(m), MputStatFldInst(m,f,r).
+
+reachableT(t) <- reachableI(i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableI(i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableI(i), clsForNameIT(i,t).
+
+reachableM(m) <- reachableI(i), objNewInstIM(i,m).
+reachableM(m) <- reachableI(i), conNewInstIM(i,m).
+
+//VH(v,h)  <- reachableI(i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), VHfilter(v,h).
+//VH(v,h)  <- reachableI(i), objNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).
+//VH(v,h2) <- reachableI(i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), VH(u,h), HFH(h,0,h2), VHfilter(v,h2).
+//VH(v,h)  <- reachableI(i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), VHfilter(v,h).
+//VH(v,h)  <- reachableI(i), conNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).
+//VH(v,h)  <- reachableI(i), aryNewInstIH(i,h), IinvkRet(i,0,v), VHfilter(v,h).
+VH(v,h)  <- reachableI(i), objNewInstIM(i,m), MmethArg(m,z0,v), Z_index[z0] = 0, objNewInstIH(i,h), VHfilter(v,h).
+VH(v,h)  <- reachableI(i), objNewInstIH(i,h), IinvkRet(i,z0,v), VHfilter(v,h), Z_index[z0] = 0.
+VH(v,h2) <- reachableI(i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), VH(u,h), HFH(h,f0,h2), VHfilter(v,h2), Z_index[z1] = 1, F_index[f0] = 0.
+VH(v,h)  <- reachableI(i), conNewInstIM(i,m), MmethArg(m,z0,v), Z_index[z0] = 0, conNewInstIH(i,h), VHfilter(v,h).
+VH(v,h)  <- reachableI(i), conNewInstIH(i,h), IinvkRet(i,z0,v), VHfilter(v,h), Z_index[z0] = 0.
+VH(v,h)  <- reachableI(i), aryNewInstIH(i,h), IinvkRet(i,z0,v), VHfilter(v,h), Z_index[z0] = 0.
+
+VH(l,h) <- objValAsgnInst(l,h), VHfilter(l,h).
+VH(l,h) <- objVarAsgnInst(l,r), VH(r,h), VHfilter(l,h).
+VH(l,h2) <- getInstFldInst(l,b,f), VH(b,h1), HFH(h1,f,h2), VHfilter(l,h2). 
+HFH(h1,f,h2) <- putInstFldInst(b,f,r), VH(b,h1), VH(r,h2). 
+VH(l,h) <- getStatFldInst(l,f), FH(f,h), VHfilter(l,h).
+FH(f,h) <- putStatFldInst(f,r), VH(r,h).
+
+// ## See: http://java.sun.com/docs/books/jls/second_edition/html/execution.doc.html
+// ## Section 12.4 Initialization of Classes and Interfaces
+// ## A class or interface type T will be initialized immediately before
+// ## the first occurrence of any one of the following:
+
+// # 1. T is a class and an instance of T is created.
+// # this handles both normal allocation and reflective allocation
+reachableT(t) <- objValAsgnInst(_,h), HT(h,t).
+// # 2. T is a class and a static method declared by T is invoked
+reachableT(t) <- reachableM(m), staticTM(t,m).
+// # 3. A static field declared by T is assigned. 
+reachableT(t) <- putStatFldInst(f,_), staticTF(t,f).
+// # 4. A static field declared by T is used and the reference to the
+// #    field is not a compile-time constant.
+reachableT(t) <- getStatFldInst(_,f), staticTF(t,f).
+// # 5. Before a class is initialized, its direct superclass must be
+// #    initialized.
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+
+//rootM(0).
+rootM(m0) <- M_index[m0] = 0.
+rootM(m) <- reachableT(t), clinitTM(t,m).
+MM(m,n) <- IM(i,n), MI(m,i).
+
diff -Nur jchord/main/src/chord/analyses/alias/cspa_0cfa.logic jchord/main/src/chord/analyses/alias/cspa_0cfa.logic
--- jchord/main/src/chord/analyses/alias/cspa_0cfa.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/cspa_0cfa.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,71 @@
+// Created by convert.py from ./src/chord/analyses/alias/cspa_0cfa.dlog on 2015-04-20 13:08:42.212581
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Adaptor of context-insensitive may-alias/call-graph analysis
+// # to a trivial context-sensitive one.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: cspa-0cfa-dlog
+
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: V
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: CH(C,H)
+// :inputs: VH(V,H)
+// :inputs: FH(F,H)
+// :inputs: HFH(H,F,H)
+// :inputs: rootM(M)
+// :inputs: reachableI(I)
+// :inputs: reachableM(M)
+// :inputs: IM(I,M)
+// :inputs: MM(M,M)
+
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+
+// ###
+// # Constraints
+// ###
+
+//reachableCI(0,i) <- reachableI(i).
+//reachableCM(0,m) <- reachableM(m).
+reachableCI(c0,i) <- reachableI(i), C_index[c0] = 0.
+reachableCM(c0,m) <- reachableM(m), C_index[c0] = 0.
+
+//CVC(0,v,o) <- VH(v,h), CH(o,h).
+CVC(c0,v,o) <- VH(v,h), CH(o,h), C_index[c0] = 0.
+FC(f,o) <- FH(f,h), CH(o,h).
+CFC(o1,f,o2) <- HFH(h1,f,h2), CH(o1,h1), CH(o2,h2).
+//rootCM(0,m) <- rootM(m).
+//CICM(0,i,0,m) <- IM(i,m).
+//CMCM(0,m,0,n) <- MM(m,n).
+rootCM(c0,m) <- rootM(m), C_index[c0] = 0.
+CICM(c0,i,c0,m) <- IM(i,m), C_index[c0] = 0.
+CMCM(c0,m,c0,n) <- MM(m,n), C_index[c0] = 0.
+
diff -Nur jchord/main/src/chord/analyses/alias/cspa_hybrid.logic jchord/main/src/chord/analyses/alias/cspa_hybrid.logic
--- jchord/main/src/chord/analyses/alias/cspa_hybrid.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/cspa_hybrid.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,313 @@
+// Created by convert.py from ./src/chord/analyses/alias/cspa_hybrid.dlog on 2015-04-20 13:08:42.213486
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Hybrid k-CFA and k-object-sensitive may-alias/call-graph analysis.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: cspa-hybrid-dlog
+
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: Z
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+
+// :outputs: RobjValAsgnInst(C,V,H)
+RobjValAsgnInst(c,l,h) -> C(c), V(l), H(h).
+// :outputs: RobjVarAsgnInst(C,V,V)
+RobjVarAsgnInst(c,l,r) -> C(c), V(l), V(r).
+// :outputs: RgetInstFldInst(C,V,V,F)
+RgetInstFldInst(c,l,b,f) -> C(c), V(l), V(b), F(f).
+// :outputs: RputInstFldInst(C,V,F,V)
+RputInstFldInst(c,b,f,r) -> C(c), V(b), F(f), V(r).
+// :outputs: RgetStatFldInst(C,V,F)
+RgetStatFldInst(c,l,f) -> C(c), V(l), F(f).
+// :outputs: RputStatFldInst(C,F,V)
+RputStatFldInst(c,f,r) -> C(c), F(f), V(r).
+
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: MspcMethArg(M,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: argCopy(I,V,M,V)
+// :inputs: retCopy(I,V,M,V)
+// :inputs: VCfilter(V,C)
+
+// :inputs: CC(C,C)
+// :inputs: CH(C,H)
+// :inputs: CI(C,I)
+// :inputs: epsilonM(M)
+// :inputs: kobjSenM(M)
+// :inputs: kcfaSenM(M)
+// :inputs: ctxtCpyM(M)
+// :inputs: epsilonV(V)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+
+// :outputs: kcfaDIC(C,I,C)
+kcfaDIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIC(C,I,C)
+DIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIH(C,I,H)
+DIH(c,i,h) -> C(c), I(i), H(h).
+
+// :outputs: DVDV(C,V,C,V)
+DVDV(c,u,d,v) -> C(c), V(u), C(d), V(v).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: ctxtInsIHM(I,H,M)
+ctxtInsIHM(i,h,m) -> I(i), H(h), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: kcfaSenIHM(I,H,M)
+kcfaSenIHM(i,h,m) -> I(i), H(h), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: kobjSenIHM(I,H,M)
+kobjSenIHM(i,h,m) -> I(i), H(h), M(m).
+
+// :outputs: ctxtInsICM(I,C,M)
+ctxtInsICM(i,c,m) -> I(i), C(c), M(m).
+// :outputs: kcfaSenICM(I,C,M)
+kcfaSenICM(i,c,m) -> I(i), C(c), M(m).
+// :outputs: kobjSenICM(I,C,M)
+kobjSenICM(i,c,m) -> I(i), C(c), M(m).
+
+// :outputs: ctxtInsSpecIM(I,M)
+ctxtInsSpecIM(i,m) -> I(i), M(m).
+// :outputs: kcfaSenSpecIM(I,M)
+kcfaSenSpecIM(i,m) -> I(i), M(m).
+// :outputs: kobjSenSpecIM(I,M)
+kobjSenSpecIM(i,m) -> I(i), M(m).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: ctxtInsStatIM(I,M)
+ctxtInsStatIM(i,m) -> I(i), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: kcfaSenStatIM(I,M)
+kcfaSenStatIM(i,m) -> I(i), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: ctxtCpyStatIM(I,M)
+ctxtCpyStatIM(i,m) -> I(i), M(m).
+
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+
+// :outputs: DVC(C,V,C)
+DVC(c1,v,c2) -> C(c1), V(v), C(c2).
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+
+// :outputs: CIC(C,I,C)
+CIC(c,i,d) -> C(c), I(i), C(d).
+// :outputs: CHC(C,H,C)
+CHC(c,h,d) -> C(c), H(h), C(d).
+
+// ###
+// # Constraints
+// ###
+
+CIC(c,i,d) <- CC(c,d), CI(d,i).
+CHC(c,h,d) <- CC(c,d), CH(d,h).
+
+// ###
+
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+ctxtInsIHM(i,h,m) <- IHM(i,h,m), epsilonM(m).
+kobjSenIHM(i,h,m) <- IHM(i,h,m), kobjSenM(m).
+kcfaSenIHM(i,h,m) <- IHM(i,h,m), kcfaSenM(m).
+
+ctxtInsICM(i,o,m) <- ctxtInsIHM(i,h,m), CH(o,h).
+kcfaSenICM(i,o,m) <- kcfaSenIHM(i,h,m), CH(o,h).
+kobjSenICM(i,o,m) <- kobjSenIHM(i,h,m), CH(o,h).
+
+kcfaSenSpecIM(i,m) <- specIM(i,m), kcfaSenM(m).
+ctxtInsSpecIM(i,m) <- specIM(i,m), epsilonM(m).
+kobjSenSpecIM(i,m) <- specIM(i,m), kobjSenM(m).
+
+kcfaSenStatIM(i,m) <- statIM(i,m), kcfaSenM(m).
+ctxtInsStatIM(i,m) <- statIM(i,m), epsilonM(m).
+ctxtCpyStatIM(i,m) <- statIM(i,m), ctxtCpyM(m).
+
+// ###
+
+//reachableCM(0,0).
+reachableCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//reachableCM(0,m) <- clinitTM(t,m), reachableT(t).
+reachableCM(c0,m) <- clinitTM(t,m), reachableT(t), C_index[c0] = 0.
+
+reachableCM(c,m) <- CICM(_,_,c,m).
+
+reachableCI(c,i) <- MI(m,i), reachableCM(c,m).
+
+// ###
+
+DIC(c,i,o) <- IinvkArg0(i,v), DVC(c,v,o).
+DIH(c,i,h) <- DIC(c,i,o), CH(o,h).
+DI(c,i) <- DIH(c,i,_).
+
+//kcfaDIC(0,i,d) <- CIC(0,i,d), MI(m,i), epsilonM(m).
+kcfaDIC(c0,i,d) <- CIC(c0,i,d), MI(m,i), epsilonM(m), C_index[c0] = 0.
+kcfaDIC(c,i,d) <- CIC(c,i,d), MI(m,i), kobjSenM(m).
+kcfaDIC(c,i,d) <- CIC(c,i,d), MI(m,i), ctxtCpyM(m).
+kcfaDIC(c,i,d) <- CIC(c,i,d), MI(m,i), kcfaSenM(m).
+
+// ###
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h), C_index[c0] = 0.
+CICM(c,i,o,m) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o).
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenIHM(i,h,m), DIH(c,i,h), kcfaDIC(c,i,d).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i), C_index[c0] = 0.
+CICM(c,i,o,m) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o).
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenSpecIM(i,m), DI(c,i), kcfaDIC(c,i,d).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), ctxtCpyStatIM(i,m), d=c.
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenStatIM(i,m), kcfaDIC(c,i,d).
+
+// ###
+
+DVC(c,v,o) <- reachableCM(c,m), MspcMethArg(m,v), o=c.
+
+// ###
+
+DVDV(d,v,c,u) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV(c,u,d,v) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+
+DVC(c,u,o) <- DVDV(c,u,d,v), DVC(d,v,o), VCfilter(u,o).
+
+// ###
+
+RobjValAsgnInst(c,l,h) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+DVC(c,l,o) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+
+// ###
+
+RobjVarAsgnInst(c,l,r) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+DVC(c,l,c1) <- RobjVarAsgnInst(c,l,r), DVC(c,r,c1), VCfilter(l,c1).
+
+// ###
+
+RgetInstFldInst(c,l,b,f) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+DVC(c,l,c2) <- RgetInstFldInst(c,l,b,f), DVC(c,b,c1), CFC(c1,f,c2). 
+
+// ###
+
+RgetStatFldInst(c,l,f) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+DVC(c,l,o) <- RgetStatFldInst(c,l,f), FC(f,o).
+
+// ###
+
+RputInstFldInst(c,b,f,r) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+CFC(c1,f,c2) <- RputInstFldInst(c,b,f,r), DVC(c,b,c1), DVC(c,r,c2). 
+
+// ###
+
+RputStatFldInst(c,f,r) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+FC(f,o) <- RputStatFldInst(c,f,r), DVC(c,r,o).
+
+// ### reflection handling rules
+
+reachableCM(c,m) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM(c,m) <- reachableCI(c,i), conNewInstIM(i,m).
+
+//DVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//DVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//DVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), DVC(c,u,o), CFC(o,0,o2).
+//DVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//DVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//DVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+DVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), DVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+
+// ###
+
+DVC(_,v,o) <- DVC(_,v,o), epsilonV(v).
+
+// ###
+
+reachableT(t) <- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), clsForNameIT(i,t).
+
+reachableT(t) <- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
+reachableT(t) <- reachableCM(_,m), staticTM(t,m).
+reachableT(t) <- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
+reachableT(t) <- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+
+// ###
+
+//CVC(0,v,o) <- DVC(_,v,o),  epsilonV(v).
+CVC(c0,v,o) <- DVC(_,v,o),  epsilonV(v), C_index[c0] = 0.
+CVC(c,v,o) <- DVC(c,v,o), !epsilonV(v).
+
+//rootCM(0,0).
+//rootCM(0,m) <- reachableT(t), clinitTM(t,m).
+rootCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+rootCM(c0,m) <- reachableT(t), clinitTM(t,m), C_index[c0] = 0.
+CMCM(c,m,d,n) <- CICM(c,i,d,n), MI(m,i).
+
diff -Nur jchord/main/src/chord/analyses/alias/cspa_kcfa.logic jchord/main/src/chord/analyses/alias/cspa_kcfa.logic
--- jchord/main/src/chord/analyses/alias/cspa_kcfa.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/cspa_kcfa.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,266 @@
+// Created by convert.py from ./src/chord/analyses/alias/cspa_kcfa.dlog on 2015-04-20 13:08:42.221107
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # k-CFA may-alias/call-graph analysis.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: cspa-kcfa-dlog
+
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: Z
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+
+// :outputs: RobjValAsgnInst(C,V,H)
+RobjValAsgnInst(c,l,h) -> C(c), V(l), H(h).
+// :outputs: RobjVarAsgnInst(C,V,V)
+RobjVarAsgnInst(c,l,r) -> C(c), V(l), V(r).
+// :outputs: RgetInstFldInst(C,V,V,F)
+RgetInstFldInst(c,l,b,f) -> C(c), V(l), V(b), F(f).
+// :outputs: RputInstFldInst(C,V,F,V)
+RputInstFldInst(c,b,f,r) -> C(c), V(b), F(f), V(r).
+// :outputs: RgetStatFldInst(C,V,F)
+RgetStatFldInst(c,l,f) -> C(c), V(l), F(f).
+// :outputs: RputStatFldInst(C,F,V)
+RputStatFldInst(c,f,r) -> C(c), F(f), V(r).
+
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: argCopy(I,V,M,V)
+// :inputs: retCopy(I,V,M,V)
+// :inputs: VCfilter(V,C)
+
+// :inputs: CC(C,C)
+// :inputs: CH(C,H)
+// :inputs: CI(C,I)
+// :inputs: epsilonM(M)
+// :inputs: kcfaSenM(M)
+// :inputs: epsilonV(V)
+
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+
+// :outputs: kcfaDIC(C,I,C)
+kcfaDIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIC(C,I,C)
+DIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIH(C,I,H)
+DIH(c,i,h) -> C(c), I(i), H(h).
+// :outputs: DI(C,I)
+DI(c,i) -> C(c), I(i).
+
+// :outputs: DVDV(C,V,C,V)
+DVDV(c,u,d,v) -> C(c), V(u), C(d), V(v).
+
+// :outputs: ctxtInsIHM(I,H,M)
+ctxtInsIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: kcfaSenIHM(I,H,M)
+kcfaSenIHM(i,h,m) -> I(i), H(h), M(m).
+
+// :outputs: ctxtInsSpecIM(I,M)
+ctxtInsSpecIM(i,m) -> I(i), M(m).
+// :outputs: kcfaSenSpecIM(I,M)
+kcfaSenSpecIM(i,m) -> I(i), M(m).
+
+// :outputs: ctxtInsStatIM(I,M)
+ctxtInsStatIM(i,m) -> I(i), M(m).
+// :outputs: kcfaSenStatIM(I,M)
+kcfaSenStatIM(i,m) -> I(i), M(m).
+
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+
+// :outputs: DVC(C,V,C)
+DVC(c1,v,c2) -> C(c1), V(v), C(c2).
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+
+// :outputs: CIC(C,I,C)
+CIC(c,i,d) -> C(c), I(i), C(d).
+// :outputs: CHC(C,H,C)
+CHC(c,h,d) -> C(c), H(h), C(d).
+
+// ###
+// # Constraints
+// ###
+
+CIC(c,i,d) <- CC(c,d), CI(d,i).
+CHC(c,h,d) <- CC(c,d), CH(d,h).
+
+// ###
+
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+ctxtInsIHM(i,h,m) <- IHM(i,h,m), epsilonM(m).
+kcfaSenIHM(i,h,m) <- IHM(i,h,m), kcfaSenM(m).
+
+kcfaSenSpecIM(i,m) <- specIM(i,m), kcfaSenM(m).
+ctxtInsSpecIM(i,m) <- specIM(i,m), epsilonM(m).
+
+kcfaSenStatIM(i,m) <- statIM(i,m), kcfaSenM(m).
+ctxtInsStatIM(i,m) <- statIM(i,m), epsilonM(m).
+
+// ###
+
+//reachableCM(0,0).
+//reachableCM(0,m) <- clinitTM(t,m), reachableT(t).
+reachableCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+reachableCM(c0,m) <- C_index[c0] = 0, clinitTM(t,m), reachableT(t).
+reachableCM(c,m) <- CICM(_,_,c,m).
+reachableCI(c,i) <- MI(m,i), reachableCM(c,m).
+
+// ###
+
+DIC(c,i,o) <- IinvkArg0(i,v), DVC(c,v,o).
+DIH(c,i,h) <- DIC(c,i,o), CH(o,h).
+DI(c,i) <- DIH(c,i,_).
+
+//kcfaDIC(0,i,d) <- CIC(0,i,d), MI(m,i), epsilonM(m).
+kcfaDIC(c0,i,d) <- C_index[c0] = 0, CIC(c0,i,d), MI(m,i), epsilonM(m).
+kcfaDIC(c,i,d) <- CIC(c,i,d), MI(m,i), kcfaSenM(m).
+
+// ###
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,c0,m) <- C_index[c0] = 0, reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenIHM(i,h,m), DIH(c,i,h), kcfaDIC(c,i,d).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,c0,m) <- C_index[c0] = 0, reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenSpecIM(i,m), DI(c,i), kcfaDIC(c,i,d).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,c0,m) <- C_index[c0] = 0, reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenStatIM(i,m), kcfaDIC(c,i,d).
+
+// ### inter-procedural
+
+DVDV(d,v,c,u) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV(c,u,d,v) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+
+DVC(c,u,o) <- DVDV(c,u,d,v), DVC(d,v,o), VCfilter(u,o).
+
+// ### in context c, l = new h
+
+RobjValAsgnInst(c,l,h) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+DVC(c,l,o) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+
+// ### in context c, l = r
+
+RobjVarAsgnInst(c,l,r) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+DVC(c,l,c1) <- RobjVarAsgnInst(c,l,r), DVC(c,r,c1), VCfilter(l,c1).
+
+// ### in context c, l = b.f
+
+RgetInstFldInst(c,l,b,f) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+DVC(c,l,c2) <- RgetInstFldInst(c,l,b,f), DVC(c,b,c1), CFC(c1,f,c2). 
+
+// ### in context c, l = STATIC.f
+
+RgetStatFldInst(c,l,f) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+DVC(c,l,o) <- RgetStatFldInst(c,l,f), FC(f,o).
+
+// ### in context c, b.f = r
+
+RputInstFldInst(c,b,f,r) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+CFC(c1,f,c2) <- RputInstFldInst(c,b,f,r), DVC(c,b,c1), DVC(c,r,c2). 
+
+// ### in context c, STATIC.f = r
+
+RputStatFldInst(c,f,r) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+FC(f,o) <- RputStatFldInst(c,f,r), DVC(c,r,o).
+
+// ### reflection handling rules
+
+reachableCM(c,m) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM(c,m) <- reachableCI(c,i), conNewInstIM(i,m).
+
+DVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+DVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+DVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), DVC(c,u,o), CFC(o,0,o2).
+DVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+DVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+DVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+
+// ### epsilonV(v): treat v context-insensitively
+
+DVC(_,v,o) <- DVC(_,v,o), epsilonV(v).
+
+// ### rules propagating reachableT
+
+reachableT(t) <- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), clsForNameIT(i,t).
+
+reachableT(t) <- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
+reachableT(t) <- reachableCM(_,m), staticTM(t,m).
+reachableT(t) <- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
+reachableT(t) <- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+
+// ### CVC <- DVC (clean up context-insensitive stuff)
+
+//CVC(0,v,o) <- DVC(_,v,o),  epsilonV(v).
+CVC(c0,v,o) <- C_index[c0] = 0, DVC(_,v,o),  epsilonV(v).
+CVC(c,v,o) <- DVC(c,v,o), !epsilonV(v).
+
+//rootCM(0,0).
+rootCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//rootCM(0,m) <- reachableT(t), clinitTM(t,m).
+rootCM(c0,m) <- C_index[c0] = 0, reachableT(t), clinitTM(t,m).
+CMCM(c,m,d,n) <- CICM(c,i,d,n), MI(m,i).
diff -Nur jchord/main/src/chord/analyses/alias/cspa_kobj.logic jchord/main/src/chord/analyses/alias/cspa_kobj.logic
--- jchord/main/src/chord/analyses/alias/cspa_kobj.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/cspa_kobj.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,279 @@
+// Created by convert.py from ./src/chord/analyses/alias/cspa_kobj.dlog on 2015-04-20 13:08:42.226720
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # k-object-sensitive may-alias/call-graph analysis.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: cspa-kobj-dlog
+
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: Z
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+
+// :outputs: RobjValAsgnInst(C,V,H)
+RobjValAsgnInst(c,l,h) -> C(c), V(l), H(h).
+// :outputs: RobjVarAsgnInst(C,V,V)
+RobjVarAsgnInst(c,l,r) -> C(c), V(l), V(r).
+// :outputs: RgetInstFldInst(C,V,V,F)
+RgetInstFldInst(c,l,b,f) -> C(c), V(l), V(b), F(f).
+// :outputs: RputInstFldInst(C,V,F,V)
+RputInstFldInst(c,b,f,r) -> C(c), V(b), F(f), V(r).
+// :outputs: RgetStatFldInst(C,V,F)
+RgetStatFldInst(c,l,f) -> C(c), V(l), F(f).
+// :outputs: RputStatFldInst(C,F,V)
+RputStatFldInst(c,f,r) -> C(c), F(f), V(r).
+
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: MspcMethArg(M,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: argCopy(I,V,M,V)
+// :inputs: retCopy(I,V,M,V)
+// :inputs: VCfilter(V,C)
+
+// :inputs: CC(C,C)
+// :inputs: CH(C,H)
+// :inputs: CI(C,I)
+// :inputs: epsilonM(M)
+// :inputs: kobjSenM(M)
+// :inputs: ctxtCpyM(M)
+// :inputs: epsilonV(V)
+
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+
+// :outputs: DIC(C,I,C)
+DIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIH(C,I,H)
+DIH(c,i,h) -> C(c), I(i), H(h).
+// :outputs: DI(C,I)
+DI(c,i) -> C(c), I(i).
+
+// :outputs: DVDV(C,V,C,V)
+DVDV(c,u,d,v) -> C(c), V(u), C(d), V(v).
+
+// :outputs: ctxtInsIHM(I,H,M)
+ctxtInsIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: kobjSenIHM(I,H,M)
+kobjSenIHM(i,h,m) -> I(i), H(h), M(m).
+
+// :outputs: kobjSenICM(I,C,M)
+kobjSenICM(i,c,m) -> I(i), C(c), M(m).
+
+// :outputs: ctxtInsSpecIM(I,M)
+ctxtInsSpecIM(i,m) -> I(i), M(m).
+// :outputs: kobjSenSpecIM(I,M)
+kobjSenSpecIM(i,m) -> I(i), M(m).
+
+// :outputs: ctxtInsStatIM(I,M)
+ctxtInsStatIM(i,m) -> I(i), M(m).
+// :outputs: ctxtCpyStatIM(I,M)
+ctxtCpyStatIM(i,m) -> I(i), M(m).
+
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+
+// :outputs: DVC(C,V,C)
+DVC(c1,v,c2) -> C(c1), V(v), C(c2).
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+
+// :outputs: CIC(C,I,C)
+CIC(c,i,d) -> C(c), I(i), C(d).
+// :outputs: CHC(C,H,C)
+CHC(c,h,d) -> C(c), H(h), C(d).
+
+// ###
+// # Constraints
+// ###
+
+CIC(c,i,d) <- CC(c,d), CI(d,i).
+CHC(c,h,d) <- CC(c,d), CH(d,h).
+
+// ###
+
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+ctxtInsIHM(i,h,m) <- IHM(i,h,m), epsilonM(m).
+kobjSenIHM(i,h,m) <- IHM(i,h,m), kobjSenM(m).
+
+kobjSenICM(i,o,m) <- kobjSenIHM(i,h,m), CH(o,h).
+
+ctxtInsSpecIM(i,m) <- specIM(i,m), epsilonM(m).
+kobjSenSpecIM(i,m) <- specIM(i,m), kobjSenM(m).
+
+ctxtInsStatIM(i,m) <- statIM(i,m), epsilonM(m).
+ctxtCpyStatIM(i,m) <- statIM(i,m), ctxtCpyM(m).
+
+// ###
+
+//reachableCM(0,0).
+reachableCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//reachableCM(0,m) <- clinitTM(t,m), reachableT(t).
+reachableCM(c0,m) <- clinitTM(t,m), reachableT(t), C_index[c0] = 0.
+
+reachableCM(c,m) <- CICM(_,_,c,m).
+
+reachableCI(c,i) <- MI(m,i), reachableCM(c,m).
+
+// ###
+
+DIC(c,i,o) <- IinvkArg0(i,v), DVC(c,v,o).
+DIH(c,i,h) <- DIC(c,i,o), CH(o,h).
+DI(c,i) <- DIH(c,i,_).
+
+// ###
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h), C_index[c0] = 0.
+CICM(c,i,o,m) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i), C_index[c0] = 0.
+CICM(c,i,o,m) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), ctxtCpyStatIM(i,m), d=c.
+
+// ###
+
+DVC(c,v,o) <- reachableCM(c,m), MspcMethArg(m,v), o=c.
+
+// ###
+
+DVDV(d,v,c,u) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV(c,u,d,v) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+
+DVC(c,u,o) <- DVDV(c,u,d,v), DVC(d,v,o), VCfilter(u,o).
+
+// ###
+
+RobjValAsgnInst(c,l,h) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+DVC(c,l,o) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+
+// ###
+
+RobjVarAsgnInst(c,l,r) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+DVC(c,l,c1) <- RobjVarAsgnInst(c,l,r), DVC(c,r,c1), VCfilter(l,c1).
+
+// ###
+
+RgetInstFldInst(c,l,b,f) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+DVC(c,l,c2) <- RgetInstFldInst(c,l,b,f), DVC(c,b,c1), CFC(c1,f,c2). 
+
+// ###
+
+RgetStatFldInst(c,l,f) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+DVC(c,l,o) <- RgetStatFldInst(c,l,f), FC(f,o).
+
+// ###
+
+RputInstFldInst(c,b,f,r) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+CFC(c1,f,c2) <- RputInstFldInst(c,b,f,r), DVC(c,b,c1), DVC(c,r,c2). 
+
+// ###
+
+RputStatFldInst(c,f,r) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+FC(f,o) <- RputStatFldInst(c,f,r), DVC(c,r,o).
+
+// ## reflection handling rules
+
+reachableCM(c,m) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM(c,m) <- reachableCI(c,i), conNewInstIM(i,m).
+
+//DVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//DVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//DVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), DVC(c,u,o), CFC(o,0,o2).
+//DVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//DVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//DVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+DVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), DVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+DVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+
+// ### epsilonV(v): treat v context-insensitively
+
+DVC(_,v,o) <- DVC(_,v,o), epsilonV(v).
+
+// ### rules propagating reachableT
+
+reachableT(t) <- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), clsForNameIT(i,t).
+
+reachableT(t) <- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
+reachableT(t) <- reachableCM(_,m), staticTM(t,m).
+reachableT(t) <- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
+reachableT(t) <- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+
+// ### CVC <- DVC (clean up context-insensitive stuff)
+
+//CVC(0,v,o) <- DVC(_,v,o),  epsilonV(v).
+CVC(c0,v,o) <- DVC(_,v,o),  epsilonV(v), C_index[c0] = 0.
+CVC(c,v,o) <- DVC(c,v,o), !epsilonV(v).
+
+//rootCM(0,0).
+rootCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//rootCM(0,m) <- reachableT(t), clinitTM(t,m).
+rootCM(c0,m) <- reachableT(t), clinitTM(t,m), C_index[c0] = 0.
+CMCM(c,m,d,n) <- CICM(c,i,d,n), MI(m,i).
diff -Nur jchord/main/src/chord/analyses/alias/retCopy.logic jchord/main/src/chord/analyses/alias/retCopy.logic
--- jchord/main/src/chord/analyses/alias/retCopy.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alias/retCopy.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,32 @@
+// Created by convert.py from ./src/chord/analyses/alias/retCopy.dlog on 2015-04-20 13:08:42.230556
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: retCopy-dlog
+
+// :domains: I
+// :domains: M
+// :domains: V
+// :domains: Z
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: IM(I,M)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: MmethRet(M0,Z0,V1)
+
+// :outputs: retCopy(I,V,M,V)
+retCopy(i,u,m,v) -> I(i), V(u), M(m), V(v).
+
+// ###
+// # Constraints
+// ###
+
+retCopy(i,u,m,v) <- IM(i,m), IinvkRet(i,z,u), MmethRet(m,z,v).
+
diff -Nur jchord/main/src/chord/analyses/alloc/checkExcludedH.logic jchord/main/src/chord/analyses/alloc/checkExcludedH.logic
--- jchord/main/src/chord/analyses/alloc/checkExcludedH.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/alloc/checkExcludedH.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,14 @@
+// Created by convert.py from ./src/chord/analyses/alloc/checkExcludedH.dlog on 2015-04-20 13:08:42.231350
+// :name: checkExcludedH-dlog
+
+// :domains: M
+// :domains: H
+
+
+// :inputs: checkExcludedM(M)
+// :inputs: MH(M,H)
+// :outputs: checkExcludedH(H)
+checkExcludedH(h) -> H(h).
+
+checkExcludedH(h) <- MH(m,h), checkExcludedM(m).
+
diff -Nur jchord/main/src/chord/analyses/datarace/datarace.logic jchord/main/src/chord/analyses/datarace/datarace.logic
--- jchord/main/src/chord/analyses/datarace/datarace.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/datarace/datarace.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,129 @@
+// Created by convert.py from ./src/chord/analyses/datarace/datarace.dlog on 2015-04-20 13:08:42.231754
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: datarace-dlog
+
+// :domains: A
+// :domains: F
+// :domains: E
+// :domains: H
+// :domains: M
+// :domains: L
+// :domains: K
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: writeE(E)
+// :inputs: ME(M,E)
+// :inputs: EF(E,F)
+// :inputs: statF(F)
+// :inputs: reachableAM(A,M)
+// :inputs: checkExcludedM(M)
+// :inputs: excludeInitMethods(K)
+// :inputs: initM(M)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: statE(E)
+statE(e) -> E(e).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: rdOrWrAEF(A,E,F)
+rdOrWrAEF(a,e,f) -> A(a), E(e), F(f).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: onlyWrAEF(A,E,F)
+onlyWrAEF(a,e,f) -> A(a), E(e), F(f).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: relevantAM(A,M)
+relevantAM(a,m) -> A(a), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: relevantAE(A,E)
+relevantAE(a,e) -> A(a), E(e).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: excludeInitM(M)
+excludeInitM(m) -> M(m).
+
+// ###
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: startingRace(A,E,A,E)
+startingRace(a1,e1,a2,e2) -> A(a1), E(e1), A(a2), E(e2).
+
+// ###
+
+// :inputs: EH(E,H)
+// :outputs: escapingRace(A,E,A,E)
+escapingRace(a1,e1,a2,e2) -> A(a1), E(e1), A(a2), E(e2).
+
+// ###
+
+// :inputs: mhe(E,A,A)
+// :outputs: parallelRace(A,E,A,E)
+parallelRace(a1,e1,a2,e2) -> A(a1), E(e1), A(a2), E(e2).
+
+// ###
+
+// :inputs: syncLH(L,H)
+// :inputs: unlockedE(A,E,H)
+// :inputs: excludeSameThread(K)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: guardedE(A,E,H)
+guardedE(t,e,o) -> A(t), E(e), H(o).
+// :outputs: unlikelyRace(A,E,A,E)
+unlikelyRace(a1,e1,a2,e2) -> A(a1), E(e1), A(a2), E(e2).
+
+// :outputs: ultimateRace(A,E,A,E)
+ultimateRace(a1,e1,a2,e2) -> A(a1), E(e1), A(a2), E(e2).
+// :outputs: raceEEH(E,E,H)
+raceEEH(e1,e2,h) -> E(e1), E(e2), H(h).
+// :outputs: racePairs(E,E)
+racePairs(e1,e2) -> E(e1), E(e2).
+
+// ###
+// # Constraints
+// ###
+
+//excludeInitM(m) <- excludeInitMethods(1), initM(m).
+excludeInitM(m) <- excludeInitMethods(k1), initM(m), K_index[k1] = 1.
+
+relevantAM(a,m) <- reachableAM(a,m), !checkExcludedM(m), !excludeInitM(m).
+
+relevantAE(a,e) <- relevantAM(a,m), ME(m,e).
+
+rdOrWrAEF(a,e,f) <- relevantAE(a,e), EF(e,f).
+onlyWrAEF(a,e,f) <- relevantAE(a,e), EF(e,f), writeE(e).
+
+startingRace(a1,e1,a2,e2) <- onlyWrAEF(a1,e1,f), rdOrWrAEF(a2,e2,f), e1 < e2.
+startingRace(a1,e1,a2,e2) <- rdOrWrAEF(a1,e1,f), onlyWrAEF(a2,e2,f), e1 < e2.
+startingRace(a1,e1,a2,e2) <- onlyWrAEF(a1,e1,f), onlyWrAEF(a2,e2,f), e1 = e2, a1 <= a2.
+
+// ###
+
+statE(e) <- EF(e,f), statF(f).
+
+escapingRace(a1,e1,a2,e2) <- startingRace(a1,e1,a2,e2), EH(e1,h), EH(e2,h).
+escapingRace(a1,e1,a2,e2) <- startingRace(a1,e1,a2,e2), statE(e1), statE(e2).
+
+// ###
+
+parallelRace(a1,e1,a2,e2) <- escapingRace(a1,e1,a2,e2), mhe(e1,a1,a2), mhe(e2,a2,a1).
+
+// ###
+
+syncH(h) <- syncLH(_,h).
+guardedE(t,e,h) <- relevantAE(t,e), syncH(h), !unlockedE(t,e,h).
+
+unlikelyRace(a1,e1,a2,e2) <- parallelRace(a1,e1,a2,e2), guardedE(a1,e1,h), guardedE(a2,e2,h).
+//unlikelyRace(a1,e1,a2,e2) <- parallelRace(a1,e1,a2,e2), excludeSameThread(1), a1=a2.
+unlikelyRace(a1,e1,a2,e2) <- parallelRace(a1,e1,a2,e2), excludeSameThread(k1), a1=a2, K_index[k1] = 1.
+
+ultimateRace(a1,e1,a2,e2) <- parallelRace(a1,e1,a2,e2), !unlikelyRace(a1,e1,a2,e2).
+
+raceEEH(e1,e2,h) <- ultimateRace(_,e1,_,e2), EH(e1,h), EH(e2,h).
+racePairs(e1,e2) <- ultimateRace(_,e1,_,e2).
+
diff -Nur jchord/main/src/chord/analyses/datarace/escaping_exclude.logic jchord/main/src/chord/analyses/datarace/escaping_exclude.logic
--- jchord/main/src/chord/analyses/datarace/escaping_exclude.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/datarace/escaping_exclude.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,25 @@
+// Created by convert.py from ./src/chord/analyses/datarace/escaping_exclude.dlog on 2015-04-20 13:08:42.234063
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: datarace-escaping-exclude-dlog
+
+// :domains: H
+// :domains: E
+// :domains: V
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: VH(V,H)
+// :inputs: EV(E,V)
+// :outputs: EH(E,H)
+EH(e,h) -> E(e), H(h).
+
+EH(e,h) <- EV(e,v), VH(v,h).
+
diff -Nur jchord/main/src/chord/analyses/datarace/escaping_include.logic jchord/main/src/chord/analyses/datarace/escaping_include.logic
--- jchord/main/src/chord/analyses/datarace/escaping_include.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/datarace/escaping_include.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,27 @@
+// Created by convert.py from ./src/chord/analyses/datarace/escaping_include.dlog on 2015-04-20 13:08:42.234565
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: datarace-escaping-include-dlog
+
+// :domains: H
+// :domains: E
+// :domains: V
+// :domains: P
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: escPVH(P,V,H)
+// :inputs: PE(P,E)
+// :inputs: EV(E,V)
+// :outputs: EH(E,H)
+EH(e,h) -> E(e), H(h).
+
+EH(e,h) <- PE(p,e), EV(e,v), escPVH(p,v,h).
+
diff -Nur jchord/main/src/chord/analyses/datarace/nongrded_exclude.logic jchord/main/src/chord/analyses/datarace/nongrded_exclude.logic
--- jchord/main/src/chord/analyses/datarace/nongrded_exclude.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/datarace/nongrded_exclude.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,27 @@
+// Created by convert.py from ./src/chord/analyses/datarace/nongrded_exclude.dlog on 2015-04-20 13:08:42.234955
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: datarace-nongrded-exclude-dlog
+
+// :domains: A
+// :domains: H
+// :domains: E
+
+
+// ###
+// # Relations
+// ###
+
+// :outputs: unlockedE(A,E,H)
+unlockedE(t,e,h) -> A(t), E(e), H(h).
+
+// ###
+// # Constraints
+// ###
+
+unlockedE(_,_,_).
+
diff -Nur jchord/main/src/chord/analyses/datarace/nongrded_include.logic jchord/main/src/chord/analyses/datarace/nongrded_include.logic
--- jchord/main/src/chord/analyses/datarace/nongrded_include.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/datarace/nongrded_include.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,66 @@
+// Created by convert.py from ./src/chord/analyses/datarace/nongrded_include.dlog on 2015-04-20 13:08:42.235257
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: datarace-nongrded-include-dlog
+
+// :domains: A
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: E
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: MI(M,I)
+// :inputs: ME(M,E)
+// :inputs: IM(I,M)
+// :inputs: threadAM(A,M)
+// :inputs: transLI(L,I)
+// :inputs: transLE(L,E)
+// :inputs: threadStartI(I)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: invkLock(I,H)
+invkLock(i,h) -> I(i), H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: elemLock(E,H)
+elemLock(e,h) -> E(e), H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncH(H)
+syncH(h) -> H(h).
+
+// :inputs: syncLH(L,H)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: unlockedM(A,M,H)
+unlockedM(t,m,h) -> A(t), M(m), H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: unlockedI(A,I,H)
+unlockedI(t,i,h) -> A(t), I(i), H(h).
+// :outputs: unlockedE(A,E,H)
+unlockedE(t,e,h) -> A(t), E(e), H(h).
+
+// ###
+// # Constraints
+// ###
+
+syncH(h) <- syncLH(_,h).
+
+invkLock(i,o) <- transLI(l,i), syncLH(l,o).
+elemLock(e,o) <- transLE(l,e), syncLH(l,o).
+
+unlockedM(t,m,o) <- syncH(o), threadAM(t,m).
+
+unlockedI(t,i,o) <- unlockedM(t,m,o), MI(m,i), !invkLock(i,o), !threadStartI(i).
+unlockedM(t,n,o) <- unlockedI(t,i,o), IM(i,n).
+
+unlockedE(t,e,o) <- unlockedM(t,m,o), ME(m,e), !elemLock(e,o).
+
diff -Nur jchord/main/src/chord/analyses/datarace/parallel_exclude.logic jchord/main/src/chord/analyses/datarace/parallel_exclude.logic
--- jchord/main/src/chord/analyses/datarace/parallel_exclude.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/datarace/parallel_exclude.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,22 @@
+// Created by convert.py from ./src/chord/analyses/datarace/parallel_exclude.dlog on 2015-04-20 13:08:42.236115
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: datarace-parallel-exclude-dlog
+
+// :domains: A
+// :domains: E
+
+
+// ###
+// # Relations
+// ###
+
+// :outputs: mhe(E,A,A)
+mhe(e,t1,t2) -> E(e), A(t1), A(t2).
+
+mhe(_,_,_).
+
diff -Nur jchord/main/src/chord/analyses/datarace/parallel_include.logic jchord/main/src/chord/analyses/datarace/parallel_include.logic
--- jchord/main/src/chord/analyses/datarace/parallel_include.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/datarace/parallel_include.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,25 @@
+// Created by convert.py from ./src/chord/analyses/datarace/parallel_include.dlog on 2015-04-20 13:08:42.236376
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: datarace-parallel-include-dlog
+
+// :domains: A
+// :domains: E
+// :domains: P
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: PE(P,E)
+// :inputs: mhp(P,A,A)
+// :outputs: mhe(E,A,A)
+mhe(e,t1,t2) -> E(e), A(t1), A(t2).
+
+mhe(e,t1,t2) <- mhp(p,t1,t2), PE(p,e).
+
diff -Nur jchord/main/src/chord/analyses/deadlock/deadlock.logic jchord/main/src/chord/analyses/deadlock/deadlock.logic
--- jchord/main/src/chord/analyses/deadlock/deadlock.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/deadlock.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,60 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/deadlock.dlog on 2015-04-20 13:08:42.236709
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-dlog
+
+// :domains: A
+// :domains: L
+// :domains: M
+// :domains: H
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: escLH(L,H)
+// :inputs: mhpTLTL(A,L,A,L)
+// :inputs: syncTLL(A,L,L)
+// :inputs: guarded(A,A,L,L)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: escLL(L,L)
+escLL(l1,l2) -> L(l1), L(l2).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: deadlock1(L,L,L,L)
+deadlock1(l1,l2,l3,l4) -> L(l1), L(l2), L(l3), L(l4).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: deadlock2(A,L,L,A,L,L)
+deadlock2(t1,l1,l2,t2,l3,l4) -> A(t1), L(l1), L(l2), A(t2), L(l3), L(l4).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: deadlock3(A,L,L,A,L,L)
+deadlock3(t1,l1,l2,t2,l3,l4) -> A(t1), L(l1), L(l2), A(t2), L(l3), L(l4).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: deadlock4(A,L,L,A,L,L)
+deadlock4(t1,l1,l2,t2,l3,l4) -> A(t1), L(l1), L(l2), A(t2), L(l3), L(l4).
+// :outputs: deadlock (A,L,L,A,L,L)
+deadlock (t1,l1,l2,t2,l3,l4) -> A(t1), L(l1), L(l2), A(t2), L(l3), L(l4).
+
+// ###
+// # Constraints
+// ###
+
+escLL(l1,l2) <- escLH(l1,o), escLH(l2,o).
+
+deadlock1(l1,l2,l3,l4) <- escLL(l1,l4), escLL(l2,l3).
+
+deadlock2(t1,l1,l2,t2,l3,l4) <- deadlock1(l1,l2,l3,l4), syncTLL(t1,l1,l2), syncTLL(t2,l3,l4).
+
+deadlock3(t1,l1,l2,t2,l3,l4) <- deadlock2(t1,l1,l2,t2,l3,l4), mhpTLTL(t2,l4,t1,l2).
+
+deadlock4(t1,l1,l2,t2,l3,l4) <- deadlock3(t1,l1,l2,t2,l3,l4), !guarded(t1,t2,l1,l3).
+
+deadlock(t1,l1,l2,t2,l3,l4) <- deadlock4(t1,l1,l2,t2,l3,l4), t1<t2.
+deadlock(t1,l1,l2,t2,l3,l4) <- deadlock4(t1,l1,l2,t2,l3,l4), t1=t2, l1<l3.
+deadlock(t1,l1,l2,t2,l3,l4) <- deadlock4(t1,l1,l2,t2,l3,l4), t1=t2, l1=l3, l2<=l4.
+
diff -Nur jchord/main/src/chord/analyses/deadlock/escaping_exclude.logic jchord/main/src/chord/analyses/deadlock/escaping_exclude.logic
--- jchord/main/src/chord/analyses/deadlock/escaping_exclude.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/escaping_exclude.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,39 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/escaping_exclude.dlog on 2015-04-20 13:08:42.237796
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-escaping-exclude-dlog
+
+// :domains: M
+// :domains: V
+// :domains: L
+// :domains: T
+// :domains: F
+// :domains: P
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: PL(P,L)
+// :inputs: syncLV(L,V)
+// :inputs: syncLM(L,M)
+// :inputs: thisMV(M,V)
+// :inputs: VH(V,H)
+// :inputs: TM(T,M)
+// :outputs: escLH(L,H)
+escLH(l,o) -> L(l), H(o).
+
+// ###
+// # Constraints
+// ###
+
+// #escLH(l,o) :- syncLM(l,m), statM(m), TM(t,m), clsTF(t,f), FC(f,o).
+
+escLH(l,o) <- syncLV(l,v), VH(v,o).
+escLH(l,o) <- syncLM(l,m), thisMV(m,v), VH(v,o).
+
diff -Nur jchord/main/src/chord/analyses/deadlock/escaping_include.logic jchord/main/src/chord/analyses/deadlock/escaping_include.logic
--- jchord/main/src/chord/analyses/deadlock/escaping_include.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/escaping_include.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,41 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/escaping_include.dlog on 2015-04-20 13:08:42.238405
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-escaping-include-dlog
+
+// :domains: M
+// :domains: V
+// :domains: L
+// :domains: P
+// :domains: T
+// :domains: F
+// :domains: H
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: PL(P,L)
+// :inputs: syncLV(L,V)
+// :inputs: syncLM(L,M)
+// :inputs: thisMV(M,V)
+// :inputs: MPhead(M,P)
+// :inputs: escPVH(P,V,H)
+// :inputs: TM(T,M)
+// :outputs: escLH(L,H)
+escLH(l,o) -> L(l), H(o).
+
+// ###
+// # Constraints
+// ###
+
+// #escLH(l,o) :- syncLM(l,m), statM(m), TM(t,m), clsTF(t,f), FC(f,o).
+
+escLH(l,o) <- syncLV(l,v), PL(p,l), escPVH(p,v,o).
+escLH(l,o) <- syncLM(l,m), thisMV(m,v), MPhead(m,p), escPVH(p,v,o).
+
diff -Nur jchord/main/src/chord/analyses/deadlock/nongrded_exclude.logic jchord/main/src/chord/analyses/deadlock/nongrded_exclude.logic
--- jchord/main/src/chord/analyses/deadlock/nongrded_exclude.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/nongrded_exclude.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,26 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/nongrded_exclude.dlog on 2015-04-20 13:08:42.239392
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-nongrded-exclude-dlog
+
+// :domains: A
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :outputs: guarded(A,A,L,L)
+guarded(t1,t2,l1,l3) -> A(t1), A(t2), L(l1), L(l3).
+
+// ###
+// # Constraints
+// ###
+
+guarded(t,_,_,_) <- t<0.
+
diff -Nur jchord/main/src/chord/analyses/deadlock/nongrded_include.logic jchord/main/src/chord/analyses/deadlock/nongrded_include.logic
--- jchord/main/src/chord/analyses/deadlock/nongrded_include.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/nongrded_include.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,72 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/nongrded_include.dlog on 2015-04-20 13:08:42.239867
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-nongrded-include-dlog
+
+// :domains: I
+// :domains: M
+// :domains: V
+// :domains: A
+// :domains: L
+// :domains: H
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: threadAM(A,M)
+// :inputs: reachableAM(A,M)
+// :inputs: threadStartI(I)
+// :inputs: MI(M,I)
+// :inputs: IM(I,M)
+// :inputs: ML(M,L)
+// :inputs: syncLH(L,H)
+// :inputs: transLL(L,L)
+// :inputs: transLI(L,I)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncH(H)
+syncH(h) -> H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: invkLock(I,H)
+invkLock(i,o) -> I(i), H(o).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: unguardedM(A,M,H)
+unguardedM(a,m,o) -> A(a), M(m), H(o).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: unguardedI(A,I,H)
+unguardedI(a,i,o) -> A(a), I(i), H(o).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: guardedM(A,M,H)
+guardedM(a,m,o) -> A(a), M(m), H(o).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: guardedL(A,L,H)
+guardedL(a,n,o) -> A(a), L(n), H(o).
+
+// # Threads t1, t2 may hold a common lock when they execute l1, l2 respectively.
+// :outputs: guarded(A,A,L,L)
+guarded(t1,t2,l1,l2) -> A(t1), A(t2), L(l1), L(l2).
+
+// ###
+// # Constraints
+// ###
+
+syncH(o) <- syncLH(_,o).
+invkLock(i,o) <- transLI(l,i), syncLH(l,o).
+
+unguardedM(t,m,o) <- syncH(o), threadAM(t,m).
+unguardedI(t,i,o) <- unguardedM(t,m,o), MI(m,i), !invkLock(i,o), !threadStartI(i).
+unguardedM(t,n,o) <- unguardedI(t,i,o), IM(i,n).
+
+guardedM(t,m,o) <- syncH(o), reachableAM(t,m), !unguardedM(t,m,o).
+
+guardedL(t,l,o) <- ML(m,l), guardedM(t,m,o).
+guardedL(_,l,o) <- transLL(l1,l), syncLH(l1,o).
+
+guarded(t1,t2,l1,l3) <- guardedL(t1,l1,o), guardedL(t2,l3,o).
+
diff -Nur jchord/main/src/chord/analyses/deadlock/nonreent_exclude.logic jchord/main/src/chord/analyses/deadlock/nonreent_exclude.logic
--- jchord/main/src/chord/analyses/deadlock/nonreent_exclude.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/nonreent_exclude.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,60 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/nonreent_exclude.dlog on 2015-04-20 13:08:42.241027
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-nonreent-exclude-dlog
+
+// :domains: M
+// :domains: V
+// :domains: A
+// :domains: L
+// :domains: I
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: ML(M,L)
+// :inputs: MI(M,I)
+// :inputs: threadStartI(I)
+// :inputs: threadAM(A,M)
+// :inputs: IM(I,M)
+// :inputs: transLI(L,I)
+// :inputs: transLL(L,L)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncMN(M,L)
+syncMN(m,n) -> M(m), L(n).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncIN(I,L)
+syncIN(i,n) -> I(i), L(n).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncMLL(M,L,L)
+syncMLL(m,l1,l2) -> M(m), L(l1), L(l2).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncILL(I,L,L)
+syncILL(i,l1,l2) -> I(i), L(l1), L(l2).
+// :outputs: syncTLL(A,L,L)
+syncTLL(t,l1,l2) -> A(t), L(l1), L(l2).
+
+// ###
+// # Constraints
+// ###
+
+syncML(m,l) <- ML(m,l).
+syncIL(i,l) <- IM(i,m), syncML(m,l), !threadStartI(i).
+syncML(m,l) <- MI(m,i), syncIL(i,l).
+
+syncMLL(m,l1,l2) <- transLL(l1,l2), ML(m,l1), ML(m,l2).
+syncMLL(m,l1,l2) <- transLI(l1,i), MI(m,i), syncIL(i,l2).
+syncMLL(m,l1,l2) <- MI(m,i), syncILL(i,l1,l2).
+
+syncILL(i,l1,l2) <- IM(i,m), syncMLL(m,l1,l2), !threadStartI(i).
+
+syncTLL(t,l1,l2) <- threadAM(t,m), syncMLL(m,l1,l2).
+
diff -Nur jchord/main/src/chord/analyses/deadlock/nonreent_include.logic jchord/main/src/chord/analyses/deadlock/nonreent_include.logic
--- jchord/main/src/chord/analyses/deadlock/nonreent_include.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/nonreent_include.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,85 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/nonreent_include.dlog on 2015-04-20 13:08:42.242677
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-nonreent-include-dlog
+
+// :domains: M
+// :domains: V
+// :domains: A
+// :domains: L
+// :domains: I
+// :domains: H
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: ML(M,L)
+// :inputs: MI(M,I)
+// :inputs: threadAM(A,M)
+// :inputs: IM(I,M)
+// :inputs: threadStartI(I)
+// :inputs: syncLH(L,H)
+// :inputs: transLL(L,L)
+// :inputs: transLI(L,I)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: mayAliasedUptoL(L)
+mayAliasedUptoL(n) -> L(n).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: notAliasedUptoL(L)
+notAliasedUptoL(n) -> L(n).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: mayAliasedUptoLI(L,I)
+mayAliasedUptoLI(n,i) -> L(n), I(i).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: notAliasedUptoLI(L,I)
+notAliasedUptoLI(n,i) -> L(n), I(i).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncML(M,L)
+syncML(m,n) -> M(m), L(n).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncIL(I,L)
+syncIL(i,n) -> I(i), L(n).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncMLL(M,L,L)
+syncMLL(m,l1,l2) -> M(m), L(l1), L(l2).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: syncILL(I,L,L)
+syncILL(i,l1,l2) -> I(i), L(l1), L(l2).
+// :outputs: syncTLL(A,L,L)
+syncTLL(t,l1,l2) -> A(t), L(l1), L(l2).
+
+// ###
+// # Constraints
+// ###
+
+mayAliasedUptoLI(n,i) <- transLI(l2,i), syncLH(n,o), syncLH(l2,o).
+mayAliasedUptoL(n) <- transLL(l1,n), syncLH(l1,o), syncLH(n,o).
+
+notAliasedUptoLI(n,i) <- !mayAliasedUptoLI(n,i).
+notAliasedUptoL(n) <- !mayAliasedUptoL(n).
+
+syncML(m,l) <- notAliasedUptoL(l), ML(m,l).
+syncIL(i,l) <- IM(i,m), syncML(m,l), !threadStartI(i).
+syncML(m,l) <- syncIL(i,l), MI(m,i), notAliasedUptoLI(l,i).
+
+syncMLL(m,l1,l2) <- transLI(l1,i), MI(m,i), syncIL(i,l2), notAliasedUptoLI(l2,i), notAliasedUptoL(l1).
+
+syncMLL(m,l1,l2) <- transLL(l1,l2), ML(m,l1), ML(m,l2), notAliasedUptoL(l1), notAliasedUptoL(l2).
+
+syncILL(i,l1,l2) <- IM(i,m), syncMLL(m,l1,l2), !threadStartI(i).
+
+syncMLL(m,l1,l2) <- MI(m,i), syncILL(i,l1,l2), notAliasedUptoLI(l1,i), notAliasedUptoLI(l2,i).
+
+syncTLL(t,l1,l2) <- threadAM(t,m), syncMLL(m,l1,l2).
+
+
diff -Nur jchord/main/src/chord/analyses/deadlock/parallel_exclude.logic jchord/main/src/chord/analyses/deadlock/parallel_exclude.logic
--- jchord/main/src/chord/analyses/deadlock/parallel_exclude.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/parallel_exclude.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,26 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/parallel_exclude.dlog on 2015-04-20 13:08:42.244239
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-parallel-exclude-dlog
+
+// :domains: A
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :outputs: mhpTLTL(A,L,A,L)
+mhpTLTL(t1,l1,t2,l2) -> A(t1), L(l1), A(t2), L(l2).
+
+// ###
+// # Constraints
+// ###
+
+mhpTLTL(_,_,_,_).
+
diff -Nur jchord/main/src/chord/analyses/deadlock/parallel_include.logic jchord/main/src/chord/analyses/deadlock/parallel_include.logic
--- jchord/main/src/chord/analyses/deadlock/parallel_include.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/deadlock/parallel_include.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,33 @@
+// Created by convert.py from ./src/chord/analyses/deadlock/parallel_include.dlog on 2015-04-20 13:08:42.244741
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: deadlock-parallel-include-dlog
+
+// :domains: A
+// :domains: L
+// :domains: P
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: PL(P,L)
+// :inputs: mhp(P,A,A)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: mhl(L,A,A)
+mhl(l,t1,t2) -> L(l), A(t1), A(t2).
+// :outputs: mhpTLTL(A,L,A,L)
+mhpTLTL(t1,l1,t2,l2) -> A(t1), L(l1), A(t2), L(l2).
+
+// ###
+// # Constraints
+// ###
+
+mhl(l,t1,t2) <- mhp(p,t1,t2), PL(p,l).
+mhpTLTL(t1,l1,t2,l2) <- mhl(l1,t1,t2), mhl(l2,t2,t1).
+
diff -Nur jchord/main/src/chord/analyses/escape/dynLocE_to_queryE.logic jchord/main/src/chord/analyses/escape/dynLocE_to_queryE.logic
--- jchord/main/src/chord/analyses/escape/dynLocE_to_queryE.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/escape/dynLocE_to_queryE.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,20 @@
+// Created by convert.py from ./src/chord/analyses/escape/dynLocE_to_queryE.dlog on 2015-04-20 13:08:42.245375
+// :name: dynLocE-queryE-dlog
+
+// :domains: E
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: dynLocE(E)
+// :outputs: queryE(E)
+queryE(e) -> E(e).
+
+// ###
+// # Constraints
+// ###
+
+queryE(e) <- dynLocE(e).
+
diff -Nur jchord/main/src/chord/analyses/escape/flowins_thresc.logic jchord/main/src/chord/analyses/escape/flowins_thresc.logic
--- jchord/main/src/chord/analyses/escape/flowins_thresc.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/escape/flowins_thresc.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,49 @@
+// Created by convert.py from ./src/chord/analyses/escape/flowins_thresc.dlog on 2015-04-20 13:08:42.245680
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: flowins-thresc-dlog
+
+// :domains: M
+// :domains: V
+// :domains: H
+// :domains: P
+// :domains: Z
+// :domains: F
+// :domains: E
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: queryE(E)
+// :inputs: VH(V,H)
+// :inputs: FH(F,H)
+// :inputs: HFH(H,F,H)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: MV(M,V)
+// :inputs: MP(M,P)
+// :inputs: EV(E,V)
+// :outputs: escH(H)
+escH(o) -> H(o).
+// :outputs: escPVH(P,V,H)
+escPVH(p,v,h) -> P(p), V(v), H(h).
+// :outputs: escE(E)
+escE(e) -> E(e).
+
+// ###
+// # Constraints
+// ###
+
+escH(h) <- FH(_,h).
+//escH(h) <- MmethArg(1,0,v), VH(v,h).
+escH(h) <- MmethArg(m1,z0,v), VH(v,h), M_index[m1] = 1, Z_index[z0] = 0.
+escH(h2) <- HFH(h1,_,h2), escH(h1).
+
+escPVH(p,v,h) <- VH(v,h), MV(m,v), MP(m,p), escH(h). 
+escE(e) <- queryE(e), EV(e,v), VH(v,h), escH(h).
+
diff -Nur jchord/main/src/chord/analyses/escape/metaback/IterThrEscAnalysis.java jchord/main/src/chord/analyses/escape/metaback/IterThrEscAnalysis.java
--- jchord/main/src/chord/analyses/escape/metaback/IterThrEscAnalysis.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/analyses/escape/metaback/IterThrEscAnalysis.java	2015-11-02 22:26:25.000000000 -0800
@@ -390,6 +390,21 @@
 		return in.encode();
 	}
 
+	private void fillInQuery(List<Quad> queries){
+		queries.clear();
+		queries.add(domE.get(20514));
+		queries.add(domE.get(20531));
+		queries.add(domE.get(20533));
+		queries.add(domE.get(20532));
+		queries.add(domE.get(20529));
+		queries.add(domE.get(20156));
+		queries.add(domE.get(20157));
+		queries.add(domE.get(20534));
+		queries.add(domE.get(19992));
+		queries.add(domE.get(20530));
+		queries.add(domE.get(19993));
+	}
+	
 	public DNF getErrSuf(Quad q) {
 		Operator ro = q.getOperator();
 		RegisterOperand rx;
diff -Nur jchord/main/src/chord/analyses/escape/trivial_locEH.logic jchord/main/src/chord/analyses/escape/trivial_locEH.logic
--- jchord/main/src/chord/analyses/escape/trivial_locEH.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/escape/trivial_locEH.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,28 @@
+// Created by convert.py from ./src/chord/analyses/escape/trivial_locEH.dlog on 2015-04-20 13:08:42.246380
+// :name: trivial-locEH-dlog
+
+// :domains: H
+// :domains: E
+// :domains: M
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: queryE(E)
+// :inputs: reachableM(M)
+// :inputs: MH(M,H)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: reachableH(H)
+reachableH(h) -> H(h).
+// :outputs: locEH(E,H)
+locEH(e,h) -> E(e), H(h).
+
+// ###
+// # Constraints
+// ###
+
+reachableH(h) <- reachableM(m), MH(m,h).
+locEH(e,h) <- queryE(e), reachableH(h).
+
diff -Nur jchord/main/src/chord/analyses/escape/zcfa_locEH.logic jchord/main/src/chord/analyses/escape/zcfa_locEH.logic
--- jchord/main/src/chord/analyses/escape/zcfa_locEH.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/escape/zcfa_locEH.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,27 @@
+// Created by convert.py from ./src/chord/analyses/escape/zcfa_locEH.dlog on 2015-04-20 13:08:42.246823
+// :name: zcfa-locEH-dlog
+
+// :domains: V
+// :domains: H
+// :domains: F
+// :domains: E
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: queryE(E)
+// :inputs: VH(V,H)
+// :inputs: HFH(H,F,H)
+// :inputs: EV(E,V)
+// :outputs: locEH(E,H)
+locEH(e,h) -> E(e), H(h).
+
+// ###
+// # Constraints
+// ###
+
+locEH(e,h) <- queryE(e), EV(e,v), VH(v,h).
+locEH(e,h) <- locEH(e,h2), HFH(h,_,h2).
+
diff -Nur jchord/main/src/chord/analyses/heapacc/checkExcludedE.logic jchord/main/src/chord/analyses/heapacc/checkExcludedE.logic
--- jchord/main/src/chord/analyses/heapacc/checkExcludedE.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/heapacc/checkExcludedE.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,14 @@
+// Created by convert.py from ./src/chord/analyses/heapacc/checkExcludedE.dlog on 2015-04-20 13:08:42.247303
+// :name: checkExcludedE-dlog
+
+// :domains: M
+// :domains: E
+
+
+// :inputs: checkExcludedM(M)
+// :inputs: ME(M,E)
+// :outputs: checkExcludedE(E)
+checkExcludedE(e) -> E(e).
+
+checkExcludedE(e) <- ME(m,e), checkExcludedM(m).
+
diff -Nur jchord/main/src/chord/analyses/inst/PobjVarAsgnInst.logic jchord/main/src/chord/analyses/inst/PobjVarAsgnInst.logic
--- jchord/main/src/chord/analyses/inst/PobjVarAsgnInst.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/inst/PobjVarAsgnInst.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,24 @@
+// Created by convert.py from ./src/chord/analyses/inst/PobjVarAsgnInst.dlog on 2015-04-20 13:08:42.247697
+// :name: PobjVarAsgnInst-dlog
+
+// :domains: Z
+// :domains: V
+// :domains: P
+
+
+// ### Relations
+
+// :inputs: PobjVarMoveInst(P,V,V)
+// :inputs: PobjVarCastInst(P,V,V)
+// :inputs: objPhiSrc(P,Z,V)
+// :inputs: objPhiDst(P,V)
+
+// :outputs: PobjVarAsgnInst(P,V,V)
+PobjVarAsgnInst(p,l,r) -> P(p), V(l), V(r).
+
+// ### Constraints
+
+PobjVarAsgnInst(p,l,r) <- PobjVarMoveInst(p,l,r).
+PobjVarAsgnInst(p,l,r) <- PobjVarCastInst(p,l,r).
+PobjVarAsgnInst(p,l,r) <- objPhiDst(p,l), objPhiSrc(p,_,r).
+
diff -Nur jchord/main/src/chord/analyses/inst/RelPobjNullAsgnInst.java jchord/main/src/chord/analyses/inst/RelPobjNullAsgnInst.java
--- jchord/main/src/chord/analyses/inst/RelPobjNullAsgnInst.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/analyses/inst/RelPobjNullAsgnInst.java	2015-11-02 22:26:25.000000000 -0800
@@ -6,7 +6,6 @@
 import joeq.Compiler.Quad.Operator;
 import joeq.Compiler.Quad.Quad;
 import joeq.Compiler.Quad.Operand.RegisterOperand;
-import joeq.Compiler.Quad.Operator.CheckCast;
 import joeq.Compiler.Quad.Operator.Move;
 import joeq.Compiler.Quad.Operator.New;
 import joeq.Compiler.Quad.Operator.NewArray;
@@ -14,7 +13,6 @@
 import chord.analyses.alloc.DomH;
 import chord.analyses.point.DomP;
 import chord.analyses.var.DomV;
-import chord.program.visitors.ICastInstVisitor;
 import chord.program.visitors.IMoveInstVisitor;
 import chord.project.Chord;
 import chord.project.analyses.ProgramRel;
@@ -27,7 +25,7 @@
  * @author Xin Zhang
  */
 @Chord(name = "PobjNullAsgnInst", sign = "P0,V0:P0_V0")
-public class RelPobjNullAsgnInst extends ProgramRel implements IMoveInstVisitor, ICastInstVisitor{
+public class RelPobjNullAsgnInst extends ProgramRel implements IMoveInstVisitor {
 	public void visit(jq_Class c) {
 	}
 
@@ -44,15 +42,4 @@
 			}
 		}
 	}
-	
-	public void visitCastInst(Quad q) {
-        Operand rx = CheckCast.getSrc(q);
-        if (!(rx instanceof RegisterOperand)) {
-            RegisterOperand lo = CheckCast.getDest(q);
-            if (lo.getType().isReferenceType()) {
-                Register l = lo.getRegister();
-                add(q, l);
-            }
-        }
-    }
 }
diff -Nur jchord/main/src/chord/analyses/invk/checkExcludedI.logic jchord/main/src/chord/analyses/invk/checkExcludedI.logic
--- jchord/main/src/chord/analyses/invk/checkExcludedI.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/invk/checkExcludedI.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,14 @@
+// Created by convert.py from ./src/chord/analyses/invk/checkExcludedI.dlog on 2015-04-20 13:08:42.248421
+// :name: checkExcludedI-dlog
+
+// :domains: I
+// :domains: M
+
+
+// :inputs: MI(M,I)
+// :inputs: checkExcludedM(M)
+// :outputs: checkExcludedI(I)
+checkExcludedI(i) -> I(i).
+
+checkExcludedI(i) <- MI(m,i), checkExcludedM(m).
+
diff -Nur jchord/main/src/chord/analyses/invk/checkIncludedI.logic jchord/main/src/chord/analyses/invk/checkIncludedI.logic
--- jchord/main/src/chord/analyses/invk/checkIncludedI.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/invk/checkIncludedI.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,14 @@
+// Created by convert.py from ./src/chord/analyses/invk/checkIncludedI.dlog on 2015-04-20 13:08:42.248890
+// :name: checkIncludedI-dlog
+
+// :domains: I
+// :domains: M
+
+
+// :inputs: MI(M,I)
+// :inputs: checkIncludedM(M)
+// :outputs: checkIncludedI(I)
+checkIncludedI(i) -> I(i).
+
+checkIncludedI(i) <- MI(m,i), checkIncludedM(m).
+
diff -Nur jchord/main/src/chord/analyses/lock/LE.logic jchord/main/src/chord/analyses/lock/LE.logic
--- jchord/main/src/chord/analyses/lock/LE.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/lock/LE.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,29 @@
+// Created by convert.py from ./src/chord/analyses/lock/LE.dlog on 2015-04-20 13:08:42.249369
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: LE-dlog
+
+// :domains: E
+// :domains: L
+// :domains: P
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: LP(L,P)
+// :inputs: PE(P,E)
+// :outputs: LE(L,E)
+LE(l,e) -> L(l), E(e).
+
+// ###
+// # Constraints
+// ###
+
+LE(l,e) <- LP(l,p), PE(p,e).
+
diff -Nur jchord/main/src/chord/analyses/lock/LI.logic jchord/main/src/chord/analyses/lock/LI.logic
--- jchord/main/src/chord/analyses/lock/LI.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/lock/LI.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,29 @@
+// Created by convert.py from ./src/chord/analyses/lock/LI.dlog on 2015-04-20 13:08:42.249921
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: LI-dlog
+
+// :domains: I
+// :domains: L
+// :domains: P
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: LP(L,P)
+// :inputs: PI(P,I)
+// :outputs: LI(L,I)
+LI(l,i) -> L(l), I(i).
+
+// ###
+// # Constraints
+// ###
+
+LI(l,i) <- LP(l,p), PI(p,i).
+
diff -Nur jchord/main/src/chord/analyses/lock/syncLH.logic jchord/main/src/chord/analyses/lock/syncLH.logic
--- jchord/main/src/chord/analyses/lock/syncLH.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/lock/syncLH.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,36 @@
+// Created by convert.py from ./src/chord/analyses/lock/syncLH.dlog on 2015-04-20 13:08:42.250330
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: syncLH-dlog
+
+// :domains: H
+// :domains: M
+// :domains: V
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: VH(V,H)
+// :inputs: thisMV(M,V)
+// :inputs: syncLM(L,M)
+// :inputs: syncLV(L,V)
+
+// :outputs: syncLH(L,H)
+syncLH(l,h) -> L(l), H(h).
+
+// ###
+// # Constraints
+// ###
+
+// #syncLH(l,o) :- syncLM(l,m), statM(m), TM(t,m), clsTF(t,f), FC(f,o).
+
+syncLH(l,h) <- syncLM(l,m), thisMV(m,v), VH(v,h).
+syncLH(l,h) <- syncLV(l,v), VH(v,h).
+
diff -Nur jchord/main/src/chord/analyses/lock/threadReachableL.logic jchord/main/src/chord/analyses/lock/threadReachableL.logic
--- jchord/main/src/chord/analyses/lock/threadReachableL.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/lock/threadReachableL.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,28 @@
+// Created by convert.py from ./src/chord/analyses/lock/threadReachableL.dlog on 2015-04-20 13:08:42.251083
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: thread-reachableL-dlog
+
+// :domains: M
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: threadReachableM(M)
+// :inputs: ML(M,L)
+// :outputs: threadReachableL(L)
+threadReachableL(l) -> L(l).
+
+// ###
+// # Constraints
+// ###
+
+threadReachableL(l) <- threadReachableM(m), ML(m,l).
+
diff -Nur jchord/main/src/chord/analyses/lock/transLE.logic jchord/main/src/chord/analyses/lock/transLE.logic
--- jchord/main/src/chord/analyses/lock/transLE.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/lock/transLE.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,30 @@
+// Created by convert.py from ./src/chord/analyses/lock/transLE.dlog on 2015-04-20 13:08:42.251655
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: transLE-dlog
+
+// :domains: E
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: LE(L,E)
+// :inputs: LL(L,L)
+
+// :outputs: transLE(L,E)
+transLE(l,e) -> L(l), E(e).
+
+// ###
+// # Constraints
+// ###
+
+transLE(l,e) <- LE(l,e).
+transLE(l,e) <- LL(l,l2), transLE(l2,e).
+
diff -Nur jchord/main/src/chord/analyses/lock/transLI.logic jchord/main/src/chord/analyses/lock/transLI.logic
--- jchord/main/src/chord/analyses/lock/transLI.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/lock/transLI.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,30 @@
+// Created by convert.py from ./src/chord/analyses/lock/transLI.dlog on 2015-04-20 13:08:42.252268
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: transLI-dlog
+
+// :domains: I
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: LI(L,I)
+// :inputs: LL(L,L)
+
+// :outputs: transLI(L,I)
+transLI(l,i) -> L(l), I(i).
+
+// ###
+// # Constraints
+// ###
+
+transLI(l,i) <- LI(l,i).
+transLI(l,i) <- LL(l,l2), transLI(l2,i).
+
diff -Nur jchord/main/src/chord/analyses/lock/transLL.logic jchord/main/src/chord/analyses/lock/transLL.logic
--- jchord/main/src/chord/analyses/lock/transLL.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/lock/transLL.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,27 @@
+// Created by convert.py from ./src/chord/analyses/lock/transLL.dlog on 2015-04-20 13:08:42.252890
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: transLL-dlog
+
+// :domains: L
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: LL(L,L)
+// :outputs: transLL(L,L)
+transLL(l1,l2) -> L(l1), L(l2).
+
+// ###
+// # Constraints
+// ###
+
+transLL(l1,l2) <- LL(l1,l2).
+transLL(l1,l2) <- transLL(l1,l3), transLL(l3,l2).
+
diff -Nur jchord/main/src/chord/analyses/logicblox/LogicBloxExportAnalysis.java jchord/main/src/chord/analyses/logicblox/LogicBloxExportAnalysis.java
--- jchord/main/src/chord/analyses/logicblox/LogicBloxExportAnalysis.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/logicblox/LogicBloxExportAnalysis.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,106 @@
+package chord.analyses.logicblox;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import chord.bddbddb.Dom;
+import chord.bddbddb.Rel;
+import chord.logicblox.LogicBloxExporter;
+import chord.logicblox.LogicBloxUtils;
+import chord.project.Chord;
+import chord.project.ChordException;
+import chord.project.ClassicProject;
+import chord.project.Config;
+import chord.project.Config.DatalogEngineType;
+import chord.project.Messages;
+import chord.project.analyses.JavaAnalysis;
+import chord.project.analyses.ProgramRel;
+import chord.util.Utils;
+
+/**
+ * A task that exports all targets to a LogicBlox workspace.
+ * <p>
+ * This is not a real analysis, but simply takes every completed target and 
+ * exports it to LogicBlox.  All config options relevant to LB are used except 
+ * that <tt>chord.logicblox.export.mode</tt> indicates the LB engine type  
+ * (<tt>chord.datalog.engine</tt> should be set to <tt>bddbddb</tt>).  LB 4 is 
+ * used by default.
+ * <p>
+ * To use this exporter, simply run it as the last analysis in the series, for example 
+ * using options like:<br />
+ * <code>-Dchord.datalog.engine=bddbddb -Dchord.run.analyses=ctxts-java,argCopy-dlog,logicblox-export</code>
+ * 
+ * @author Jake Cobb <tt>&lt;jake.cobb@gatech.edu&gt;</tt>
+ */
+@Chord(name = "logicblox-export")
+public class LogicBloxExportAnalysis extends JavaAnalysis {
+    private DatalogEngineType logicbloxType;
+
+    public LogicBloxExportAnalysis() {
+        logicbloxType = Utils.buildEnumProperty("chord.logicblox.export.mode", DatalogEngineType.LOGICBLOX4);
+        switch (logicbloxType) {
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            break;
+        default:
+            throw new ChordException("Unsupported chord.logicblox.export.mode type: " + logicbloxType);
+        }
+    }
+    
+    @Override
+    public void run() {
+        boolean v = Config.verbose >= 1;
+        
+        // make sure we're not using LB already since we'd trash the workspace
+        switch (Config.datalogEngine) {
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            throw new ChordException("Datalog engine is already a LogicBlox type (" 
+                + Config.datalogEngine + "), refusing to overwrite workspace.");
+        default:
+            break;
+        }
+        
+        LogicBloxUtils.initializeWorkspace();
+        LogicBloxExporter exporter = new LogicBloxExporter(logicbloxType);
+        
+        ClassicProject project = ClassicProject.g();
+        Set<String> targetNames = project.getFinishedTargetNames();
+        
+        List<Dom<?>> domains = new ArrayList<Dom<?>>( (targetNames.size() / 2) + 1);
+        List<Rel> relations = new ArrayList<Rel>( (targetNames.size() / 2) + 1);
+        
+        // split the targets into domains and relations
+        for (String targetName: targetNames) {
+            Object target = project.getTrgt(targetName);
+            if (target instanceof Dom) {
+                domains.add((Dom<?>)target);
+            } else if (target instanceof Rel) {
+                relations.add((Rel)target);
+            } else {
+                Messages.warn("Unhandled target: name=%s, type=%s", targetName, target.getClass().getName());
+            }
+        }
+        
+        // domains first since relation type signatures depend on them
+        for (Dom<?> domain: domains) {
+            if (v) Messages.log("Exporting domain: %s", domain.getName());
+            exporter.saveDomain(domain);
+        }
+        
+        for (Rel relation: relations) {
+            if (relation instanceof ProgramRel) {
+                ((ProgramRel)relation).load();
+            } else {
+                Messages.warn("Relation %s is not a ProgramRel, attempting BDDBDDB load.", relation.getName());
+                relation.loadFromBDDBDDB(Config.bddbddbWorkDirName);
+            }
+
+            if (v) Messages.log("Exporting relation: %s", relation.getName());
+            exporter.saveRelation(relation);
+            relation.close();
+        }
+    }
+
+}
diff -Nur jchord/main/src/chord/analyses/method/checkExcludedM.logic jchord/main/src/chord/analyses/method/checkExcludedM.logic
--- jchord/main/src/chord/analyses/method/checkExcludedM.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/method/checkExcludedM.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,14 @@
+// Created by convert.py from ./src/chord/analyses/method/checkExcludedM.dlog on 2015-04-20 13:08:42.253415
+// :name: checkExcludedM-dlog
+
+// :domains: T
+// :domains: M
+
+
+// :inputs: checkExcludedT(T)
+// :inputs: TM(T,M)
+// :outputs: checkExcludedM(M)
+checkExcludedM(m) -> M(m).
+
+checkExcludedM(m) <- TM(t,m), checkExcludedT(t).
+
diff -Nur jchord/main/src/chord/analyses/method/checkIncludedM.logic jchord/main/src/chord/analyses/method/checkIncludedM.logic
--- jchord/main/src/chord/analyses/method/checkIncludedM.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/method/checkIncludedM.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,14 @@
+// Created by convert.py from ./src/chord/analyses/method/checkIncludedM.dlog on 2015-04-20 13:08:42.253861
+// :name: checkIncludedM-dlog
+
+// :domains: T
+// :domains: M
+
+
+// :inputs: checkIncludedT(T)
+// :inputs: TM(T,M)
+// :outputs: checkIncludedM(M)
+checkIncludedM(m) -> M(m).
+
+checkIncludedM(m) <- TM(t,m), checkIncludedT(t).
+
diff -Nur jchord/main/src/chord/analyses/mhp/mhp.logic jchord/main/src/chord/analyses/mhp/mhp.logic
--- jchord/main/src/chord/analyses/mhp/mhp.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/mhp/mhp.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,115 @@
+// Created by convert.py from ./src/chord/analyses/mhp/mhp.dlog on 2015-04-20 13:08:42.254313
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: mhp-dlog
+
+// :domains: A
+// :domains: I
+// :domains: M
+// :domains: P
+// :domains: V
+// :domains: Z
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: PP(P,P)
+// :inputs: MPhead(M,P)
+// :inputs: MPtail(M,P)
+// :inputs: PI(P,I)
+// :inputs: IM(I,M)
+// :inputs: threadAM(A,M)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: threadRunAM(A,M)
+threadRunAM(t,m) -> A(t), M(m).
+// :inputs: threadIM(I,M)
+// :inputs: threadStartI(I)
+
+// :outputs: threadPM(P,M)
+threadPM(p,m) -> P(p), M(m).
+// :outputs: threadPH(P,P)
+threadPH(p,q) -> P(p), P(q).
+// :outputs: simpleIM(I,M)
+simpleIM(i,m) -> I(i), M(m).
+// :outputs: simplePM(P,M)
+simplePM(p,m) -> P(p), M(m).
+// :outputs: simplePH(P,P)
+simplePH(p,q) -> P(p), P(q).
+// :outputs: simplePT(P,P)
+simplePT(p,q) -> P(p), P(q).
+
+// # Path edge from dataflow fact (this,sThat) at the entry point of a method to dataflow fact
+// # (this,tThat) at point p contained in that method.  It means:
+// # If thread 'this' starts executing the method containing p while thread 'sThat' runs in parallel,
+// # then it may finish executing that method with thread 'tThat' running in parallel.
+// :outputs: PathEdge(P,A,A,A)
+PathEdge(p,this,sThat,tThat) -> P(p), A(this), A(sThat), A(tThat).
+
+// # Defined only for ordinary calls p (not thread start calls)
+// :outputs: SummEdge(P,A,A,A)
+SummEdge(p,this,sThat,tThat) -> P(p), A(this), A(sThat), A(tThat).
+
+// # Thread t1 may reach point p while thread t2 runs in parallel.
+// :outputs: mhp(P,A,A)
+mhp(p,t1,t2) -> P(p), A(t1), A(t2).
+
+// ###
+// # Constraints
+// ###
+
+simpleIM(i,m) <- IM(i,m), !threadStartI(i).
+simplePM(p,m) <- simpleIM(i,m), PI(p,i).
+simplePH(p,h) <- simplePM(p,m), MPhead(m,h).
+simplePT(p,t) <- simplePM(p,m), MPtail(m,t).
+threadPM(p,m) <- threadIM(i,m), PI(p,i).
+threadPH(p,h) <- threadPM(p,m), MPhead(m,h).
+
+//threadRunAM(t,m) <- threadAM(t,m), m!=0.
+threadRunAM(t,m) <- threadAM(t,m), M_index[m] != 0.
+threadRunAH(t,h) <- threadRunAM(t,m), MPhead(m,h).
+
+// # Main thread (this=1) starts executing entry point of main method (p=0) with no thread
+// # (sThat=tThat=0) in parallel. 
+
+//PathEdge(0,1,0,0).
+PathEdge(p0,a1,a0,a0) <- P_index[p0] = 0, A_index[a0] = 0, A_index[a1] = 1.
+
+// # If t starts executing method of p with t1 in parallel, reaches p with t2 in parallel,
+// # and q follows p in that method, then t may reach q with t2 in parallel.
+
+PathEdge(q,t,t1,t2) <- PathEdge(p,t,t1,t2), PP(p,q).
+
+// ### ordinary (non thread-starting) calls
+
+PathEdge(q,t,t1,t2) <- simplePH(p,q), PathEdge(p,t,_ ,t2), t1=t2.
+SummEdge(p,t,t1,t2) <- simplePT(p,q), PathEdge(q,t,t1,t2).
+PathEdge(r,t,t1,t3) <- SummEdge(p,t,t2,t3), PathEdge(p,t,t1,t2), PP(p,r).
+
+// ### thread-starting calls
+
+// # when a thread t spawns a thread t2, then t may execute with t2 in parallel.
+
+PathEdge(r,t,t1,t2) <- threadPM(p,m), PathEdge(p,t,t1,_), PP(p,r), threadRunAM(t2,m).
+
+// # following two rules: when a thread t1 spawns a thread x, then x may execute with t1 running in
+// # parallel and any threads already running in parallel with t1 (denoted by t3 below).
+
+PathEdge(h,x,t1,t2) <- threadPH(p,h), PathEdge(p,t1,_,_), threadRunAH(x,h), t2=t1. 
+PathEdge(h,x,t3,t2) <- threadPH(p,h), PathEdge(p,_,_,t3), threadRunAH(x,h), t2=t3. 
+
+// # when a thread x spawns a thread t2, and t3 is already running in parallel with x, then t3 may
+// # execute with t2 running in parallel.
+
+PathEdge(h,t3,t1,t2) <- threadPM(p,m), PathEdge(p,_,_,t3), threadRunAH(t3,h), threadRunAM(t2,m), t2=t1. 
+
+// # compute mhp
+
+//mhp(p,t1,t2) <- PathEdge(p,t1,_,t2), t1!=0, t2!=0.
+mhp(p,t1,t2) <- PathEdge(p,t1,_,t2), A_index[t1] != 0, A_index[t2] != 0.
+
diff -Nur jchord/main/src/chord/analyses/mustalias/tdbu/reachableFromM.logic jchord/main/src/chord/analyses/mustalias/tdbu/reachableFromM.logic
--- jchord/main/src/chord/analyses/mustalias/tdbu/reachableFromM.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/mustalias/tdbu/reachableFromM.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,13 @@
+// Created by convert.py from ./src/chord/analyses/mustalias/tdbu/reachableFromM.dlog on 2015-04-20 13:08:42.255992
+// :name: reachableFromM-dlog
+
+// :domains: M
+
+
+// :inputs: MM(M,M)
+
+// :outputs: reachableFromM(M,M)
+reachableFromM(m1,m2) -> M(m1), M(m2).
+
+reachableFromM(m0,m1) <- MM(m0,m1).
+reachableFromM(m0,m2) <- reachableFromM(m0,m1), MM(m1,m2).
diff -Nur jchord/main/src/chord/analyses/provenance/downcast/downcast.logic jchord/main/src/chord/analyses/provenance/downcast/downcast.logic
--- jchord/main/src/chord/analyses/provenance/downcast/downcast.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/downcast/downcast.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,44 @@
+// Created by convert.py from ./src/chord/analyses/provenance/downcast/downcast.dlog on 2015-04-20 13:08:42.256413
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: pro-downcast-dlog
+
+// :domains: H
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: reachableCM(C,M)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: reachableCast(T,V)
+reachableCast(t,v) -> T(t), V(v).
+// :inputs: CVC(C,V,C)
+// :inputs: CH(C,H)
+// :inputs: sub(T1,T0)
+// :inputs: HT(H0,T1)
+// :inputs: McheckCastInst(M,V,T,V)
+// :inputs: checkExcludedM(M)
+// :outputs: ptsVH(V,H)
+ptsVH(v,h) -> V(v), H(h).
+// :outputs: ptsVT(V,T)
+ptsVT(v,t) -> V(v), T(t).
+// :outputs: unsafeDowncast(V,T)
+unsafeDowncast(v,t) -> V(v), T(t).
+
+reachableCast(t,v2) <- McheckCastInst(m,_,t,v2), reachableCM(_,m), !checkExcludedM(m).
+
+ptsVH(v,h) <- CVC(_,v,o), CH(o,h).
+ptsVT(v,t) <- ptsVH(v,h), HT(h,t).
+
+unsafeDowncast(v,t1) <- reachableCast(t1,v), ptsVT(v,t2), !sub(t2,t1).
diff -Nur jchord/main/src/chord/analyses/provenance/downcast/pro-downcast-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/downcast/pro-downcast-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/downcast/pro-downcast-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/downcast/pro-downcast-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,50 @@
+// Created by convert.py from ./src/chord/analyses/provenance/downcast/pro-downcast-dlog_XZ89_.dlog on 2015-04-20 13:08:42.257606
+// :name: pro-downcast-dlog_XZ89_
+// :domains: H
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: C
+
+
+// #Input relations
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: reachableCM(C,M)
+// :inputs: CVC(C,V,C)
+// :inputs: CH(C,H)
+// :inputs: sub(T1,T0)
+// :inputs: HT(H0,T1)
+// :inputs: McheckCastInst(M,V,T,V)
+// :inputs: checkExcludedM(M)
+
+// #Output relations
+// :outputs: reachableCast(T,V)
+reachableCast(t,v) -> T(t), V(v).
+// :outputs: ptsVH(V,H)
+ptsVH(v,h) -> V(v), H(h).
+// :outputs: ptsVT(V,T)
+ptsVT(v,t) -> V(v), T(t).
+// :outputs: unsafeDowncast(V,T)
+unsafeDowncast(v,t) -> V(v), T(t).
+
+// #Instrumented relations
+// :outputs: unsafeDowncast_XZ89_3(V,T,T)
+unsafeDowncast_XZ89_3(v,t1,t2) -> V(v), T(t1), T(t2).
+// :outputs: ptsVT_XZ89_2(V,T,H)
+ptsVT_XZ89_2(v,t,h) -> V(v), T(t), H(h).
+// :outputs: reachableCast_XZ89_0(T,V,M,V,C)
+reachableCast_XZ89_0(t,v2,m,v_XZ89_0,v_XZ89_1) -> T(t), V(v2), M(m), V(v_XZ89_0), C(v_XZ89_1).
+// :outputs: ptsVH_XZ89_1(V,H,C,C)
+ptsVH_XZ89_1(v,h,v_XZ89_0,o) -> V(v), H(h), C(v_XZ89_0), C(o).
+
+// #Original rules
+reachableCast(t,v2) <- McheckCastInst(m,_,t,v2), reachableCM(_,m), !checkExcludedM(m).
+ptsVH(v,h) <- CVC(_,v,o), CH(o,h).
+ptsVT(v,t) <- ptsVH(v,h), HT(h,t).
+unsafeDowncast(v,t1) <- reachableCast(t1,v), ptsVT(v,t2), !sub(t2,t1).
+
+// #Instrumented rules
+reachableCast_XZ89_0(t,v2,m,v_XZ89_0,v_XZ89_1) <- McheckCastInst(m,v_XZ89_0,t,v2), reachableCM(v_XZ89_1,m), !checkExcludedM(m).
+ptsVH_XZ89_1(v,h,v_XZ89_0,o) <- CVC(v_XZ89_0,v,o), CH(o,h).
+ptsVT_XZ89_2(v,t,h) <- ptsVH(v,h), HT(h,t).
+unsafeDowncast_XZ89_3(v,t1,t2) <- reachableCast(t1,v), ptsVT(v,t2), !sub(t2,t1).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/argCopy.logic jchord/main/src/chord/analyses/provenance/kcfa/argCopy.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/argCopy.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/argCopy.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,46 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/argCopy.dlog on 2015-04-20 13:08:42.259118
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: pro-argCopy-dlog
+
+// :domains: I
+// :domains: M
+// :domains: V
+// :domains: Z
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: IM(I,M)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: kobjSenM(M)
+
+// :outputs: MspcMethArg(M,V)
+MspcMethArg(m,v) -> M(m), V(v).
+// :outputs: MordMethArg(M,Z,V)
+MordMethArg(m,z,v) -> M(m), Z(z), V(v).
+
+// :outputs: argCopy(I,V,M,V)
+argCopy(i,u,m,v) -> I(i), V(u), M(m), V(v).
+
+// ###
+// # Constraints
+// ###
+
+//MspcMethArg(m,v)   <- MmethArg(m,0,v), kobjSenM(m).
+MspcMethArg(m,v)   <- MmethArg(m,z0,v), kobjSenM(m), Z_index[z0] = 0.
+//MordMethArg(m,0,v) <- MmethArg(m,0,v), !MspcMethArg(m,v).
+MordMethArg(m,z0,v) <- MmethArg(m,z0,v), !MspcMethArg(m,v), Z_index[z0] = 0.
+//MordMethArg(m,z,v) <- MmethArg(m,z,v), z!=0.
+MordMethArg(m,z,v) <- MmethArg(m,z,v), Z_index[z] != 0.
+
+argCopy(i,u,m,v) <- IM(i,m), IinvkArg(i,z,u), MordMethArg(m,z,v).
+// #argCopy(i,u,m,v) :- IM(i,m), IinvkArg(i,z,u), MmethArg(m,z,v).
+
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/cspa_kcfa.logic jchord/main/src/chord/analyses/provenance/kcfa/cspa_kcfa.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/cspa_kcfa.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/cspa_kcfa.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,257 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/cspa_kcfa.dlog on 2015-04-20 13:08:42.260082
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # k-CFA may-alias/call-graph analysis.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: pro-cspa-kcfa-dlog
+
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: Z
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+
+// :outputs: RobjValAsgnInst(C,V,H)
+RobjValAsgnInst(c,l,h) -> C(c), V(l), H(h).
+// :outputs: RobjVarAsgnInst(C,V,V)
+RobjVarAsgnInst(c,l,r) -> C(c), V(l), V(r).
+// :outputs: RgetInstFldInst(C,V,V,F)
+RgetInstFldInst(c,l,b,f) -> C(c), V(l), V(b), F(f).
+// :outputs: RputInstFldInst(C,V,F,V)
+RputInstFldInst(c,b,f,r) -> C(c), V(b), F(f), V(r).
+// :outputs: RgetStatFldInst(C,V,F)
+RgetStatFldInst(c,l,f) -> C(c), V(l), F(f).
+// :outputs: RputStatFldInst(C,F,V)
+RputStatFldInst(c,f,r) -> C(c), F(f), V(r).
+
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: argCopy(I,V,M,V)
+// :inputs: retCopy(I,V,M,V)
+// :inputs: VCfilter(V,C)
+
+// #CC(c:C,d:C) input # d = [* c]
+// :inputs: CH(C,H)
+// #CI(c:C,i:I) input # c = [i ...]
+// :inputs: epsilonM(M)
+// :inputs: kcfaSenM(M)
+
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+
+// :outputs: kcfaDIC(C,I,C)
+kcfaDIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIC(C,I,C)
+DIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIH(C,I,H)
+DIH(c,i,h) -> C(c), I(i), H(h).
+// :outputs: DI(C,I)
+DI(c,i) -> C(c), I(i).
+
+// :outputs: DVDV(C,V,C,V)
+DVDV(c,u,d,v) -> C(c), V(u), C(d), V(v).
+
+// :outputs: ctxtInsIHM(I,H,M)
+ctxtInsIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: kcfaSenIHM(I,H,M)
+kcfaSenIHM(i,h,m) -> I(i), H(h), M(m).
+
+// :outputs: ctxtInsSpecIM(I,M)
+ctxtInsSpecIM(i,m) -> I(i), M(m).
+// :outputs: kcfaSenSpecIM(I,M)
+kcfaSenSpecIM(i,m) -> I(i), M(m).
+
+// :outputs: ctxtInsStatIM(I,M)
+ctxtInsStatIM(i,m) -> I(i), M(m).
+// :outputs: kcfaSenStatIM(I,M)
+kcfaSenStatIM(i,m) -> I(i), M(m).
+
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+
+// :inputs: CIC(C,I,C)
+// :inputs: CHC(C,H,C)
+
+// ###
+// # Constraints
+// ###
+
+// #CIC(c,i,d) :- CC(c,d), CI(d,i).
+// #CHC(c,h,d) :- CC(c,d), CH(d,h).
+
+// ###
+
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+ctxtInsIHM(i,h,m) <- IHM(i,h,m), epsilonM(m).
+kcfaSenIHM(i,h,m) <- IHM(i,h,m), kcfaSenM(m).
+
+kcfaSenSpecIM(i,m) <- specIM(i,m), kcfaSenM(m).
+ctxtInsSpecIM(i,m) <- specIM(i,m), epsilonM(m).
+
+kcfaSenStatIM(i,m) <- statIM(i,m), kcfaSenM(m).
+ctxtInsStatIM(i,m) <- statIM(i,m), epsilonM(m).
+
+// ###
+
+//reachableCM(0,0).
+reachableCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//reachableCM(0,m) <- clinitTM(t,m), reachableT(t).
+reachableCM(c0,m) <- clinitTM(t,m), reachableT(t), C_index[c0] = 0.
+reachableCM(c,m) <- CICM(_,_,c,m).
+reachableCI(c,i) <- MI(m,i), reachableCM(c,m).
+
+// ###
+
+DIC(c,i,o) <- IinvkArg0(i,v), CVC(c,v,o).
+DIH(c,i,h) <- DIC(c,i,o), CH(o,h).
+DI(c,i) <- DIH(c,i,_).
+
+//kcfaDIC(0,i,d) <- CIC(0,i,d), MI(m,i), epsilonM(m).
+kcfaDIC(c0,i,d) <- CIC(c0,i,d), MI(m,i), epsilonM(m), C_index[c0] = 0.
+kcfaDIC(c,i,d) <- CIC(c,i,d), MI(m,i), kcfaSenM(m).
+
+// ###
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenIHM(i,h,m), DIH(c,i,h), kcfaDIC(c,i,d).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenSpecIM(i,m), DI(c,i), kcfaDIC(c,i,d).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenStatIM(i,m), kcfaDIC(c,i,d).
+
+// ### inter-procedural
+
+DVDV(d,v,c,u) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV(c,u,d,v) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+
+CVC(c,u,o) <- DVDV(c,u,d,v), CVC(d,v,o), VCfilter(u,o).
+
+// ### in context c, l = new h
+
+RobjValAsgnInst(c,l,h) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+CVC(c,l,o) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+
+// ### in context c, l = r
+
+RobjVarAsgnInst(c,l,r) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+CVC(c,l,c1) <- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).
+
+// ### in context c, l = b.f
+
+RgetInstFldInst(c,l,b,f) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+CVC(c,l,c2) <- RgetInstFldInst(c,l,b,f), CVC(c,b,c1), CFC(c1,f,c2). 
+
+// ### in context c, l = STATIC.f
+
+RgetStatFldInst(c,l,f) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+CVC(c,l,o) <- RgetStatFldInst(c,l,f), FC(f,o).
+
+// ### in context c, b.f = r
+
+RputInstFldInst(c,b,f,r) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+CFC(c1,f,c2) <- RputInstFldInst(c,b,f,r), CVC(c,b,c1), CVC(c,r,c2). 
+
+// ### in context c, STATIC.f = r
+
+RputStatFldInst(c,f,r) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+FC(f,o) <- RputStatFldInst(c,f,r), CVC(c,r,o).
+
+// ### reflection handling rules
+
+reachableCM(c,m) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM(c,m) <- reachableCI(c,i), conNewInstIM(i,m).
+
+//CVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), CVC(c,u,o), CFC(o,0,o2).
+//CVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+CVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), CVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+
+// ### rules propagating reachableT
+
+reachableT(t) <- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), clsForNameIT(i,t).
+
+reachableT(t) <- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
+reachableT(t) <- reachableCM(_,m), staticTM(t,m).
+reachableT(t) <- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
+reachableT(t) <- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+
+//rootCM(0,0).
+rootCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//rootCM(0,m) <- reachableT(t), clinitTM(t,m).
+rootCM(c0,m) <- reachableT(t), clinitTM(t,m), C_index[c0] = 0.
+CMCM(c,m,d,n) <- CICM(c,i,d,n), MI(m,i).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,91 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/kcfa-bit-init-dlog_XZ89_.dlog on 2015-04-20 13:08:42.265496
+// :name: kcfa-bit-init-dlog_XZ89_
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+
+
+// #Input relations
+// :inputs: initCIC(C,I,C)
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: IM(I,M)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: CL(C,K)
+// :inputs: AllowI(I,K)
+// :inputs: DenyI(I,K)
+// :inputs: AllowH(H,K)
+// :inputs: DenyH(H,K)
+// :inputs: roots(M)
+
+// #Output relations
+// :outputs: CIC(C,I,C)
+CIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+// :outputs: CIC_1(C,I,C)
+CIC_1(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: CIC_2(C,I,C)
+CIC_2(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: CHC_1(C,H,C)
+CHC_1(c,h,c1) -> C(c), H(h), C(c1).
+// :outputs: CHC_2(C,H,C)
+CHC_2(c,h,c1) -> C(c), H(h), C(c1).
+
+// #Instrumented relations
+// :outputs: CIC_XZ89_2(C,I,C,K)
+CIC_XZ89_2(c1,i,c2,l) -> C(c1), I(i), C(c2), K(l).
+// :outputs: CIC_XZ89_4(C,I,C,K)
+CIC_XZ89_4(c1,i,c2,l) -> C(c1), I(i), C(c2), K(l).
+// :outputs: CIC_2_XZ89_3(C,I,C,C,K,K)
+CIC_2_XZ89_3(c1,i,c3,c2,l1,l2) -> C(c1), I(i), C(c3), C(c2), K(l1), K(l2).
+// :outputs: CHC_2_XZ89_6(C,H,C,C,K,K)
+CHC_2_XZ89_6(c1,h,c3,c2,l1,l2) -> C(c1), H(h), C(c3), C(c2), K(l1), K(l2).
+// :outputs: CHC_XZ89_5(C,H,C,K)
+CHC_XZ89_5(c1,h,c2,l) -> C(c1), H(h), C(c2), K(l).
+// :outputs: CM_XZ89_8(C,M,C,I)
+CM_XZ89_8(c,m,v_XZ89_0,i) -> C(c), M(m), C(v_XZ89_0), I(i).
+// :outputs: CHC_XZ89_7(C,H,C,K)
+CHC_XZ89_7(c1,h,c2,l) -> C(c1), H(h), C(c2), K(l).
+// :outputs: CHC_1_XZ89_10(C,H,C,M)
+CHC_1_XZ89_10(c1,h,c2,m) -> C(c1), H(h), C(c2), M(m).
+// :outputs: CIC_1_XZ89_9(C,I,C,M)
+CIC_1_XZ89_9(c1,i,c2,m) -> C(c1), I(i), C(c2), M(m).
+// :outputs: CM_XZ89_11(M)
+CM_XZ89_11(m) -> M(m).
+
+// #Original rules
+//CM(0,m) <- roots(m).
+CM(c0,m) <- roots(m), C_index[c0] = 0.
+CM(c,m) <- CIC(_,i,c), IM(i,m).
+//AllowI(_,0).
+//AllowH(_,0).
+//AllowH(_,1).
+AllowI(i,k0) <- I(i), K_index[k0] = 0.
+AllowH(h,k0) <- H(h), K_index[k0] = 0.
+AllowH(h,k1) <- H(h), K_index[k1] = 1.
+CIC_1(c1,i,c2) <- MI(m,i), CM(c1,m), initCIC(c1,i,c2).
+CIC(c1,i,c2) <- CIC_1(c1,i,c2), CL(c2,l), AllowI(i,l).
+CIC_2(c1,i,c3) <- CIC_1(c1,i,c2), CL(c2,l1), DenyI(i,l2), truncCKC(c2,l2,c3), l2<=l1.
+CIC(c1,i,c2) <- CIC_2(c1,i,c2), CL(c2,l), AllowI(i,l).
+CHC_1(c1,h,c2) <- MH(m,h), CM(c1,m), initCHC(c1,h,c2).
+CHC(c1,h,c2) <- CHC_1(c1,h,c2), CL(c2,l), AllowH(h,l).
+CHC_2(c1,h,c3) <- CHC_1(c1,h,c2), CL(c2,l1), DenyH(h,l2), truncCKC(c2,l2,c3), l2<=l1.
+CHC(c1,h,c2) <- CHC_2(c1,h,c2), CL(c2,l), AllowH(h,l).
+
+// #Instrumented rules
+CIC_XZ89_2(c1,i,c2,l) <- CIC_1(c1,i,c2), CL(c2,l), AllowI(i,l).
+CIC_2_XZ89_3(c1,i,c3,c2,l1,l2) <- CIC_1(c1,i,c2), CL(c2,l1), DenyI(i,l2), truncCKC(c2,l2,c3), l2<=l1.
+CIC_XZ89_4(c1,i,c2,l) <- CIC_2(c1,i,c2), CL(c2,l), AllowI(i,l).
+CHC_XZ89_5(c1,h,c2,l) <- CHC_1(c1,h,c2), CL(c2,l), AllowH(h,l).
+CHC_2_XZ89_6(c1,h,c3,c2,l1,l2) <- CHC_1(c1,h,c2), CL(c2,l1), DenyH(h,l2), truncCKC(c2,l2,c3), l2<=l1.
+CHC_XZ89_7(c1,h,c2,l) <- CHC_2(c1,h,c2), CL(c2,l), AllowH(h,l).
+CM_XZ89_8(c,m,v_XZ89_0,i) <- CIC(v_XZ89_0,i,c), IM(i,m).
+CIC_1_XZ89_9(c1,i,c2,m) <- MI(m,i), CM(c1,m), initCIC(c1,i,c2).
+CHC_1_XZ89_10(c1,h,c2,m) <- MH(m,h), CM(c1,m), initCHC(c1,h,c2).
+CM_XZ89_11(m) <- roots(m).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init.logic jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/kcfa-bit-init.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,80 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/kcfa-bit-init.dlog on 2015-04-20 13:08:42.267673
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Xin Zhang (xin.zhang@gatech.edu)
+// :name: kcfa-bit-init-dlog
+
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: initCIC(C,I,C)
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: IM(I,M)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: CL(C,K)
+// :inputs: AllowI(I,K)
+// :inputs: DenyI(I,K)
+// :inputs: AllowH(H,K)
+// :inputs: DenyH(H,K)
+// :inputs: roots(M)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CIC_1(C,I,C)
+CIC_1(c,i,c1) -> C(c), I(i), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CIC_2(C,I,C)
+CIC_2(c,i,c1) -> C(c), I(i), C(c1).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_1(C,H,C)
+CHC_1(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_2(C,H,C)
+CHC_2(c,h,c1) -> C(c), H(h), C(c1).
+
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CIC(C,I,C)
+CIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+
+// ###
+// # Constraints
+// ###
+
+//CM(0,m) <- roots(m).
+CM(c0,m) <- roots(m), C_index[c0] = 0.
+CM(c,m) <- CIC(_,i,c), IM(i,m).
+
+//AllowI(_,0).
+//AllowH(_,0).
+//AllowH(_,1).
+AllowI(i,k0) <- I(i), K_index[k0] = 0.
+AllowH(h,k0) <- H(h), K_index[k0] = 0.
+AllowH(h,k1) <- H(h), K_index[k1] = 1.
+
+CIC_1(c1,i,c2) <- MI(m,i),CM(c1,m),initCIC(c1,i,c2).
+CIC(c1,i,c2) <- CIC_1(c1,i,c2),CL(c2,l),AllowI(i,l).
+
+CIC_2(c1,i,c3) <- CIC_1(c1,i,c2), CL(c2,l1), DenyI(i,l2), truncCKC(c2,l2,c3), l2 <= l1.
+CIC(c1,i,c2) <- CIC_2(c1,i,c2), CL(c2,l), AllowI(i,l).
+
+CHC_1(c1,h,c2) <- MH(m,h), CM(c1,m), initCHC(c1,h,c2).
+CHC(c1,h,c2) <- CHC_1(c1,h,c2),CL(c2,l),AllowH(h,l).
+
+CHC_2(c1,h,c3) <- CHC_1(c1,h,c2), CL(c2,l1), DenyH(h,l2), truncCKC(c2,l2,c3), l2 <= l1.
+CHC(c1,h,c2) <- CHC_2(c1,h,c2), CL(c2,l), AllowH(h,l).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,50 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/kcfa-init-dlog_XZ89_.dlog on 2015-04-20 13:08:42.268711
+// :name: kcfa-init-dlog_XZ89_
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+
+
+// #Input relations
+// :inputs: initCIC(C,I,C)
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: IK(I,K)
+// :inputs: HK(H,K)
+// :inputs: IM(I,M)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: roots(M)
+
+// #Output relations
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CIC(C,I,C)
+CIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+
+// #Instrumented relations
+// :outputs: CM_XZ89_0(M)
+CM_XZ89_0(m) -> M(m).
+// :outputs: CIC_XZ89_1(C,I,C,M,K,C)
+CIC_XZ89_1(c1,i,c3,m,k,c2) -> C(c1), I(i), C(c3), M(m), K(k), C(c2).
+// :outputs: CM_XZ89_2(C,M,C,I)
+CM_XZ89_2(c,m,v_XZ89_0,i) -> C(c), M(m), C(v_XZ89_0), I(i).
+// :outputs: CHC_XZ89_3(C,H,C,M,K,C)
+CHC_XZ89_3(c1,h,c3,m,k,c2) -> C(c1), H(h), C(c3), M(m), K(k), C(c2).
+
+// #Original rules
+//CM(0,m) <- roots(m).
+CM(c0,m) <- C_index[c0] = 0, roots(m).
+CIC(c1,i,c3) <- MI(m,i), CM(c1,m), IK(i,k), initCIC(c1,i,c2), truncCKC(c2,k,c3).
+CM(c,m) <- CIC(_,i,c), IM(i,m).
+CHC(c1,h,c3) <- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3).
+
+// #Instrumented rules
+CM_XZ89_0(m) <- roots(m).
+CIC_XZ89_1(c1,i,c3,m,k,c2) <- MI(m,i), CM(c1,m), IK(i,k), initCIC(c1,i,c2), truncCKC(c2,k,c3).
+CM_XZ89_2(c,m,v_XZ89_0,i) <- CIC(v_XZ89_0,i,c), IM(i,m).
+CHC_XZ89_3(c1,h,c3,m,k,c2) <- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-trunk.logic jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-trunk.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-trunk.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init-trunk.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,84 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/kcfa-init-trunk.dlog on 2015-04-20 13:08:42.269579
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: kcfa-init-trunk-dlog
+
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: initCIC(C,I,C)
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: IK(I,K)
+// :inputs: HK(H,K)
+// :inputs: IM(I,M)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: roots(M)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CM_1(C,M)
+CM_1(c,m) -> C(c), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CIC_1(C,I,C)
+CIC_1(c,i,c1) -> C(c), I(i), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CIC_2(C,I,C)
+CIC_2(c,i,c1) -> C(c), I(i), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CIC_3(C,I,C)
+CIC_3(c,i,c1) -> C(c), I(i), C(c1).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_1(C,H,C)
+CHC_1(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_2(C,H,C)
+CHC_2(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_3(C,H,C)
+CHC_3(c,h,c1) -> C(c), H(h), C(c1).
+
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CIC(C,I,C)
+CIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+
+// ###
+// # Constraints
+// ###
+
+// #initialize CM for root methods with emptycontext
+//CM_1(0,m) <- roots(m).
+CM_1(c0,m) <- roots(m), C_index[c0] = 0.
+CIC_1(c1,i,c3) <- MI(m,i), CM_1(c1,m), IK(i,k), initCIC(c1,i,c2), truncCKC(c2, k, c3).
+CM_1(c,m) <- CIC_1(_,i,c), IM(i,m).
+CIC_2(c1,i,c2) <- CIC_1(c1,i,c2), initCIC(c1,i,c2).
+CIC_3(c1,i,c3) <- !CIC_2(c1,i,c3), CIC_1(c1,i,c3).
+
+//CM(0,m) <- roots(m).
+CM(c0,m) <- roots(m), C_index[c0] = 0.
+CIC(c1,i,c3) <- CIC_2(c1,i,c3).
+CIC(c1,i,c3) <- MI(m,i), CM(c1,m), IK(i,k), initCIC(c1,i,c2), truncCKC(c2,k,c3), CIC_3(c1,i,c3).
+CM(c,m) <- CIC(_,i,c), IM(i,m).
+
+CHC_1(c1,h,c3) <- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3).
+CHC_2(c1,h,c2) <- CHC_1(c1,h,c2), initCHC(c1,h,c2).
+CHC_3(c1,h,c3) <- !CHC_2(c1,h,c3), CHC_1(c1,h,c3).
+
+CHC(c1,h,c3) <- CHC_2(c1,h,c3).
+CHC(c1,h,c3) <- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3), CHC_3(c1,h,c3).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init.logic jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/kcfa-init.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,71 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/kcfa-init.dlog on 2015-04-20 13:08:42.270633
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: kcfa-init-dlog
+
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: initCIC(C,I,C)
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: IK(I,K)
+// :inputs: HK(H,K)
+// :inputs: IM(I,M)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: roots(M)
+
+// #CM_1(c:C, m:M)
+// #CIC_1(c:C, i:I, c:C)
+// #CIC_2(c:C, i:I, c:C)
+// #CIC_3(c:C, i:I, c:C)
+
+// #CHC_1(c:C, h:H, c:C)
+// #CHC_2(c:C, h:H, c:C)
+// #CHC_3(c:C, h:H, c:C)
+
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CIC(C,I,C)
+CIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+
+// ###
+// # Constraints
+// ###
+
+// #initialize CM for root methods with emptycontext
+// #CM_1(0,m) :- roots(m).
+// #CIC_1(c1,i,c3) :- MI(m,i), CM_1(c1,m), IK(i,k), initCIC(c1,i,c2), truncCKC(c2, k, c3).
+// #CM_1(c,m) :- CIC_1(_,i,c), IM(i,m).
+// #CIC_2(c1,i,c2) :- CIC_1(c1,i,c2), initCIC(c1,i,c2).
+// #CIC_3(c1,i,c3) :- !CIC_2(c1,i,c3), CIC_1(c1,i,c3).
+
+//CM(0,m) <- roots(m).
+CM(c0,m) <- roots(m), C_index[c0] = 0.
+// #CIC(c1,i,c3) :- CIC_2(c1,i,c3).
+// #CIC(c1,i,c3) :- MI(m,i), CM(c1,m), IK(i,k), initCIC(c1,i,c2), truncCKC(c2,k,c3), CIC_3(c1,i,c3).
+CIC(c1,i,c3) <- MI(m,i), CM(c1,m), IK(i,k), initCIC(c1,i,c2), truncCKC(c2,k,c3).
+CM(c,m) <- CIC(_,i,c), IM(i,m).
+
+// #CHC_1(c1,h,c3) :- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3).
+// #CHC_2(c1,h,c2) :- CHC_1(c1,h,c2), initCHC(c1,h,c2).
+// #CHC_3(c1,h,c3) :- !CHC_2(c1,h,c3), CHC_1(c1,h,c3).
+
+// #CHC(c1,h,c3) :- CHC_2(c1,h,c3).
+// #CHC(c1,h,c3) :- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3), CHC_3(c1,h,c3).
+CHC(c1,h,c3) <- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/kobj-init.logic jchord/main/src/chord/analyses/provenance/kcfa/kobj-init.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/kobj-init.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/kobj-init.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,79 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/kobj-init.dlog on 2015-04-20 13:08:42.271421
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: kobj-init-dlog
+
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+// :domains: V
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: HK(H,K)
+// :inputs: roots(M)
+// :inputs: IM(I,M)
+// :inputs: VH(V,H)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: statM(M)
+
+// :inputs: thisMV(M,V)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: HM(H,M)
+HM(h,m) -> H(h), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CM_1(C,M)
+CM_1(c,m) -> C(c), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_1(C,H,C)
+CHC_1(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_2(C,H,C)
+CHC_2(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_3(C,H,C)
+CHC_3(c,h,c1) -> C(c), H(h), C(c1).
+
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+
+// ###
+// # Constraints
+// ###
+
+HM(h,m) <- thisMV(m,v), VH(v,h).
+
+// #initialize CM for root methods with emptycontext
+//CM_1(0,m) <- roots(m).
+CM_1(c0,m) <- roots(m), C_index[c0] = 0.
+// #CM_1(c,m) :- CHC_1(_,h,c), IM(i,m), IinvkArg0(i,v), VH(v,h), !statM(m).
+CM_1(c,m) <- CHC_1(_,h,c), HM(h,m).
+CM_1(c,m1) <- CM_1(c,m0), IM(i,m1), statM(m1), MI(m0,i).
+
+CHC_1(c1,h,c3) <- MH(m,h), CM_1(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3).
+CHC_2(c1,h,c2) <- CHC_1(c1,h,c2), initCHC(c1,h,c2).
+CHC_3(c1,h,c3) <- !CHC_2(c1,h,c3), CHC_1(c1,h,c3).
+
+//CM(0,m) <- roots(m).
+CM(c0,m) <- roots(m), C_index[c0] = 0.
+// #CM(c,m) :- CHC(_,h,c), IM(i,m), IinvkArg0(i,v), VH(v,h), !statM(m).
+CM(c,m) <- CHC(_,h,c), HM(h,m).
+CM(c,m1) <- CM(c,m0), IM(i,m1), statM(m1), MI(m0,i).
+
+CHC(c1,h,c3) <- CHC_2(c1,h,c3).
+CHC(c1,h,c3) <- MH(m,h), CM(c1,m), HK(h,k), initCHC(c1,h,c2), truncCKC(c2,k,c3), CHC_3(c1,h,c3).
diff -Nur jchord/main/src/chord/analyses/provenance/kcfa/pro-cspa-kcfa-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/kcfa/pro-cspa-kcfa-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/kcfa/pro-cspa-kcfa-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kcfa/pro-cspa-kcfa-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,340 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kcfa/pro-cspa-kcfa-dlog_XZ89_.dlog on 2015-04-20 13:08:42.272426
+// :name: pro-cspa-kcfa-dlog_XZ89_
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: Z
+// :domains: C
+
+
+// #Input relations
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: argCopy(I,V,M,V)
+// :inputs: retCopy(I,V,M,V)
+// :inputs: VCfilter(V,C)
+// :inputs: CH(C,H)
+// :inputs: epsilonM(M)
+// :inputs: kcfaSenM(M)
+// :inputs: CIC(C,I,C)
+// :inputs: CHC(C,H,C)
+
+// #Output relations
+// :outputs: RobjValAsgnInst(C,V,H)
+RobjValAsgnInst(c,l,h) -> C(c), V(l), H(h).
+// :outputs: RgetInstFldInst(C,V,V,F)
+RgetInstFldInst(c,l,b,f) -> C(c), V(l), V(b), F(f).
+// :outputs: RobjVarAsgnInst(C,V,V)
+RobjVarAsgnInst(c,l,r) -> C(c), V(l), V(r).
+// :outputs: RgetStatFldInst(C,V,F)
+RgetStatFldInst(c,l,f) -> C(c), V(l), F(f).
+// :outputs: RputInstFldInst(C,V,F,V)
+RputInstFldInst(c,b,f,r) -> C(c), V(b), F(f), V(r).
+// :outputs: RputStatFldInst(C,F,V)
+RputStatFldInst(c,f,r) -> C(c), F(f), V(r).
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: DIC(C,I,C)
+DIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIH(C,I,H)
+DIH(c,i,h) -> C(c), I(i), H(h).
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+// :outputs: kcfaDIC(C,I,C)
+kcfaDIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: ctxtInsIHM(I,H,M)
+ctxtInsIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: kcfaSenIHM(I,H,M)
+kcfaSenIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: DI(C,I)
+DI(c,i) -> C(c), I(i).
+// :outputs: DVDV(C,V,C,V)
+DVDV(c,u,d,v) -> C(c), V(u), C(d), V(v).
+// :outputs: kcfaSenStatIM(I,M)
+kcfaSenStatIM(i,m) -> I(i), M(m).
+// :outputs: ctxtInsStatIM(I,M)
+ctxtInsStatIM(i,m) -> I(i), M(m).
+// :outputs: kcfaSenSpecIM(I,M)
+kcfaSenSpecIM(i,m) -> I(i), M(m).
+// :outputs: ctxtInsSpecIM(I,M)
+ctxtInsSpecIM(i,m) -> I(i), M(m).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+// :outputs: CFC_34_0(C,F,V,C)
+CFC_34_0(_c,_f,_r,_c1) -> C(_c), F(_f), V(_r), C(_c1).
+// :outputs: CVC_30_0(C,V,F,C)
+CVC_30_0(_c,_l,_f,_c1) -> C(_c), V(_l), F(_f), C(_c1).
+
+// #Instrumented relations
+// :outputs: CICM_XZ89_4(C,I,C,M)
+CICM_XZ89_4(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CICM_XZ89_5(C,I,M)
+CICM_XZ89_5(c,i,m) -> C(c), I(i), M(m).
+// :outputs: CICM_XZ89_6(C,I,C,M)
+CICM_XZ89_6(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: DVDV_XZ89_7(C,V,C,V,I,M)
+DVDV_XZ89_7(d,v,c,u,i,m) -> C(d), V(v), C(c), V(u), I(i), M(m).
+// :outputs: kcfaDIC_XZ89_0(I,C,M)
+kcfaDIC_XZ89_0(i,d,m) -> I(i), C(d), M(m).
+// :outputs: kcfaDIC_XZ89_1(C,I,C,M)
+kcfaDIC_XZ89_1(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CICM_XZ89_2(C,I,C,M,H)
+CICM_XZ89_2(c,i,d,m,h) -> C(c), I(i), C(d), M(m), H(h).
+// :outputs: CICM_XZ89_3(C,I,M)
+CICM_XZ89_3(c,i,m) -> C(c), I(i), M(m).
+// :outputs: CVC_XZ89_12(C,V,C,F,C)
+CVC_XZ89_12(c,l,c2,f,c1) -> C(c), V(l), C(c2), F(f), C(c1).
+// :outputs: CVC_XZ89_13(C,V,C,F)
+CVC_XZ89_13(c,l,o,f) -> C(c), V(l), C(o), F(f).
+// :outputs: CFC_XZ89_14(C,F,C,C,V)
+CFC_XZ89_14(c1,f,c2,c,r) -> C(c1), F(f), C(c2), C(c), V(r).
+// :outputs: FC_XZ89_15(F,C,C,V)
+FC_XZ89_15(f,o,c,r) -> F(f), C(o), C(c), V(r).
+// :outputs: DVDV_XZ89_8(C,V,C,V,I,M)
+DVDV_XZ89_8(c,u,d,v,i,m) -> C(c), V(u), C(d), V(v), I(i), M(m).
+// :outputs: CVC_XZ89_9(C,V,C,C,V)
+CVC_XZ89_9(c,u,o,d,v) -> C(c), V(u), C(o), C(d), V(v).
+// :outputs: CVC_XZ89_10(C,V,C,H)
+CVC_XZ89_10(c,l,o,h) -> C(c), V(l), C(o), H(h).
+// :outputs: CVC_XZ89_11(C,V,C,V)
+CVC_XZ89_11(c,l,c1,r) -> C(c), V(l), C(c1), V(r).
+// :outputs: CVC_XZ89_21(C,V,C,I,H)
+CVC_XZ89_21(c,v,o,i,h) -> C(c), V(v), C(o), I(i), H(h).
+// :outputs: CVC_XZ89_20(C,V,C,I,H)
+CVC_XZ89_20(c,v,o,i,h) -> C(c), V(v), C(o), I(i), H(h).
+// :outputs: CVC_30_0_XZ89_23(C,V,F,C,V)
+CVC_30_0_XZ89_23(c,l,f,c1,b) -> C(c), V(l), F(f), C(c1), V(b).
+// :outputs: CMCM_XZ89_22(C,M,C,M,I)
+CMCM_XZ89_22(c,m,d,n,i) -> C(c), M(m), C(d), M(n), I(i).
+// :outputs: CVC_XZ89_17(C,V,C,I,H)
+CVC_XZ89_17(c,v,o,i,h) -> C(c), V(v), C(o), I(i), H(h).
+// :outputs: CVC_XZ89_16(C,V,C,I,M,H)
+CVC_XZ89_16(c,v,o,i,m,h) -> C(c), V(v), C(o), I(i), M(m), H(h).
+// :outputs: CVC_XZ89_19(C,V,C,I,M,H)
+CVC_XZ89_19(c,v,o,i,m,h) -> C(c), V(v), C(o), I(i), M(m), H(h).
+// :outputs: CVC_XZ89_18(C,V,C,I,M,V,C)
+CVC_XZ89_18(c,v,o2,i,m,u,o) -> C(c), V(v), C(o2), I(i), M(m), V(u), C(o).
+// :outputs: DI_XZ89_29(C,I,H)
+DI_XZ89_29(c,i,v_XZ89_0) -> C(c), I(i), H(v_XZ89_0).
+// :outputs: DIH_XZ89_28(C,I,H,C)
+DIH_XZ89_28(c,i,h,o) -> C(c), I(i), H(h), C(o).
+// :outputs: RobjValAsgnInst_XZ89_31(C,V,H,M)
+RobjValAsgnInst_XZ89_31(c,l,h,m) -> C(c), V(l), H(h), M(m).
+// :outputs: CICM_XZ89_30(C,I,M,H)
+CICM_XZ89_30(c,i,m,h) -> C(c), I(i), M(m), H(h).
+// :outputs: reachableCM_XZ89_25(C,M,C,I)
+reachableCM_XZ89_25(c,m,v_XZ89_0,v_XZ89_1) -> C(c), M(m), C(v_XZ89_0), I(v_XZ89_1).
+// :outputs: CFC_34_0_XZ89_24(C,F,V,C,V)
+CFC_34_0_XZ89_24(c,f,r,c1,b) -> C(c), F(f), V(r), C(c1), V(b).
+// :outputs: DIC_XZ89_27(C,I,C,V)
+DIC_XZ89_27(c,i,o,v) -> C(c), I(i), C(o), V(v).
+// :outputs: reachableCI_XZ89_26(C,I,M)
+reachableCI_XZ89_26(c,i,m) -> C(c), I(i), M(m).
+// :outputs: reachableCM_XZ89_38(C,M,I)
+reachableCM_XZ89_38(c,m,i) -> C(c), M(m), I(i).
+// :outputs: reachableT_XZ89_39(T,C,I,H)
+reachableT_XZ89_39(t,v_XZ89_0,i,h) -> T(t), C(v_XZ89_0), I(i), H(h).
+// :outputs: RputStatFldInst_XZ89_36(C,F,V,M)
+RputStatFldInst_XZ89_36(c,f,r,m) -> C(c), F(f), V(r), M(m).
+// :outputs: reachableCM_XZ89_37(C,M,I)
+reachableCM_XZ89_37(c,m,i) -> C(c), M(m), I(i).
+// :outputs: RgetStatFldInst_XZ89_34(C,V,F,M)
+RgetStatFldInst_XZ89_34(c,l,f,m) -> C(c), V(l), F(f), M(m).
+// :outputs: RputInstFldInst_XZ89_35(C,V,F,V,M)
+RputInstFldInst_XZ89_35(c,b,f,r,m) -> C(c), V(b), F(f), V(r), M(m).
+// :outputs: RobjVarAsgnInst_XZ89_32(C,V,V,M)
+RobjVarAsgnInst_XZ89_32(c,l,r,m) -> C(c), V(l), V(r), M(m).
+// :outputs: RgetInstFldInst_XZ89_33(C,V,V,F,M)
+RgetInstFldInst_XZ89_33(c,l,b,f,m) -> C(c), V(l), V(b), F(f), M(m).
+// :outputs: reachableT_XZ89_46(T,T)
+reachableT_XZ89_46(t,s) -> T(t), T(s).
+// :outputs: rootCM_XZ89_47(M,T)
+rootCM_XZ89_47(m,t) -> M(m), T(t).
+// :outputs: reachableT_XZ89_44(T,C,M,F,V)
+reachableT_XZ89_44(t,v_XZ89_0,m,f,v_XZ89_1) -> T(t), C(v_XZ89_0), M(m), F(f), V(v_XZ89_1).
+// :outputs: reachableT_XZ89_45(T,C,M,V,F)
+reachableT_XZ89_45(t,v_XZ89_0,m,v_XZ89_1,f) -> T(t), C(v_XZ89_0), M(m), V(v_XZ89_1), F(f).
+// :outputs: reachableT_XZ89_42(T,C,M,V,H)
+reachableT_XZ89_42(t,v_XZ89_0,m,v_XZ89_1,h) -> T(t), C(v_XZ89_0), M(m), V(v_XZ89_1), H(h).
+// :outputs: reachableT_XZ89_43(T,C,M)
+reachableT_XZ89_43(t,v_XZ89_0,m) -> T(t), C(v_XZ89_0), M(m).
+// :outputs: reachableT_XZ89_40(T,C,I,H)
+reachableT_XZ89_40(t,v_XZ89_0,i,h) -> T(t), C(v_XZ89_0), I(i), H(h).
+// :outputs: reachableT_XZ89_41(T,C,I)
+reachableT_XZ89_41(t,v_XZ89_0,i) -> T(t), C(v_XZ89_0), I(i).
+// :outputs: reachableCM_XZ89_49(M,T)
+reachableCM_XZ89_49(m,t) -> M(m), T(t).
+
+// #Original rules
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+ctxtInsIHM(i,h,m) <- IHM(i,h,m), epsilonM(m).
+kcfaSenIHM(i,h,m) <- IHM(i,h,m), kcfaSenM(m).
+kcfaSenSpecIM(i,m) <- specIM(i,m), kcfaSenM(m).
+ctxtInsSpecIM(i,m) <- specIM(i,m), epsilonM(m).
+kcfaSenStatIM(i,m) <- statIM(i,m), kcfaSenM(m).
+ctxtInsStatIM(i,m) <- statIM(i,m), epsilonM(m).
+//reachableCM(0,0).
+reachableCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//reachableCM(0,m) <- clinitTM(t,m), reachableT(t).
+reachableCM(c0,m) <- clinitTM(t,m), reachableT(t), C_index[c0] = 0.
+reachableCM(c,m) <- CICM(_,_,c,m).
+reachableCI(c,i) <- MI(m,i), reachableCM(c,m).
+DIC(c,i,o) <- IinvkArg0(i,v), CVC(c,v,o).
+DIH(c,i,h) <- DIC(c,i,o), CH(o,h).
+DI(c,i) <- DIH(c,i,_).
+//kcfaDIC(0,i,d) <- CIC(0,i,d), MI(m,i), epsilonM(m).
+kcfaDIC(c0,i,d) <- CIC(c0,i,d), MI(m,i), epsilonM(m), C_index[c0] = 0.
+kcfaDIC(c,i,d) <- CIC(c,i,d), MI(m,i), kcfaSenM(m).
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenIHM(i,h,m), DIH(c,i,h), kcfaDIC(c,i,d).
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenSpecIM(i,m), DI(c,i), kcfaDIC(c,i,d).
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), kcfaSenStatIM(i,m), kcfaDIC(c,i,d).
+DVDV(d,v,c,u) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV(c,u,d,v) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+CVC(c,u,o) <- DVDV(c,u,d,v), CVC(d,v,o), VCfilter(u,o).
+RobjValAsgnInst(c,l,h) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+CVC(c,l,o) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+RobjVarAsgnInst(c,l,r) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+CVC(c,l,c1) <- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).
+RgetInstFldInst(c,l,b,f) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+CVC(c,l,c2) <- CVC_30_0(c,l,f,c1), CFC(c1,f,c2).
+RgetStatFldInst(c,l,f) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+CVC(c,l,o) <- RgetStatFldInst(c,l,f), FC(f,o).
+RputInstFldInst(c,b,f,r) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+CFC(c1,f,c2) <- CFC_34_0(c,f,r,c1), CVC(c,r,c2).
+RputStatFldInst(c,f,r) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+FC(f,o) <- RputStatFldInst(c,f,r), CVC(c,r,o).
+reachableCM(c,m) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM(c,m) <- reachableCI(c,i), conNewInstIM(i,m).
+//CVC(c,v,o) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), CVC(c,u,o), CFC(o,0,o2).
+//CVC(c,v,o) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+CVC(c,v,o) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), CVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+reachableT(t) <- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), clsForNameIT(i,t).
+reachableT(t) <- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
+reachableT(t) <- reachableCM(_,m), staticTM(t,m).
+reachableT(t) <- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
+reachableT(t) <- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+//rootCM(0,0).
+rootCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//rootCM(0,m) <- reachableT(t), clinitTM(t,m).
+rootCM(c0,m) <- reachableT(t), clinitTM(t,m), C_index[c0] = 0.
+CMCM(c,m,d,n) <- CICM(c,i,d,n), MI(m,i).
+CVC_30_0(c,l,f,c1) <- RgetInstFldInst(c,l,b,f), CVC(c,b,c1).
+CFC_34_0(c,f,r,c1) <- RputInstFldInst(c,b,f,r), CVC(c,b,c1).
+
+// #Instrumented rules
+//kcfaDIC_XZ89_0(i,d,m) <- CIC(0,i,d), MI(m,i), epsilonM(m).
+kcfaDIC_XZ89_0(i,d,m) <- CIC(c0,i,d), MI(m,i), epsilonM(m), C_index[c0] = 0.
+kcfaDIC_XZ89_1(c,i,d,m) <- CIC(c,i,d), MI(m,i), kcfaSenM(m).
+CICM_XZ89_2(c,i,d,m,h) <- reachableCI(c,i), kcfaSenIHM(i,h,m), DIH(c,i,h), kcfaDIC(c,i,d).
+CICM_XZ89_3(c,i,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM_XZ89_4(c,i,d,m) <- reachableCI(c,i), kcfaSenSpecIM(i,m), DI(c,i), kcfaDIC(c,i,d).
+CICM_XZ89_5(c,i,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM_XZ89_6(c,i,d,m) <- reachableCI(c,i), kcfaSenStatIM(i,m), kcfaDIC(c,i,d).
+DVDV_XZ89_7(d,v,c,u,i,m) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV_XZ89_8(c,u,d,v,i,m) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+CVC_XZ89_9(c,u,o,d,v) <- DVDV(c,u,d,v), CVC(d,v,o), VCfilter(u,o).
+CVC_XZ89_10(c,l,o,h) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+CVC_XZ89_11(c,l,c1,r) <- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).
+CVC_XZ89_12(c,l,c2,f,c1) <- CVC_30_0(c,l,f,c1), CFC(c1,f,c2).
+CVC_XZ89_13(c,l,o,f) <- RgetStatFldInst(c,l,f), FC(f,o).
+CFC_XZ89_14(c1,f,c2,c,r) <- CFC_34_0(c,f,r,c1), CVC(c,r,c2).
+FC_XZ89_15(f,o,c,r) <- RputStatFldInst(c,f,r), CVC(c,r,o).
+//CVC_XZ89_16(c,v,o,i,m,h) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//CVC_XZ89_17(c,v,o,i,h) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC_XZ89_18(c,v,o2,i,m,u,o) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), CVC(c,u,o), CFC(o,0,o2).
+//CVC_XZ89_19(c,v,o,i,m,h) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//CVC_XZ89_20(c,v,o,i,h) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC_XZ89_21(c,v,o,i,h) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+CVC_XZ89_16(c,v,o,i,m,h) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_17(c,v,o,i,h) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_18(c,v,o2,i,m,u,o) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), CVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+CVC_XZ89_19(c,v,o,i,m,h) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_20(c,v,o,i,h) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_21(c,v,o,i,h) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CMCM_XZ89_22(c,m,d,n,i) <- CICM(c,i,d,n), MI(m,i).
+CVC_30_0_XZ89_23(c,l,f,c1,b) <- RgetInstFldInst(c,l,b,f), CVC(c,b,c1).
+CFC_34_0_XZ89_24(c,f,r,c1,b) <- RputInstFldInst(c,b,f,r), CVC(c,b,c1).
+reachableCM_XZ89_25(c,m,v_XZ89_0,v_XZ89_1) <- CICM(v_XZ89_0,v_XZ89_1,c,m).
+reachableCI_XZ89_26(c,i,m) <- MI(m,i), reachableCM(c,m).
+DIC_XZ89_27(c,i,o,v) <- IinvkArg0(i,v), CVC(c,v,o).
+DIH_XZ89_28(c,i,h,o) <- DIC(c,i,o), CH(o,h).
+DI_XZ89_29(c,i,v_XZ89_0) <- DIH(c,i,v_XZ89_0).
+CICM_XZ89_30(c,i,m,h) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+RobjValAsgnInst_XZ89_31(c,l,h,m) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+RobjVarAsgnInst_XZ89_32(c,l,r,m) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+RgetInstFldInst_XZ89_33(c,l,b,f,m) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+RgetStatFldInst_XZ89_34(c,l,f,m) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+RputInstFldInst_XZ89_35(c,b,f,r,m) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+RputStatFldInst_XZ89_36(c,f,r,m) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+reachableCM_XZ89_37(c,m,i) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM_XZ89_38(c,m,i) <- reachableCI(c,i), conNewInstIM(i,m).
+reachableT_XZ89_39(t,v_XZ89_0,i,h) <- reachableCI(v_XZ89_0,i), conNewInstIH(i,h), HT(h,t).
+reachableT_XZ89_40(t,v_XZ89_0,i,h) <- reachableCI(v_XZ89_0,i), objNewInstIH(i,h), HT(h,t).
+reachableT_XZ89_41(t,v_XZ89_0,i) <- reachableCI(v_XZ89_0,i), clsForNameIT(i,t).
+reachableT_XZ89_42(t,v_XZ89_0,m,v_XZ89_1,h) <- reachableCM(v_XZ89_0,m), MobjValAsgnInst(m,v_XZ89_1,h), HT(h,t).
+reachableT_XZ89_43(t,v_XZ89_0,m) <- reachableCM(v_XZ89_0,m), staticTM(t,m).
+reachableT_XZ89_44(t,v_XZ89_0,m,f,v_XZ89_1) <- reachableCM(v_XZ89_0,m), MputStatFldInst(m,f,v_XZ89_1), staticTF(t,f).
+reachableT_XZ89_45(t,v_XZ89_0,m,v_XZ89_1,f) <- reachableCM(v_XZ89_0,m), MgetStatFldInst(m,v_XZ89_1,f), staticTF(t,f).
+reachableT_XZ89_46(t,s) <- classT(t), reachableT(s), sub(s,t).
+rootCM_XZ89_47(m,t) <- reachableT(t), clinitTM(t,m).
+reachableCM_XZ89_49(m,t) <- clinitTM(t,m), reachableT(t).
diff -Nur jchord/main/src/chord/analyses/provenance/kobj/cspa_kobj.logic jchord/main/src/chord/analyses/provenance/kobj/cspa_kobj.logic
--- jchord/main/src/chord/analyses/provenance/kobj/cspa_kobj.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kobj/cspa_kobj.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,313 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kobj/cspa_kobj.dlog on 2015-04-20 13:08:42.280035
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # k-object-sensitive may-alias/call-graph analysis.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: pro-cspa-kobj-dlog
+
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: Z
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+
+// :outputs: RobjValAsgnInst(C,V,H)
+RobjValAsgnInst(c,l,h) -> C(c), V(l), H(h).
+// :outputs: RobjVarAsgnInst(C,V,V)
+RobjVarAsgnInst(c,l,r) -> C(c), V(l), V(r).
+// :outputs: RgetInstFldInst(C,V,V,F)
+RgetInstFldInst(c,l,b,f) -> C(c), V(l), V(b), F(f).
+// :outputs: RputInstFldInst(C,V,F,V)
+RputInstFldInst(c,b,f,r) -> C(c), V(b), F(f), V(r).
+// :outputs: RgetStatFldInst(C,V,F)
+RgetStatFldInst(c,l,f) -> C(c), V(l), F(f).
+// :outputs: RputStatFldInst(C,F,V)
+RputStatFldInst(c,f,r) -> C(c), F(f), V(r).
+
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: MspcMethArg(M,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: argCopy(I,V,M,V)
+// :inputs: retCopy(I,V,M,V)
+// :inputs: VCfilter(V,C)
+
+// #CC(c:C,d:C) input
+// :inputs: CH(C,H)
+// #CI(c:C,i:I) input
+// :inputs: epsilonM(M)
+// :inputs: kobjSenM(M)
+// :inputs: ctxtCpyM(M)
+// #epsilonV(v:V) input
+
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+
+// :outputs: DIC(C,I,C)
+DIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: DIH(C,I,H)
+DIH(c,i,h) -> C(c), I(i), H(h).
+// :outputs: DI(C,I)
+DI(c,i) -> C(c), I(i).
+
+// :outputs: DVDV(C,V,C,V)
+DVDV(c,u,d,v) -> C(c), V(u), C(d), V(v).
+
+// :outputs: ctxtInsIHM(I,H,M)
+ctxtInsIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: kobjSenIHM(I,H,M)
+kobjSenIHM(i,h,m) -> I(i), H(h), M(m).
+
+// :outputs: kobjSenICM(I,C,M)
+kobjSenICM(i,c,m) -> I(i), C(c), M(m).
+
+// :outputs: ctxtInsSpecIM(I,M)
+ctxtInsSpecIM(i,m) -> I(i), M(m).
+// :outputs: kobjSenSpecIM(I,M)
+kobjSenSpecIM(i,m) -> I(i), M(m).
+
+// :outputs: ctxtInsStatIM(I,M)
+ctxtInsStatIM(i,m) -> I(i), M(m).
+// :outputs: ctxtCpyStatIM(I,M)
+ctxtCpyStatIM(i,m) -> I(i), M(m).
+
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+
+// #DVC(c1:C,v:V,c2:C) output
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+
+// #CIC(c:C,i:I,d:C) input
+// :inputs: CHC(C,H,C)
+// :inputs: COC(C,H,C)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CCMatch(C,C)
+CCMatch(c,d) -> C(c), C(d).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CCM(C,C,M)
+CCM(c,d,m) -> C(c), C(d), M(m).
+
+// ###
+// # Constraints
+// ###
+
+// #CIC(c,i,d) :- CC(c,d), CI(d,i).
+// #CHC(c,h,d) :- CC(c,d), CH(d,h).
+CCMatch(c2,c3) <- CHC(c1,h,c2), COC(c1,h,c3).
+
+// ###
+
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+ctxtInsIHM(i,h,m) <- IHM(i,h,m), epsilonM(m).
+kobjSenIHM(i,h,m) <- IHM(i,h,m), kobjSenM(m).
+
+kobjSenICM(i,o,m) <- kobjSenIHM(i,h,m), CH(o,h).
+
+ctxtInsSpecIM(i,m) <- specIM(i,m), epsilonM(m).
+kobjSenSpecIM(i,m) <- specIM(i,m), kobjSenM(m).
+
+ctxtInsStatIM(i,m) <- statIM(i,m), epsilonM(m).
+ctxtCpyStatIM(i,m) <- statIM(i,m), ctxtCpyM(m).
+
+// ###
+
+//reachableCM(0,0).
+//reachableCM(0,m) <- clinitTM(t,m), reachableT(t).
+reachableCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+reachableCM(c0,m) <- clinitTM(t,m), reachableT(t), C_index[c0] = 0.
+
+reachableCM(c,m) <- CICM(_,_,c,m).
+
+reachableCI(c,i) <- MI(m,i), reachableCM(c,m).
+
+// ###
+
+// #DIC(c,i,o) :- IinvkArg0(i,v), DVC(c,v,o).
+DIC(c,i,o) <- IinvkArg0(i,v), CVC(c,v,o).
+DIH(c,i,h) <- DIC(c,i,o), CH(o,h).
+DI(c,i) <- DIH(c,i,_).
+
+// ###
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h), C_index[c0] = 0.
+// #CICM(c,i,o,m) :- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o).
+CICM(c,i,n,m) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o), CCMatch(o,n).
+CCM(o,n,m) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o), CCMatch(o,n).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i), C_index[c0] = 0.
+// #CICM(c,i,o,m) :- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o).
+CICM(c,i,n,m) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o), CCMatch(o,n).
+CCM(o,n,m) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o), CCMatch(o,n).
+
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), ctxtCpyStatIM(i,m), d=c.
+
+// ###
+
+// #This rule is mainly for an optimization. Ensures that the points-to
+// #information for "this" variable is always equal to the incoming context.
+// #DVC(c,v,o) :- reachableCM(c,m), MspcMethArg(m,v), o=c.
+// #CVC(c,v,o) :- reachableCM(c,m), MspcMethArg(m,v), o=c.
+
+// #The following couple of rules try to simulate the above effect for the
+// #modified setting where heap-element and context are not co-related.
+// #CVC(d,v,o) :- CICM(c,i,d,m), DIC(c,i,o), kobjSenICM(i,o,m), MspcMethArg(m,v), CH(d,h), CH(o,h).
+// #CVC(d,v,o) :- CICM(c,i,d,m), DIC(c,i,o), kobjSenSpecIM(i,m), MspcMethArg(m,v), CH(d,h), CH(o,h).
+
+CVC(d,v,o) <- CCM(o,d,m), MspcMethArg(m,v), CH(d,h), CH(o,h).
+
+// ###
+
+DVDV(d,v,c,u) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV(c,u,d,v) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+
+// #DVC(c,u,o) :- DVDV(c,u,d,v), DVC(d,v,o), VCfilter(u,o).
+CVC(c,u,o) <- DVDV(c,u,d,v), CVC(d,v,o), VCfilter(u,o).
+
+// ###
+
+RobjValAsgnInst(c,l,h) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+// #DVC(c,l,o) :- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+CVC(c,l,o) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+
+// ###
+
+RobjVarAsgnInst(c,l,r) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+// #DVC(c,l,c1) :- RobjVarAsgnInst(c,l,r), DVC(c,r,c1), VCfilter(l,c1).
+CVC(c,l,c1) <- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).
+
+// ###
+
+RgetInstFldInst(c,l,b,f) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+// #DVC(c,l,c2) :- RgetInstFldInst(c,l,b,f), DVC(c,b,c1), CFC(c1,f,c2). split
+CVC(c,l,c2) <- RgetInstFldInst(c,l,b,f), CVC(c,b,c1), CFC(c1,f,c2). 
+
+// ###
+
+RgetStatFldInst(c,l,f) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+// #DVC(c,l,o) :- RgetStatFldInst(c,l,f), FC(f,o).
+CVC(c,l,o) <- RgetStatFldInst(c,l,f), FC(f,o).
+
+// ###
+
+RputInstFldInst(c,b,f,r) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+// #CFC(c1,f,c2) :- RputInstFldInst(c,b,f,r), DVC(c,b,c1), DVC(c,r,c2). split
+CFC(c1,f,c2) <- RputInstFldInst(c,b,f,r), CVC(c,b,c1), CVC(c,r,c2). 
+
+// ###
+
+RputStatFldInst(c,f,r) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+// #FC(f,o) :- RputStatFldInst(c,f,r), DVC(c,r,o).
+FC(f,o) <- RputStatFldInst(c,f,r), CVC(c,r,o).
+
+// ## reflection handling rules
+
+reachableCM(c,m) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM(c,m) <- reachableCI(c,i), conNewInstIM(i,m).
+
+// #DVC(c,v,o)  :- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+// #DVC(c,v,o)  :- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+// #DVC(c,v,o2) :- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), DVC(c,u,o), CFC(o,0,o2).
+// #DVC(c,v,o)  :- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+// #DVC(c,v,o)  :- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+// #DVC(c,v,o)  :- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+
+//CVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), CVC(c,u,o), CFC(o,0,o2).
+//CVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+CVC(c,v,o)  <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), CVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o)  <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+
+// ### epsilonV(v): treat v context-insensitively
+
+// #DVC(_,v,o) :- DVC(_,v,o), epsilonV(v).
+
+// ### rules propagating reachableT
+
+reachableT(t) <- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), clsForNameIT(i,t).
+
+reachableT(t) <- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
+reachableT(t) <- reachableCM(_,m), staticTM(t,m).
+reachableT(t) <- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
+reachableT(t) <- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+
+// ### CVC <- DVC (clean up context-insensitive stuff)
+
+// #CVC(0,v,o) :- DVC(_,v,o),  epsilonV(v).
+// #CVC(c,v,o) :- DVC(c,v,o), !epsilonV(v).
+
+//rootCM(0,0).
+rootCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//rootCM(0,m) <- reachableT(t), clinitTM(t,m).
+rootCM(c0,m) <- reachableT(t), clinitTM(t,m), C_index[c0] = 0.
+CMCM(c,m,d,n) <- CICM(c,i,d,n), MI(m,i).
diff -Nur jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,103 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kobj/kobj-bit-init-dlog_XZ89_.dlog on 2015-04-20 13:08:42.284082
+// :name: kobj-bit-init-dlog_XZ89_
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+// :domains: V
+
+
+// #Input relations
+// :inputs: initCOC(C,H,C)
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: HK(H,K)
+// :inputs: OK(H,K)
+// :inputs: roots(M)
+// :inputs: IM(I,M)
+// :inputs: VH(V,H)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: CL(C,K)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: statM(M)
+// :inputs: AllowH(H,K)
+// :inputs: DenyH(H,K)
+// :inputs: AllowO(H,K)
+// :inputs: DenyO(H,K)
+// :inputs: thisMV(M,V)
+
+// #Output relations
+// :outputs: CHC_1(C,H,C)
+CHC_1(c,h,c1) -> C(c), H(h), C(c1).
+// :outputs: HM(H,M)
+HM(h,m) -> H(h), M(m).
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CHC_2(C,H,C)
+CHC_2(c,h,c1) -> C(c), H(h), C(c1).
+// :outputs: COC(C,H,C)
+COC(c,h,c1) -> C(c), H(h), C(c1).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+// :outputs: COC_2(C,H,C)
+COC_2(c1,h,c3) -> C(c1), H(h), C(c3).
+// :outputs: COC_1(C,H,C)
+COC_1(c1,h,c2) -> C(c1), H(h), C(c2).
+
+// #Instrumented relations
+// :outputs: CM_XZ89_8_11(C,M,C,H)
+CM_XZ89_8_11(c,m,v_XZ89_0,h) -> C(c), M(m), C(v_XZ89_0), H(h).
+// :outputs: CM_XZ89_9_11(C,M,M,I)
+CM_XZ89_9_11(c,m1,m0,i) -> C(c), M(m1), M(m0), I(i).
+// :outputs: COC_2_XZ89_6_11(C,H,C,C,K,K)
+COC_2_XZ89_6_11(c1,h,c3,c2,l1,l2) -> C(c1), H(h), C(c3), C(c2), K(l1), K(l2).
+// :outputs: COC_XZ89_7_11(C,H,C,K)
+COC_XZ89_7_11(c1,h,c2,l) -> C(c1), H(h), C(c2), K(l).
+// :outputs: CM_XZ89_12_11(M)
+CM_XZ89_12_11(m) -> M(m).
+// :outputs: CHC_1_XZ89_10_11(C,H,C,M)
+CHC_1_XZ89_10_11(c1,h,c2,m) -> C(c1), H(h), C(c2), M(m).
+// :outputs: COC_1_XZ89_11_11(C,H,C,M)
+COC_1_XZ89_11_11(c1,h,c2,m) -> C(c1), H(h), C(c2), M(m).
+// :outputs: CHC_2_XZ89_2_11(C,H,C,C,K,K)
+CHC_2_XZ89_2_11(c1,h,c3,c2,l1,l2) -> C(c1), H(h), C(c3), C(c2), K(l1), K(l2).
+// :outputs: CHC_XZ89_1_11(C,H,C,K)
+CHC_XZ89_1_11(c1,h,c2,l) -> C(c1), H(h), C(c2), K(l).
+// :outputs: COC_XZ89_5_11(C,H,C,K)
+COC_XZ89_5_11(c1,h,c2,l) -> C(c1), H(h), C(c2), K(l).
+// :outputs: CHC_XZ89_3_11(C,H,C,K)
+CHC_XZ89_3_11(c1,h,c2,l) -> C(c1), H(h), C(c2), K(l).
+
+// #Original rules
+HM(h,m) <- thisMV(m,v), VH(v,h).
+//CM(0,m) <- roots(m).
+CM(c0,m) <- roots(m), C_index[c0] = 0.
+CM(c,m) <- COC(_,h,c), HM(h,m).
+CM(c,m1) <- CM(c,m0), IM(i,m1), statM(m1), MI(m0,i).
+//AllowH(_,0).
+AllowH(h,k0) <- H(h), K_index[k0] = 0.
+CHC_1(c1,h,c2) <- MH(m,h), CM(c1,m), initCHC(c1,h,c2).
+CHC(c1,h,c2) <- CHC_1(c1,h,c2), CL(c2,l), AllowH(h,l).
+CHC_2(c1,h,c3) <- CHC_1(c1,h,c2), CL(c2,l1), DenyH(h,l2), truncCKC(c2,l2,c3), l2<=l1.
+CHC(c1,h,c2) <- CHC_2(c1,h,c2), CL(c2,l), AllowH(h,l).
+//AllowO(_,0).
+AllowO(h,k0) <- H(h), K_index[k0] = 0.
+COC_1(c1,h,c2) <- MH(m,h), CM(c1,m), initCOC(c1,h,c2).
+COC(c1,h,c2) <- COC_1(c1,h,c2), CL(c2,l), AllowO(h,l).
+COC_2(c1,h,c3) <- COC_1(c1,h,c2), CL(c2,l1), DenyO(h,l2), truncCKC(c2,l2,c3), l2<=l1.
+COC(c1,h,c2) <- COC_2(c1,h,c2), CL(c2,l), AllowO(h,l).
+
+// #Instrumented rules
+CHC_XZ89_1_11(c1,h,c2,l) <- CHC_1(c1,h,c2), CL(c2,l), AllowH(h,l).
+CHC_2_XZ89_2_11(c1,h,c3,c2,l1,l2) <- CHC_1(c1,h,c2), CL(c2,l1), DenyH(h,l2), truncCKC(c2,l2,c3), l2<=l1.
+CHC_XZ89_3_11(c1,h,c2,l) <- CHC_2(c1,h,c2), CL(c2,l), AllowH(h,l).
+COC_XZ89_5_11(c1,h,c2,l) <- COC_1(c1,h,c2), CL(c2,l), AllowO(h,l).
+COC_2_XZ89_6_11(c1,h,c3,c2,l1,l2) <- COC_1(c1,h,c2), CL(c2,l1), DenyO(h,l2), truncCKC(c2,l2,c3), l2<=l1.
+COC_XZ89_7_11(c1,h,c2,l) <- COC_2(c1,h,c2), CL(c2,l), AllowO(h,l).
+CM_XZ89_8_11(c,m,v_XZ89_0,h) <- COC(v_XZ89_0,h,c), HM(h,m).
+CM_XZ89_9_11(c,m1,m0,i) <- CM(c,m0), IM(i,m1), statM(m1), MI(m0,i).
+CHC_1_XZ89_10_11(c1,h,c2,m) <- MH(m,h), CM(c1,m), initCHC(c1,h,c2).
+COC_1_XZ89_11_11(c1,h,c2,m) <- MH(m,h), CM(c1,m), initCOC(c1,h,c2).
+CM_XZ89_12_11(m) <- roots(m).
diff -Nur jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init.logic jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init.logic
--- jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kobj/kobj-bit-init.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,91 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kobj/kobj-bit-init.dlog on 2015-04-20 13:08:42.285885
+
+// # Author: Xin Zhang
+// :name: kobj-bit-init-dlog
+
+// :domains: I
+// :domains: M
+// :domains: K
+// :domains: C
+// :domains: H
+// :domains: V
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: initCOC(C,H,C)
+// :inputs: initCHC(C,H,C)
+// :inputs: truncCKC(C,K,C)
+// :inputs: HK(H,K)
+// :inputs: OK(H,K)
+// :inputs: roots(M)
+// :inputs: IM(I,M)
+// :inputs: VH(V,H)
+// :inputs: MI(M,I)
+// :inputs: MH(M,H)
+// :inputs: CL(C,K)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: statM(M)
+
+// :inputs: AllowH(H,K)
+// :inputs: DenyH(H,K)
+// :inputs: AllowO(H,K)
+// :inputs: DenyO(H,K)
+
+// :inputs: thisMV(M,V)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: HM(H,M)
+HM(h,m) -> H(h), M(m).
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_1(C,H,C)
+CHC_1(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: CHC_2(C,H,C)
+CHC_2(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: COC_1(C,H,C)
+COC_1(c,h,c1) -> C(c), H(h), C(c1).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: COC_2(C,H,C)
+COC_2(c,h,c1) -> C(c), H(h), C(c1).
+
+// :outputs: CM(C,M)
+CM(c,m) -> C(c), M(m).
+// :outputs: CHC(C,H,C)
+CHC(c,h,c1) -> C(c), H(h), C(c1).
+// :outputs: COC(C,H,C)
+COC(c,h,c1) -> C(c), H(h), C(c1).
+
+// ###
+// # Constraints
+// ###
+
+HM(h,m) <- thisMV(m,v), VH(v,h).
+
+//CM(0,m) <- roots(m).
+CM(c0,m) <- roots(m), C_index[c0] = 0.
+// #CM(c,m) :- CHC(_,h,c), HM(h,m).
+CM(c,m) <- COC(_,h,c), HM(h,m).
+CM(c,m1) <- CM(c,m0), IM(i,m1), statM(m1), MI(m0,i).
+
+//AllowH(_,0).
+AllowH(h,k0) <- H(h), K_index[k0] = 0.
+
+CHC_1(c1,h,c2) <- MH(m,h), CM(c1,m),initCHC(c1,h,c2).
+CHC(c1,h,c2) <- CHC_1(c1,h,c2),CL(c2,l),AllowH(h,l).
+
+CHC_2(c1,h,c3) <- CHC_1(c1,h,c2), CL(c2,l1), DenyH(h,l2), truncCKC(c2,l2,c3), l2 <= l1.
+CHC(c1,h,c2) <- CHC_2(c1,h,c2), CL(c2,l), AllowH(h,l).
+
+
+//AllowO(_,0).
+AllowO(h,k0) <- H(h), K_index[k0] = 0.
+
+COC_1(c1,h,c2) <- MH(m,h), CM(c1,m),initCOC(c1,h,c2).
+COC(c1,h,c2) <- COC_1(c1,h,c2),CL(c2,l),AllowO(h,l).
+
+COC_2(c1,h,c3) <- COC_1(c1,h,c2), CL(c2,l1), DenyO(h,l2), truncCKC(c2,l2,c3), l2 <= l1.
+COC(c1,h,c2) <- COC_2(c1,h,c2), CL(c2,l), AllowO(h,l).
diff -Nur jchord/main/src/chord/analyses/provenance/kobj/pro-cspa-kobj-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/kobj/pro-cspa-kobj-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/kobj/pro-cspa-kobj-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/kobj/pro-cspa-kobj-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,353 @@
+// Created by convert.py from ./src/chord/analyses/provenance/kobj/pro-cspa-kobj-dlog_XZ89_.dlog on 2015-04-20 13:08:42.287134
+// :name: pro-cspa-kobj-dlog_XZ89_
+// :domains: F
+// :domains: H
+// :domains: I
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: Z
+// :domains: C
+
+
+// #Input relations
+// :inputs: HT(H0,T1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: sub(T1,T0)
+// :inputs: MI(M,I)
+// :inputs: statIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: virtIM(I,M)
+// :inputs: MobjValAsgnInst(M,V,H)
+// :inputs: MobjVarAsgnInst(M,V,V)
+// :inputs: MgetInstFldInst(M,V,V,F)
+// :inputs: MputInstFldInst(M,V,F,V)
+// :inputs: MgetStatFldInst(M,V,F)
+// :inputs: MputStatFldInst(M,F,V)
+// :inputs: clsForNameIT(I,T)
+// :inputs: objNewInstIH(I,H)
+// :inputs: objNewInstIM(I,M)
+// :inputs: conNewInstIH(I,H)
+// :inputs: conNewInstIM(I,M)
+// :inputs: aryNewInstIH(I,H)
+// :inputs: classT(T)
+// :inputs: staticTM(T,M)
+// :inputs: staticTF(T,F)
+// :inputs: clinitTM(T,M)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: MspcMethArg(M,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: IinvkArg0(I0,V1)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: argCopy(I,V,M,V)
+// :inputs: retCopy(I,V,M,V)
+// :inputs: VCfilter(V,C)
+// :inputs: CH(C,H)
+// :inputs: epsilonM(M)
+// :inputs: kobjSenM(M)
+// :inputs: ctxtCpyM(M)
+// :inputs: CHC(C,H,C)
+// :inputs: COC(C,H,C)
+
+// #Output relations
+// :outputs: CFC_37_0(C,F,V,C)
+CFC_37_0(_c,_f,_r,_c1) -> C(_c), F(_f), V(_r), C(_c1).
+// :outputs: CCMatch(C,C)
+CCMatch(c,d) -> C(c), C(d).
+// :outputs: CCM(C,C,M)
+CCM(c,d,m) -> C(c), C(d), M(m).
+// :outputs: CVC_33_0(C,V,F,C)
+CVC_33_0(_c,_l,_f,_c1) -> C(_c), V(_l), F(_f), C(_c1).
+// :outputs: RobjValAsgnInst(C,V,H)
+RobjValAsgnInst(c,l,h) -> C(c), V(l), H(h).
+// :outputs: RgetInstFldInst(C,V,V,F)
+RgetInstFldInst(c,l,b,f) -> C(c), V(l), V(b), F(f).
+// :outputs: RobjVarAsgnInst(C,V,V)
+RobjVarAsgnInst(c,l,r) -> C(c), V(l), V(r).
+// :outputs: RgetStatFldInst(C,V,F)
+RgetStatFldInst(c,l,f) -> C(c), V(l), F(f).
+// :outputs: RputInstFldInst(C,V,F,V)
+RputInstFldInst(c,b,f,r) -> C(c), V(b), F(f), V(r).
+// :outputs: RputStatFldInst(C,F,V)
+RputStatFldInst(c,f,r) -> C(c), F(f), V(r).
+// :outputs: reachableT(T)
+reachableT(t) -> T(t).
+// :outputs: DIC(C,I,C)
+DIC(c,i,c1) -> C(c), I(i), C(c1).
+// :outputs: IHM(I,H,M)
+IHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: DVDV(C,V,C,V)
+DVDV(c,u,d,v) -> C(c), V(u), C(d), V(v).
+// :outputs: ctxtInsIHM(I,H,M)
+ctxtInsIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: DIH(C,I,H)
+DIH(c,i,h) -> C(c), I(i), H(h).
+// :outputs: DI(C,I)
+DI(c,i) -> C(c), I(i).
+// :outputs: kobjSenSpecIM(I,M)
+kobjSenSpecIM(i,m) -> I(i), M(m).
+// :outputs: ctxtInsSpecIM(I,M)
+ctxtInsSpecIM(i,m) -> I(i), M(m).
+// :outputs: kobjSenICM(I,C,M)
+kobjSenICM(i,c,m) -> I(i), C(c), M(m).
+// :outputs: kobjSenIHM(I,H,M)
+kobjSenIHM(i,h,m) -> I(i), H(h), M(m).
+// :outputs: reachableCM(C,M)
+reachableCM(c,m) -> C(c), M(m).
+// :outputs: reachableCI(C,I)
+reachableCI(c,i) -> C(c), I(i).
+// :outputs: ctxtCpyStatIM(I,M)
+ctxtCpyStatIM(i,m) -> I(i), M(m).
+// :outputs: ctxtInsStatIM(I,M)
+ctxtInsStatIM(i,m) -> I(i), M(m).
+// :outputs: CVC(C,V,C)
+CVC(c1,v,c2) -> C(c1), V(v), C(c2).
+// :outputs: CMCM(C,M,C,M)
+CMCM(c,m,d,n) -> C(c), M(m), C(d), M(n).
+// :outputs: CICM(C,I,C,M)
+CICM(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: rootCM(C,M)
+rootCM(c,m) -> C(c), M(m).
+// :outputs: CFC(C,F,C)
+CFC(c1,f,c2) -> C(c1), F(f), C(c2).
+// :outputs: FC(F,C)
+FC(f,c) -> F(f), C(c).
+
+// #Instrumented relations
+// :outputs: CCMatch_XZ89_0_66(C,C,C,H)
+CCMatch_XZ89_0_66(c2,c3,c1,h) -> C(c2), C(c3), C(c1), H(h).
+// :outputs: CICM_XZ89_1_66(C,I,C,M,C)
+CICM_XZ89_1_66(c,i,n,m,o) -> C(c), I(i), C(n), M(m), C(o).
+// :outputs: CCM_XZ89_2_66(C,C,M,C,I)
+CCM_XZ89_2_66(o,n,m,c,i) -> C(o), C(n), M(m), C(c), I(i).
+// :outputs: CICM_XZ89_7_66(C,I,C,M)
+CICM_XZ89_7_66(c,i,d,m) -> C(c), I(i), C(d), M(m).
+// :outputs: CVC_XZ89_8_66(C,V,C,M,H)
+CVC_XZ89_8_66(d,v,o,m,h) -> C(d), V(v), C(o), M(m), H(h).
+// :outputs: DVDV_XZ89_9_66(C,V,C,V,I,M)
+DVDV_XZ89_9_66(d,v,c,u,i,m) -> C(d), V(v), C(c), V(u), I(i), M(m).
+// :outputs: DVDV_XZ89_10_66(C,V,C,V,I,M)
+DVDV_XZ89_10_66(c,u,d,v,i,m) -> C(c), V(u), C(d), V(v), I(i), M(m).
+// :outputs: CICM_XZ89_3_66(C,I,M)
+CICM_XZ89_3_66(c,i,m) -> C(c), I(i), M(m).
+// :outputs: CICM_XZ89_4_66(C,I,C,M,C)
+CICM_XZ89_4_66(c,i,n,m,o) -> C(c), I(i), C(n), M(m), C(o).
+// :outputs: CCM_XZ89_5_66(C,C,M,C,I)
+CCM_XZ89_5_66(o,n,m,c,i) -> C(o), C(n), M(m), C(c), I(i).
+// :outputs: CICM_XZ89_6_66(C,I,M)
+CICM_XZ89_6_66(c,i,m) -> C(c), I(i), M(m).
+// :outputs: CFC_XZ89_16_66(C,F,C,C,V)
+CFC_XZ89_16_66(c1,f,c2,c,r) -> C(c1), F(f), C(c2), C(c), V(r).
+// :outputs: CVC_XZ89_15_66(C,V,C,F)
+CVC_XZ89_15_66(c,l,o,f) -> C(c), V(l), C(o), F(f).
+// :outputs: CVC_XZ89_18_66(C,V,C,I,M,H)
+CVC_XZ89_18_66(c,v,o,i,m,h) -> C(c), V(v), C(o), I(i), M(m), H(h).
+// :outputs: FC_XZ89_17_66(F,C,C,V)
+FC_XZ89_17_66(f,o,c,r) -> F(f), C(o), C(c), V(r).
+// :outputs: CVC_XZ89_12_66(C,V,C,H)
+CVC_XZ89_12_66(c,l,o,h) -> C(c), V(l), C(o), H(h).
+// :outputs: CVC_XZ89_11_66(C,V,C,C,V)
+CVC_XZ89_11_66(c,u,o,d,v) -> C(c), V(u), C(o), C(d), V(v).
+// :outputs: CVC_XZ89_14_66(C,V,C,F,C)
+CVC_XZ89_14_66(c,l,c2,f,c1) -> C(c), V(l), C(c2), F(f), C(c1).
+// :outputs: CVC_XZ89_13_66(C,V,C,V)
+CVC_XZ89_13_66(c,l,c1,r) -> C(c), V(l), C(c1), V(r).
+// :outputs: CMCM_XZ89_24_66(C,M,C,M,I)
+CMCM_XZ89_24_66(c,m,d,n,i) -> C(c), M(m), C(d), M(n), I(i).
+// :outputs: CVC_XZ89_23_66(C,V,C,I,H)
+CVC_XZ89_23_66(c,v,o,i,h) -> C(c), V(v), C(o), I(i), H(h).
+// :outputs: CFC_37_0_XZ89_26_66(C,F,V,C,V)
+CFC_37_0_XZ89_26_66(c,f,r,c1,b) -> C(c), F(f), V(r), C(c1), V(b).
+// :outputs: CVC_33_0_XZ89_25_66(C,V,F,C,V)
+CVC_33_0_XZ89_25_66(c,l,f,c1,b) -> C(c), V(l), F(f), C(c1), V(b).
+// :outputs: CVC_XZ89_20_66(C,V,C,I,M,V,C)
+CVC_XZ89_20_66(c,v,o2,i,m,u,o) -> C(c), V(v), C(o2), I(i), M(m), V(u), C(o).
+// :outputs: CVC_XZ89_19_66(C,V,C,I,H)
+CVC_XZ89_19_66(c,v,o,i,h) -> C(c), V(v), C(o), I(i), H(h).
+// :outputs: CVC_XZ89_22_66(C,V,C,I,H)
+CVC_XZ89_22_66(c,v,o,i,h) -> C(c), V(v), C(o), I(i), H(h).
+// :outputs: CVC_XZ89_21_66(C,V,C,I,M,H)
+CVC_XZ89_21_66(c,v,o,i,m,h) -> C(c), V(v), C(o), I(i), M(m), H(h).
+// :outputs: RobjValAsgnInst_XZ89_33_66(C,V,H,M)
+RobjValAsgnInst_XZ89_33_66(c,l,h,m) -> C(c), V(l), H(h), M(m).
+// :outputs: RobjVarAsgnInst_XZ89_34_66(C,V,V,M)
+RobjVarAsgnInst_XZ89_34_66(c,l,r,m) -> C(c), V(l), V(r), M(m).
+// :outputs: DI_XZ89_31_66(C,I,H)
+DI_XZ89_31_66(c,i,v_XZ89_0) -> C(c), I(i), H(v_XZ89_0).
+// :outputs: CICM_XZ89_32_66(C,I,M,H)
+CICM_XZ89_32_66(c,i,m,h) -> C(c), I(i), M(m), H(h).
+// :outputs: DIC_XZ89_29_66(C,I,C,V)
+DIC_XZ89_29_66(c,i,o,v) -> C(c), I(i), C(o), V(v).
+// :outputs: DIH_XZ89_30_66(C,I,H,C)
+DIH_XZ89_30_66(c,i,h,o) -> C(c), I(i), H(h), C(o).
+// :outputs: reachableCM_XZ89_27_66(C,M,C,I)
+reachableCM_XZ89_27_66(c,m,v_XZ89_0,v_XZ89_1) -> C(c), M(m), C(v_XZ89_0), I(v_XZ89_1).
+// :outputs: reachableCI_XZ89_28_66(C,I,M)
+reachableCI_XZ89_28_66(c,i,m) -> C(c), I(i), M(m).
+// :outputs: reachableT_XZ89_41_66(T,C,I,H)
+reachableT_XZ89_41_66(t,v_XZ89_0,i,h) -> T(t), C(v_XZ89_0), I(i), H(h).
+// :outputs: reachableT_XZ89_42_66(T,C,I,H)
+reachableT_XZ89_42_66(t,v_XZ89_0,i,h) -> T(t), C(v_XZ89_0), I(i), H(h).
+// :outputs: reachableCM_XZ89_39_66(C,M,I)
+reachableCM_XZ89_39_66(c,m,i) -> C(c), M(m), I(i).
+// :outputs: reachableCM_XZ89_40_66(C,M,I)
+reachableCM_XZ89_40_66(c,m,i) -> C(c), M(m), I(i).
+// :outputs: RputInstFldInst_XZ89_37_66(C,V,F,V,M)
+RputInstFldInst_XZ89_37_66(c,b,f,r,m) -> C(c), V(b), F(f), V(r), M(m).
+// :outputs: RputStatFldInst_XZ89_38_66(C,F,V,M)
+RputStatFldInst_XZ89_38_66(c,f,r,m) -> C(c), F(f), V(r), M(m).
+// :outputs: RgetInstFldInst_XZ89_35_66(C,V,V,F,M)
+RgetInstFldInst_XZ89_35_66(c,l,b,f,m) -> C(c), V(l), V(b), F(f), M(m).
+// :outputs: RgetStatFldInst_XZ89_36_66(C,V,F,M)
+RgetStatFldInst_XZ89_36_66(c,l,f,m) -> C(c), V(l), F(f), M(m).
+// :outputs: reachableCM_XZ89_51_66(M,T)
+reachableCM_XZ89_51_66(m,t) -> M(m), T(t).
+// :outputs: rootCM_XZ89_49_66(M,T)
+rootCM_XZ89_49_66(m,t) -> M(m), T(t).
+// :outputs: reachableT_XZ89_48_66(T,T)
+reachableT_XZ89_48_66(t,s) -> T(t), T(s).
+// :outputs: reachableT_XZ89_47_66(T,C,M,V,F)
+reachableT_XZ89_47_66(t,v_XZ89_0,m,v_XZ89_1,f) -> T(t), C(v_XZ89_0), M(m), V(v_XZ89_1), F(f).
+// :outputs: reachableT_XZ89_46_66(T,C,M,F,V)
+reachableT_XZ89_46_66(t,v_XZ89_0,m,f,v_XZ89_1) -> T(t), C(v_XZ89_0), M(m), F(f), V(v_XZ89_1).
+// :outputs: reachableT_XZ89_45_66(T,C,M)
+reachableT_XZ89_45_66(t,v_XZ89_0,m) -> T(t), C(v_XZ89_0), M(m).
+// :outputs: reachableT_XZ89_44_66(T,C,M,V,H)
+reachableT_XZ89_44_66(t,v_XZ89_0,m,v_XZ89_1,h) -> T(t), C(v_XZ89_0), M(m), V(v_XZ89_1), H(h).
+// :outputs: reachableT_XZ89_43_66(T,C,I)
+reachableT_XZ89_43_66(t,v_XZ89_0,i) -> T(t), C(v_XZ89_0), I(i).
+
+// #Original rules
+CCMatch(c2,c3) <- CHC(c1,h,c2), COC(c1,h,c3).
+IHM(i,h,m2) <- virtIM(i,m1), HT(h,t), cha(m1,t,m2).
+ctxtInsIHM(i,h,m) <- IHM(i,h,m), epsilonM(m).
+kobjSenIHM(i,h,m) <- IHM(i,h,m), kobjSenM(m).
+kobjSenICM(i,o,m) <- kobjSenIHM(i,h,m), CH(o,h).
+ctxtInsSpecIM(i,m) <- specIM(i,m), epsilonM(m).
+kobjSenSpecIM(i,m) <- specIM(i,m), kobjSenM(m).
+ctxtInsStatIM(i,m) <- statIM(i,m), epsilonM(m).
+ctxtCpyStatIM(i,m) <- statIM(i,m), ctxtCpyM(m).
+//reachableCM(0,0).
+reachableCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//reachableCM(0,m) <- clinitTM(t,m), reachableT(t).
+reachableCM(c0,m) <- clinitTM(t,m), reachableT(t), C_index[c0] = 0.
+reachableCM(c,m) <- CICM(_,_,c,m).
+reachableCI(c,i) <- MI(m,i), reachableCM(c,m).
+DIC(c,i,o) <- IinvkArg0(i,v), CVC(c,v,o).
+DIH(c,i,h) <- DIC(c,i,o), CH(o,h).
+DI(c,i) <- DIH(c,i,_).
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h), C_index[c0] = 0.
+CICM(c,i,n,m) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o), CCMatch(o,n).
+CCM(o,n,m) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o), CCMatch(o,n).
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i), C_index[c0] = 0.
+CICM(c,i,n,m) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o), CCMatch(o,n).
+CCM(o,n,m) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o), CCMatch(o,n).
+//CICM(c,i,0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM(c,i,c0,m) <- reachableCI(c,i), ctxtInsStatIM(i,m), C_index[c0] = 0.
+CICM(c,i,d,m) <- reachableCI(c,i), ctxtCpyStatIM(i,m), d=c.
+CVC(d,v,o) <- CCM(o,d,m), MspcMethArg(m,v), CH(d,h), CH(o,h).
+DVDV(d,v,c,u) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV(c,u,d,v) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+CVC(c,u,o) <- DVDV(c,u,d,v), CVC(d,v,o), VCfilter(u,o).
+RobjValAsgnInst(c,l,h) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+CVC(c,l,o) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+RobjVarAsgnInst(c,l,r) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+CVC(c,l,c1) <- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).
+RgetInstFldInst(c,l,b,f) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+CVC(c,l,c2) <- CVC_33_0(c,l,f,c1), CFC(c1,f,c2).
+RgetStatFldInst(c,l,f) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+CVC(c,l,o) <- RgetStatFldInst(c,l,f), FC(f,o).
+RputInstFldInst(c,b,f,r) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+CFC(c1,f,c2) <- CFC_37_0(c,f,r,c1), CVC(c,r,c2).
+RputStatFldInst(c,f,r) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+FC(f,o) <- RputStatFldInst(c,f,r), CVC(c,r,o).
+reachableCM(c,m) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM(c,m) <- reachableCI(c,i), conNewInstIM(i,m).
+//CVC(c,v,o) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), CVC(c,u,o), CFC(o,0,o2).
+//CVC(c,v,o) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//CVC(c,v,o) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC(c,v,o) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+CVC(c,v,o) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o2) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), CVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC(c,v,o) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+reachableT(t) <- reachableCI(_,i), conNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), objNewInstIH(i,h), HT(h,t).
+reachableT(t) <- reachableCI(_,i), clsForNameIT(i,t).
+reachableT(t) <- reachableCM(_,m), MobjValAsgnInst(m,_,h), HT(h,t).
+reachableT(t) <- reachableCM(_,m), staticTM(t,m).
+reachableT(t) <- reachableCM(_,m), MputStatFldInst(m,f,_), staticTF(t,f).
+reachableT(t) <- reachableCM(_,m), MgetStatFldInst(m,_,f), staticTF(t,f).
+reachableT(t) <- classT(t), reachableT(s), sub(s,t).
+//rootCM(0,0).
+rootCM(c0,m0) <- C_index[c0] = 0, M_index[m0] = 0.
+//rootCM(0,m) <- reachableT(t), clinitTM(t,m).
+rootCM(c0,m) <- reachableT(t), clinitTM(t,m), C_index[c0] = 0.
+CMCM(c,m,d,n) <- CICM(c,i,d,n), MI(m,i).
+CVC_33_0(c,l,f,c1) <- RgetInstFldInst(c,l,b,f), CVC(c,b,c1).
+CFC_37_0(c,f,r,c1) <- RputInstFldInst(c,b,f,r), CVC(c,b,c1).
+
+// #Instrumented rules
+CCMatch_XZ89_0_66(c2,c3,c1,h) <- CHC(c1,h,c2), COC(c1,h,c3).
+CICM_XZ89_1_66(c,i,n,m,o) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o), CCMatch(o,n).
+CCM_XZ89_2_66(o,n,m,c,i) <- reachableCI(c,i), kobjSenICM(i,o,m), DIC(c,i,o), CCMatch(o,n).
+CICM_XZ89_3_66(c,i,m) <- reachableCI(c,i), ctxtInsSpecIM(i,m), DI(c,i).
+CICM_XZ89_4_66(c,i,n,m,o) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o), CCMatch(o,n).
+CCM_XZ89_5_66(o,n,m,c,i) <- reachableCI(c,i), kobjSenSpecIM(i,m), DIC(c,i,o), CCMatch(o,n).
+CICM_XZ89_6_66(c,i,m) <- reachableCI(c,i), ctxtInsStatIM(i,m).
+CICM_XZ89_7_66(c,i,d,m) <- reachableCI(c,i), ctxtCpyStatIM(i,m), d=c.
+CVC_XZ89_8_66(d,v,o,m,h) <- CCM(o,d,m), MspcMethArg(m,v), CH(d,h), CH(o,h).
+DVDV_XZ89_9_66(d,v,c,u,i,m) <- argCopy(i,u,m,v), CICM(c,i,d,m).
+DVDV_XZ89_10_66(c,u,d,v,i,m) <- retCopy(i,u,m,v), CICM(c,i,d,m).
+CVC_XZ89_11_66(c,u,o,d,v) <- DVDV(c,u,d,v), CVC(d,v,o), VCfilter(u,o).
+CVC_XZ89_12_66(c,l,o,h) <- RobjValAsgnInst(c,l,h), CHC(c,h,o).
+CVC_XZ89_13_66(c,l,c1,r) <- RobjVarAsgnInst(c,l,r), CVC(c,r,c1), VCfilter(l,c1).
+CVC_XZ89_14_66(c,l,c2,f,c1) <- CVC_33_0(c,l,f,c1), CFC(c1,f,c2).
+CVC_XZ89_15_66(c,l,o,f) <- RgetStatFldInst(c,l,f), FC(f,o).
+CFC_XZ89_16_66(c1,f,c2,c,r) <- CFC_37_0(c,f,r,c1), CVC(c,r,c2).
+FC_XZ89_17_66(f,o,c,r) <- RputStatFldInst(c,f,r), CVC(c,r,o).
+//CVC_XZ89_18_66(c,v,o,i,m,h) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,0,v), objNewInstIH(i,h), CHC(c,h,o).
+//CVC_XZ89_19_66(c,v,o,i,h) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC_XZ89_20_66(c,v,o2,i,m,u,o) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,1,u), MmethArg(m,1,v), CVC(c,u,o), CFC(o,0,o2).
+//CVC_XZ89_21_66(c,v,o,i,m,h) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,0,v), conNewInstIH(i,h), CHC(c,h,o).
+//CVC_XZ89_22_66(c,v,o,i,h) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+//CVC_XZ89_23_66(c,v,o,i,h) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,0,v), CHC(c,h,o).
+CVC_XZ89_18_66(c,v,o,i,m,h) <- reachableCI(c,i), objNewInstIM(i,m), MmethArg(m,z0,v), objNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_19_66(c,v,o,i,h) <- reachableCI(c,i), objNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_20_66(c,v,o2,i,m,u,o) <- reachableCI(c,i), conNewInstIM(i,m), IinvkArg(i,z1,u), MmethArg(m,z1,v), CVC(c,u,o), CFC(o,f0,o2), Z_index[z1] = 1, F_index[f0] = 0.
+CVC_XZ89_21_66(c,v,o,i,m,h) <- reachableCI(c,i), conNewInstIM(i,m), MmethArg(m,z0,v), conNewInstIH(i,h), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_22_66(c,v,o,i,h) <- reachableCI(c,i), conNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CVC_XZ89_23_66(c,v,o,i,h) <- reachableCI(c,i), aryNewInstIH(i,h), IinvkRet(i,z0,v), CHC(c,h,o), Z_index[z0] = 0.
+CMCM_XZ89_24_66(c,m,d,n,i) <- CICM(c,i,d,n), MI(m,i).
+CVC_33_0_XZ89_25_66(c,l,f,c1,b) <- RgetInstFldInst(c,l,b,f), CVC(c,b,c1).
+CFC_37_0_XZ89_26_66(c,f,r,c1,b) <- RputInstFldInst(c,b,f,r), CVC(c,b,c1).
+reachableCM_XZ89_27_66(c,m,v_XZ89_0,v_XZ89_1) <- CICM(v_XZ89_0,v_XZ89_1,c,m).
+reachableCI_XZ89_28_66(c,i,m) <- MI(m,i), reachableCM(c,m).
+DIC_XZ89_29_66(c,i,o,v) <- IinvkArg0(i,v), CVC(c,v,o).
+DIH_XZ89_30_66(c,i,h,o) <- DIC(c,i,o), CH(o,h).
+DI_XZ89_31_66(c,i,v_XZ89_0) <- DIH(c,i,v_XZ89_0).
+CICM_XZ89_32_66(c,i,m,h) <- reachableCI(c,i), ctxtInsIHM(i,h,m), DIH(c,i,h).
+RobjValAsgnInst_XZ89_33_66(c,l,h,m) <- reachableCM(c,m), MobjValAsgnInst(m,l,h).
+RobjVarAsgnInst_XZ89_34_66(c,l,r,m) <- reachableCM(c,m), MobjVarAsgnInst(m,l,r).
+RgetInstFldInst_XZ89_35_66(c,l,b,f,m) <- reachableCM(c,m), MgetInstFldInst(m,l,b,f).
+RgetStatFldInst_XZ89_36_66(c,l,f,m) <- reachableCM(c,m), MgetStatFldInst(m,l,f).
+RputInstFldInst_XZ89_37_66(c,b,f,r,m) <- reachableCM(c,m), MputInstFldInst(m,b,f,r).
+RputStatFldInst_XZ89_38_66(c,f,r,m) <- reachableCM(c,m), MputStatFldInst(m,f,r).
+reachableCM_XZ89_39_66(c,m,i) <- reachableCI(c,i), objNewInstIM(i,m).
+reachableCM_XZ89_40_66(c,m,i) <- reachableCI(c,i), conNewInstIM(i,m).
+reachableT_XZ89_41_66(t,v_XZ89_0,i,h) <- reachableCI(v_XZ89_0,i), conNewInstIH(i,h), HT(h,t).
+reachableT_XZ89_42_66(t,v_XZ89_0,i,h) <- reachableCI(v_XZ89_0,i), objNewInstIH(i,h), HT(h,t).
+reachableT_XZ89_43_66(t,v_XZ89_0,i) <- reachableCI(v_XZ89_0,i), clsForNameIT(i,t).
+reachableT_XZ89_44_66(t,v_XZ89_0,m,v_XZ89_1,h) <- reachableCM(v_XZ89_0,m), MobjValAsgnInst(m,v_XZ89_1,h), HT(h,t).
+reachableT_XZ89_45_66(t,v_XZ89_0,m) <- reachableCM(v_XZ89_0,m), staticTM(t,m).
+reachableT_XZ89_46_66(t,v_XZ89_0,m,f,v_XZ89_1) <- reachableCM(v_XZ89_0,m), MputStatFldInst(m,f,v_XZ89_1), staticTF(t,f).
+reachableT_XZ89_47_66(t,v_XZ89_0,m,v_XZ89_1,f) <- reachableCM(v_XZ89_0,m), MgetStatFldInst(m,v_XZ89_1,f), staticTF(t,f).
+reachableT_XZ89_48_66(t,s) <- classT(t), reachableT(s), sub(s,t).
+rootCM_XZ89_49_66(m,t) <- reachableT(t), clinitTM(t,m).
+reachableCM_XZ89_51_66(m,t) <- clinitTM(t,m), reachableT(t).
diff -Nur jchord/main/src/chord/analyses/provenance/monosite/polysite-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/monosite/polysite-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/monosite/polysite-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/monosite/polysite-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,35 @@
+// Created by convert.py from ./src/chord/analyses/provenance/monosite/polysite-dlog_XZ89_.dlog on 2015-04-20 13:08:42.293406
+// :name: polysite-dlog_XZ89_
+// :domains: M
+// :domains: I
+// :domains: C
+
+
+// #Input relations
+// :inputs: CICM(C,I,C,M)
+// :inputs: virtIM(I,M)
+// :inputs: reachableCI(C,I)
+// :inputs: checkExcludedI(I)
+
+// #Output relations
+// :outputs: virtI(I)
+virtI(i) -> I(i).
+// :outputs: polySite(I)
+polySite(i) -> I(i).
+// :outputs: insvIM(I,M)
+insvIM(i,m) -> I(i), M(m).
+
+// #Instrumented relations
+// :outputs: insvIM_XZ89_0(I,M,C,C)
+insvIM_XZ89_0(i,m,v_XZ89_0,v_XZ89_1) -> I(i), M(m), C(v_XZ89_0), C(v_XZ89_1).
+// :outputs: polySite_XZ89_3(I,M,M)
+polySite_XZ89_3(i,m1,m2) -> I(i), M(m1), M(m2).
+
+// #Original rules
+insvIM(i,m) <- CICM(_,i,_,m).
+virtI(i) <- virtIM(i,_).
+polySite(i) <- virtI(i), insvIM(i,m1), insvIM(i,m2),!checkExcludedI(i), m1!=m2.
+
+// #Instrumented rules
+insvIM_XZ89_0(i,m,v_XZ89_0,v_XZ89_1) <- CICM(v_XZ89_0,i,v_XZ89_1,m).
+polySite_XZ89_3(i,m1,m2) <- virtI(i), insvIM(i,m1), insvIM(i,m2),!checkExcludedI(i), m1!=m2.
diff -Nur jchord/main/src/chord/analyses/provenance/monosite/polysite.logic jchord/main/src/chord/analyses/provenance/monosite/polysite.logic
--- jchord/main/src/chord/analyses/provenance/monosite/polysite.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/monosite/polysite.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,37 @@
+// Created by convert.py from ./src/chord/analyses/provenance/monosite/polysite.dlog on 2015-04-20 13:08:42.294015
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: polysite-dlog
+
+// :domains: M
+// :domains: I
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: CICM(C,I,C,M)
+// :inputs: virtIM(I,M)
+// :inputs: reachableCI(C,I)
+// :inputs: checkExcludedI(I)
+// :outputs: virtI(I)
+virtI(i) -> I(i).
+// :outputs: polySite(I)
+polySite(i) -> I(i).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: insvIM(I,M)
+insvIM(i,m) -> I(i), M(m).
+// :outputs: allQueries(I)
+allQueries(i) -> I(i).
+
+insvIM(i,m) <- CICM(_,i,_,m).
+
+virtI(i) <- virtIM(i,_).
+polySite(i) <- virtI(i), insvIM(i,m1), insvIM(i,m2), !checkExcludedI(i), m1!=m2.
+
diff -Nur jchord/main/src/chord/analyses/provenance/pts/checkExcludedV.logic jchord/main/src/chord/analyses/provenance/pts/checkExcludedV.logic
--- jchord/main/src/chord/analyses/provenance/pts/checkExcludedV.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/pts/checkExcludedV.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,13 @@
+// Created by convert.py from ./src/chord/analyses/provenance/pts/checkExcludedV.dlog on 2015-04-20 13:08:42.294641
+// :name: checkExcludedV-dlog
+
+// :domains: M
+// :domains: V
+
+
+// :inputs: checkExcludedM(M)
+// :inputs: MV(M,V)
+// :outputs: checkExcludedV(V)
+checkExcludedV(v) -> V(v).
+
+checkExcludedV(v) <- MV(m,v), checkExcludedM(m).
diff -Nur jchord/main/src/chord/analyses/provenance/pts/pro-pts-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/pts/pro-pts-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/pts/pro-pts-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/pts/pro-pts-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,43 @@
+// Created by convert.py from ./src/chord/analyses/provenance/pts/pro-pts-dlog_XZ89_.dlog on 2015-04-20 13:08:42.295002
+// :name: pro-pts-dlog_XZ89_
+// :domains: H
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: C
+
+
+// #Input relations
+// :inputs: reachableCM(C,M)
+// :inputs: checkExcludedH(H)
+// :inputs: checkExcludedV(V)
+// :inputs: CVC(C,V,C)
+// :inputs: CH(C,H)
+// :inputs: MV(M,V)
+// :inputs: MH(M,H)
+
+// #Output relations
+// :outputs: reachableV(V)
+reachableV(v) -> V(v).
+// :outputs: reachableH(H)
+reachableH(h) -> H(h).
+// :outputs: ptsVH(V,H)
+ptsVH(v,h) -> V(v), H(h).
+
+// #Instrumented relations
+// :outputs: reachableV_XZ89_0_1(V,M,C)
+reachableV_XZ89_0_1(v,m,v_XZ89_0) -> V(v), M(m), C(v_XZ89_0).
+// :outputs: reachableH_XZ89_1_1(H,M,C)
+reachableH_XZ89_1_1(h,m,v_XZ89_0) -> H(h), M(m), C(v_XZ89_0).
+// :outputs: ptsVH_XZ89_2_1(V,H,C,C)
+ptsVH_XZ89_2_1(v,h,v_XZ89_0,o) -> V(v), H(h), C(v_XZ89_0), C(o).
+
+// #Original rules
+reachableV(v) <- MV(m,v), reachableCM(_,m).
+reachableH(h) <- MH(m,h), reachableCM(_,m).
+ptsVH(v,h) <- CVC(_,v,o), CH(o,h), !checkExcludedV(v), !checkExcludedH(h), reachableV(v), reachableH(h).
+
+// #Instrumented rules
+reachableV_XZ89_0_1(v,m,v_XZ89_0) <- MV(m,v), reachableCM(v_XZ89_0,m).
+reachableH_XZ89_1_1(h,m,v_XZ89_0) <- MH(m,h), reachableCM(v_XZ89_0,m).
+ptsVH_XZ89_2_1(v,h,v_XZ89_0,o) <- CVC(v_XZ89_0,v,o), CH(o,h), !checkExcludedV(v), !checkExcludedH(h), reachableV(v), reachableH(h).
diff -Nur jchord/main/src/chord/analyses/provenance/pts/pts.logic jchord/main/src/chord/analyses/provenance/pts/pts.logic
--- jchord/main/src/chord/analyses/provenance/pts/pts.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/pts/pts.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,36 @@
+// Created by convert.py from ./src/chord/analyses/provenance/pts/pts.dlog on 2015-04-20 13:08:42.295854
+// :name: pro-pts-dlog
+
+// :domains: H
+// :domains: M
+// :domains: T
+// :domains: V
+// :domains: C
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: reachableCM(C,M)
+// :inputs: checkExcludedH(H)
+// :inputs: checkExcludedV(V)
+// :inputs: CVC(C,V,C)
+// :inputs: CH(C,H)
+// :inputs: MV(M,V)
+// :inputs: MH(M,H)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: reachableV(V)
+reachableV(v) -> V(v).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: reachableH(H)
+reachableH(h) -> H(h).
+
+// :outputs: ptsVH(V,H)
+ptsVH(v,h) -> V(v), H(h).
+
+reachableV(v) <- MV(m,v),reachableCM(_,m).
+reachableH(h) <- MH(m,h),reachableCM(_,m).
+
+ptsVH(v,h) <- CVC(_,v,o), CH(o,h), !checkExcludedV(v), !checkExcludedH(h), reachableV(v), reachableH(h).
diff -Nur jchord/main/src/chord/analyses/provenance/typestate/trackedT.logic jchord/main/src/chord/analyses/provenance/typestate/trackedT.logic
--- jchord/main/src/chord/analyses/provenance/typestate/trackedT.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/typestate/trackedT.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,16 @@
+// Created by convert.py from ./src/chord/analyses/provenance/typestate/trackedT.dlog on 2015-04-20 13:08:42.296503
+// :name: trackedT-dlog
+
+// :domains: H
+// :domains: M
+// :domains: T
+
+
+// :inputs: checkIncludedM(M)
+// :inputs: HT(H0,T1)
+// :inputs: MH(M,H)
+// :inputs: reachableM(M)
+// :outputs: trackedT(T)
+trackedT(t) -> T(t).
+
+trackedT(t) <- reachableM(m),checkIncludedM(m),MH(m,h),HT(h,t).
diff -Nur jchord/main/src/chord/analyses/provenance/typestate/typestate-dlog_XZ89_.logic jchord/main/src/chord/analyses/provenance/typestate/typestate-dlog_XZ89_.logic
--- jchord/main/src/chord/analyses/provenance/typestate/typestate-dlog_XZ89_.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/typestate/typestate-dlog_XZ89_.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,859 @@
+// Created by convert.py from ./src/chord/analyses/provenance/typestate/typestate-dlog_XZ89_.dlog on 2015-04-20 13:08:42.296860
+// :name: typestate-dlog_XZ89_
+// :domains: I
+// :domains: M
+// :domains: P
+// :domains: V
+// :domains: Z
+// :domains: H
+// :domains: MS
+// :domains: K
+// :domains: F
+
+
+// #Input relations
+// :inputs: PP(P,P)
+// :inputs: PI(P,I)
+// :inputs: IM(I,M)
+// :inputs: PobjValAsgnInst(P,V,H)
+// :inputs: PobjVarAsgnInst(P,V,V)
+// :inputs: MPhead(M,P)
+// :inputs: rootM(M)
+// :inputs: PobjNullAsgnInst(P,V)
+// :inputs: PgetInstFldInst(P,V,V,F)
+// :inputs: PgetStatFldInst(P,V,F)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: MP(M,P)
+// :inputs: MPtail(M,P)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: MmethRet(M0,Z0,V1)
+// :inputs: MZfirst(M,Z)
+// :inputs: MZlast(M,Z)
+// :inputs: MZZ(M,Z,Z)
+// :inputs: MK(M,K)
+// :inputs: gen(MS,V,MS)
+// :inputs: kill(MS,V,MS)
+// :inputs: contain(V,MS)
+// :inputs: virtIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: PobjRetInst(P,V)
+// :inputs: checkExcludedH(H)
+// :inputs: checkExcludedI(I)
+// :inputs: VH(V,H)
+// :inputs: reachableM(M)
+// :inputs: trackedH(H)
+// :inputs: allow(V)
+// :inputs: deny(V)
+
+// #Output relations
+// :outputs: summary(M,H,MS,H,K)
+summary(m,h,ms1,h2,k) -> M(m), H(h), MS(ms1), H(h2), K(k).
+// :outputs: pathArg(P,Z,M,MS,MS)
+pathArg(p,z,m,ms1,ms2) -> P(p), Z(z), M(m), MS(ms1), MS(ms2).
+// :outputs: path(P,H,MS,H,MS,K)
+path(p,h1,ms1,h2,ms2,k) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), K(k).
+// :outputs: PInvkRetInstFilter(P,M)
+PInvkRetInstFilter(p,m) -> P(p), M(m).
+// :outputs: PInvkRetInstNotFilter(P,M)
+PInvkRetInstNotFilter(p,m) -> P(p), M(m).
+// :outputs: PInvkInst(P,M,V,V,Z)
+PInvkInst(p,m,v,u,z) -> P(p), M(m), V(v), V(u), Z(z).
+// :outputs: PInvkRetInst(P,M,V,V)
+PInvkRetInst(p,m,v,u) -> P(p), M(m), V(v), V(u).
+// :outputs: pathArgInit(P,MS,H)
+pathArgInit(p,ms1,h) -> P(p), MS(ms1), H(h).
+// :outputs: pathArgLast(P,M,MS,MS)
+pathArgLast(p,m,ms1,ms2) -> P(p), M(m), MS(ms1), MS(ms2).
+// :outputs: nonRelevantP(P)
+nonRelevantP(p) -> P(p).
+// :outputs: relevantP(P)
+relevantP(p) -> P(p).
+// :outputs: unprovenQuery(P,H)
+unprovenQuery(p,h) -> P(p), H(h).
+// :outputs: PInvkSkip(P)
+PInvkSkip(p) -> P(p).
+// :outputs: IMFilter(I)
+IMFilter(i) -> I(i).
+// :outputs: path_7_0(P,V,H,P)
+path_7_0(_p,_v,_h,_q) -> P(_p), V(_v), H(_h), P(_q).
+// :outputs: path_8_0(P,V,H,P)
+path_8_0(_p,_v,_h,_q) -> P(_p), V(_v), H(_h), P(_q).
+// :outputs: path_7_3(P,H,MS)
+path_7_3(_p,_h,_ms) -> P(_p), H(_h), MS(_ms).
+// :outputs: path_7_2(P,V,H)
+path_7_2(_p,_v,_h) -> P(_p), V(_v), H(_h).
+// :outputs: path_7_1(P,V,H)
+path_7_1(_p,_v,_h) -> P(_p), V(_v), H(_h).
+// :outputs: path_9_1(P,V,H,MS,H,MS)
+path_9_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_9_0(P,V,P)
+path_9_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_8_2(P,H)
+path_8_2(_p,_h) -> P(_p), H(_h).
+// :outputs: path_8_1(P,V,H)
+path_8_1(_p,_v,_h) -> P(_p), V(_v), H(_h).
+// :outputs: path_11_1(P,V,V,H,MS,H,MS)
+path_11_1(_p,_v,_u,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), V(_u), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_11_2(P,V,H,MS,H,MS)
+path_11_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_11_3(P,V,H,MS,H,MS)
+path_11_3(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_12_0(P,V,V,P)
+path_12_0(_p,_v,_u,_q) -> P(_p), V(_v), V(_u), P(_q).
+// :outputs: path_9_2(P,V,H,MS,H,MS)
+path_9_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_10_0(P,V,P)
+path_10_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_10_1(P,V,H,MS,H,MS)
+path_10_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_11_0(P,V,V,P)
+path_11_0(_p,_v,_u,_q) -> P(_p), V(_v), V(_u), P(_q).
+// :outputs: path_13_2(P,V,H,MS,H,MS)
+path_13_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_14_0(P,V,V,P)
+path_14_0(_p,_v,_u,_q) -> P(_p), V(_v), V(_u), P(_q).
+// :outputs: path_14_1(P,V,V,H,MS,H,MS)
+path_14_1(_p,_v,_u,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), V(_u), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_14_2(P,V,H,MS,H,MS)
+path_14_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_12_1(P,V,V,H,MS,H,MS)
+path_12_1(_p,_v,_u,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), V(_u), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_12_2(P,V,H,MS,H,MS)
+path_12_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_13_0(P,V,V,P)
+path_13_0(_p,_v,_u,_q) -> P(_p), V(_v), V(_u), P(_q).
+// :outputs: path_13_1(P,V,V,H,MS,H,MS)
+path_13_1(_p,_v,_u,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), V(_u), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_16_1(P,V,H,MS,H,MS)
+path_16_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_16_0(P,V,P)
+path_16_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_17_1(P,V,H,MS,H,MS)
+path_17_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_17_0(P,V,P)
+path_17_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_15_0(P,V,P)
+path_15_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_14_3(P,V,H,MS,H,MS)
+path_14_3(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_15_2(P,V,H,MS,H,MS)
+path_15_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_15_1(P,V,H,MS,H,MS)
+path_15_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_19_2(P,V,H,MS,H,MS)
+path_19_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_19_1(P,V,H,MS,H,MS)
+path_19_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_20_1(P,V,H,MS,H,MS)
+path_20_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_20_0(P,V,P)
+path_20_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_18_0(P,V,P)
+path_18_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_17_2(P,V,H,MS,H,MS)
+path_17_2(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_19_0(P,V,P)
+path_19_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_18_1(P,V,H,MS,H,MS)
+path_18_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: pathArg_22_4(M,V,Z,P,MS)
+pathArg_22_4(_m,_v,_z,_q,_ms2) -> M(_m), V(_v), Z(_z), P(_q), MS(_ms2).
+// :outputs: pathArg_23_0(M,V,V,Z,P)
+pathArg_23_0(_m,_v,_u,_z,_q) -> M(_m), V(_v), V(_u), Z(_z), P(_q).
+// :outputs: pathArg_22_2(M,V,V,Z,P,MS)
+pathArg_22_2(_m,_v,_u,_z,_q,_ms2) -> M(_m), V(_v), V(_u), Z(_z), P(_q), MS(_ms2).
+// :outputs: pathArg_22_3(M,V,Z,P,MS)
+pathArg_22_3(_m,_v,_z,_q,_ms2) -> M(_m), V(_v), Z(_z), P(_q), MS(_ms2).
+// :outputs: pathArg_22_0(M,V,V,Z,P)
+pathArg_22_0(_m,_v,_u,_z,_q) -> M(_m), V(_v), V(_u), Z(_z), P(_q).
+// :outputs: pathArg_22_1(M,V,V,Z,P)
+pathArg_22_1(_m,_v,_u,_z,_q) -> M(_m), V(_v), V(_u), Z(_z), P(_q).
+// :outputs: pathArgInit_21_0(P)
+pathArgInit_21_0(_p) -> P(_p).
+// :outputs: pathArgInit_21_1(P)
+pathArgInit_21_1(_q) -> P(_q).
+// :outputs: pathArg_25_0(M,V,V,Z,P)
+pathArg_25_0(_m,_v,_u,_z2,_q) -> M(_m), V(_v), V(_u), Z(_z2), P(_q).
+// :outputs: pathArg_25_1(M,V,V,Z,P,Z)
+pathArg_25_1(_m,_v,_u,_z2,_q,_z1) -> M(_m), V(_v), V(_u), Z(_z2), P(_q), Z(_z1).
+// :outputs: pathArg_24_1(M,V,Z,P)
+pathArg_24_1(_m,_u,_z,_q) -> M(_m), V(_u), Z(_z), P(_q).
+// :outputs: pathArg_24_2(M,V,Z,P,MS)
+pathArg_24_2(_m,_u,_z,_q,_ms2) -> M(_m), V(_u), Z(_z), P(_q), MS(_ms2).
+// :outputs: pathArg_23_3(M,V,Z,P,MS)
+pathArg_23_3(_m,_v,_z,_q,_ms2) -> M(_m), V(_v), Z(_z), P(_q), MS(_ms2).
+// :outputs: pathArg_24_0(M,V,Z,P)
+pathArg_24_0(_m,_u,_z,_q) -> M(_m), V(_u), Z(_z), P(_q).
+// :outputs: pathArg_23_1(M,V,V,Z,P)
+pathArg_23_1(_m,_v,_u,_z,_q) -> M(_m), V(_v), V(_u), Z(_z), P(_q).
+// :outputs: pathArg_23_2(M,V,V,Z,P,MS)
+pathArg_23_2(_m,_v,_u,_z,_q,_ms2) -> M(_m), V(_v), V(_u), Z(_z), P(_q), MS(_ms2).
+// :outputs: pathArg_27_0(M,V,Z,P)
+pathArg_27_0(_m,_u,_z2,_q) -> M(_m), V(_u), Z(_z2), P(_q).
+// :outputs: pathArg_26_3(M,V,Z,P,MS,MS)
+pathArg_26_3(_m,_v,_z2,_q,_ms2,_ms3) -> M(_m), V(_v), Z(_z2), P(_q), MS(_ms2), MS(_ms3).
+// :outputs: pathArg_26_2(M,V,V,Z,P,MS,MS)
+pathArg_26_2(_m,_v,_u,_z2,_q,_ms2,_ms3) -> M(_m), V(_v), V(_u), Z(_z2), P(_q), MS(_ms2), MS(_ms3).
+// :outputs: pathArg_26_1(M,V,V,Z,P,Z)
+pathArg_26_1(_m,_v,_u,_z2,_q,_z1) -> M(_m), V(_v), V(_u), Z(_z2), P(_q), Z(_z1).
+// :outputs: pathArg_26_0(M,V,V,Z,P)
+pathArg_26_0(_m,_v,_u,_z2,_q) -> M(_m), V(_v), V(_u), Z(_z2), P(_q).
+// :outputs: pathArg_25_4(M,V,Z,P,MS,MS)
+pathArg_25_4(_m,_v,_z2,_q,_ms2,_ms3) -> M(_m), V(_v), Z(_z2), P(_q), MS(_ms2), MS(_ms3).
+// :outputs: pathArg_25_3(M,V,Z,P,MS,MS)
+pathArg_25_3(_m,_v,_z2,_q,_ms2,_ms3) -> M(_m), V(_v), Z(_z2), P(_q), MS(_ms2), MS(_ms3).
+// :outputs: pathArg_25_2(M,V,V,Z,P,MS,MS)
+pathArg_25_2(_m,_v,_u,_z2,_q,_ms2,_ms3) -> M(_m), V(_v), V(_u), Z(_z2), P(_q), MS(_ms2), MS(_ms3).
+// :outputs: pathArgInit_30_2(P,K)
+pathArgInit_30_2(_q,_k) -> P(_q), K(_k).
+// :outputs: pathArgInit_30_1(M,P)
+pathArgInit_30_1(_m,_q) -> M(_m), P(_q).
+// :outputs: pathArgInit_30_0(P,M)
+pathArgInit_30_0(_p,_m) -> P(_p), M(_m).
+// :outputs: path_29_2(MS,H,P,MS)
+path_29_2(_ms2,_h1,_p,_ms3) -> MS(_ms2), H(_h1), P(_p), MS(_ms3).
+// :outputs: path_29_1(MS,H,P)
+path_29_1(_ms2,_h1,_p) -> MS(_ms2), H(_h1), P(_p).
+// :outputs: path_29_0(M,MS,H)
+path_29_0(_m,_ms2,_h1) -> M(_m), MS(_ms2), H(_h1).
+// :outputs: pathArg_27_2(M,V,Z,P,MS,MS)
+pathArg_27_2(_m,_u,_z2,_q,_ms2,_ms3) -> M(_m), V(_u), Z(_z2), P(_q), MS(_ms2), MS(_ms3).
+// :outputs: pathArg_27_1(M,V,Z,P,Z)
+pathArg_27_1(_m,_u,_z2,_q,_z1) -> M(_m), V(_u), Z(_z2), P(_q), Z(_z1).
+// :outputs: path_33_3(P,V,H,MS,MS,H)
+path_33_3(_p,_v,_h1,_ms1,_ms2,_h3) -> P(_p), V(_v), H(_h1), MS(_ms1), MS(_ms2), H(_h3).
+// :outputs: path_33_2(P,M,V,H,MS,H,MS,MS)
+path_33_2(_p,_m,_v,_h1,_ms1,_h2,_ms2,_ms3) -> P(_p), M(_m), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2), MS(_ms3).
+// :outputs: path_34_0(P,M,V,P)
+path_34_0(_p,_m,_v,_q) -> P(_p), M(_m), V(_v), P(_q).
+// :outputs: path_33_4(P,V,H,MS,MS,H)
+path_33_4(_p,_v,_h1,_ms1,_ms2,_h3) -> P(_p), V(_v), H(_h1), MS(_ms1), MS(_ms2), H(_h3).
+// :outputs: path_34_2(P,M,V,H,MS,H,MS,MS)
+path_34_2(_p,_m,_v,_h1,_ms1,_h2,_ms2,_ms3) -> P(_p), M(_m), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2), MS(_ms3).
+// :outputs: path_34_1(P,M,V,P,H,MS,H,MS)
+path_34_1(_p,_m,_v,_q,_h1,_ms1,_h2,_ms2) -> P(_p), M(_m), V(_v), P(_q), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_35_0(P,M,V,P)
+path_35_0(_p,_m,_v,_q) -> P(_p), M(_m), V(_v), P(_q).
+// :outputs: path_34_3(P,V,H,MS,MS,H)
+path_34_3(_p,_v,_h1,_ms1,_ms2,_h3) -> P(_p), V(_v), H(_h1), MS(_ms1), MS(_ms2), H(_h3).
+// :outputs: pathArgLast_31_0(P,M)
+pathArgLast_31_0(_p,_m) -> P(_p), M(_m).
+// :outputs: pathArgInit_30_3(P)
+pathArgInit_30_3(_q) -> P(_q).
+// :outputs: pathArgLast_31_2(M,P,K)
+pathArgLast_31_2(_m,_q,_k) -> M(_m), P(_q), K(_k).
+// :outputs: pathArgLast_31_1(M,P)
+pathArgLast_31_1(_m,_q) -> M(_m), P(_q).
+// :outputs: path_32_0(P,P)
+path_32_0(_p,_q) -> P(_p), P(_q).
+// :outputs: pathArgLast_31_3(M,P)
+pathArgLast_31_3(_m,_q) -> M(_m), P(_q).
+// :outputs: path_33_1(P,M,V,P,H,MS,H,MS)
+path_33_1(_p,_m,_v,_q,_h1,_ms1,_h2,_ms2) -> P(_p), M(_m), V(_v), P(_q), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_33_0(P,M,V,P)
+path_33_0(_p,_m,_v,_q) -> P(_p), M(_m), V(_v), P(_q).
+// :outputs: path_37_0(P,M)
+path_37_0(_p,_m) -> P(_p), M(_m).
+// :outputs: path_37_1(P,M)
+path_37_1(_p,_m) -> P(_p), M(_m).
+// :outputs: path_37_2(P,M,P)
+path_37_2(_p,_m,_q) -> P(_p), M(_m), P(_q).
+// :outputs: path_37_3(P,M,P,H,MS,H,MS)
+path_37_3(_p,_m,_q,_h1,_ms1,_h2,_ms2) -> P(_p), M(_m), P(_q), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_37_4(P,M,H,MS,H,MS,MS)
+path_37_4(_p,_m,_h1,_ms1,_h2,_ms2,_ms3) -> P(_p), M(_m), H(_h1), MS(_ms1), H(_h2), MS(_ms2), MS(_ms3).
+// :outputs: path_38_0(P,V,P)
+path_38_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_38_1(P,V,H,MS,H,MS)
+path_38_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_39_0(P,V,P)
+path_39_0(_p,_v,_q) -> P(_p), V(_v), P(_q).
+// :outputs: path_35_1(P,M,V,P,H,MS,H,MS)
+path_35_1(_p,_m,_v,_q,_h1,_ms1,_h2,_ms2) -> P(_p), M(_m), V(_v), P(_q), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_35_2(P,M,V,H,MS,H,MS,MS)
+path_35_2(_p,_m,_v,_h1,_ms1,_h2,_ms2,_ms3) -> P(_p), M(_m), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2), MS(_ms3).
+// :outputs: path_35_3(P,V,H,MS,MS,H)
+path_35_3(_p,_v,_h1,_ms1,_ms2,_h3) -> P(_p), V(_v), H(_h1), MS(_ms1), MS(_ms2), H(_h3).
+// :outputs: path_35_4(P,V,H,MS,MS,H)
+path_35_4(_p,_v,_h1,_ms1,_ms2,_h3) -> P(_p), V(_v), H(_h1), MS(_ms1), MS(_ms2), H(_h3).
+// :outputs: path_36_0(P,M,V,P)
+path_36_0(_p,_m,_v,_q) -> P(_p), M(_m), V(_v), P(_q).
+// :outputs: path_36_1(P,M,V,P,H,MS,H,MS)
+path_36_1(_p,_m,_v,_q,_h1,_ms1,_h2,_ms2) -> P(_p), M(_m), V(_v), P(_q), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: path_36_2(P,M,V,H,MS,H,MS,MS)
+path_36_2(_p,_m,_v,_h1,_ms1,_h2,_ms2,_ms3) -> P(_p), M(_m), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2), MS(_ms3).
+// :outputs: path_36_3(P,V,H,MS,MS,H)
+path_36_3(_p,_v,_h1,_ms1,_ms2,_h3) -> P(_p), V(_v), H(_h1), MS(_ms1), MS(_ms2), H(_h3).
+// :outputs: unprovenQuery_51_1(P,I,P)
+unprovenQuery_51_1(_q,_i,_p) -> P(_q), I(_i), P(_p).
+// :outputs: unprovenQuery_51_0(P,I)
+unprovenQuery_51_0(_q,_i) -> P(_q), I(_i).
+// :outputs: path_50_0(P,P)
+path_50_0(_p,_q) -> P(_p), P(_q).
+// :outputs: path_39_1(P,V,H,MS,H,MS)
+path_39_1(_p,_v,_h1,_ms1,_h2,_ms2) -> P(_p), V(_v), H(_h1), MS(_ms1), H(_h2), MS(_ms2).
+// :outputs: unprovenQuery_51_5(P,I,H)
+unprovenQuery_51_5(_q,_i,_h) -> P(_q), I(_i), H(_h).
+// :outputs: unprovenQuery_51_4(P,I,H,MS,V)
+unprovenQuery_51_4(_q,_i,_h,_ms,_v) -> P(_q), I(_i), H(_h), MS(_ms), V(_v).
+// :outputs: unprovenQuery_51_3(P,I,H,MS,V)
+unprovenQuery_51_3(_q,_i,_h,_ms,_v) -> P(_q), I(_i), H(_h), MS(_ms), V(_v).
+// :outputs: unprovenQuery_51_2(P,I,H,MS)
+unprovenQuery_51_2(_q,_i,_h,_ms) -> P(_q), I(_i), H(_h), MS(_ms).
+
+// #Instrumented relations
+// :outputs: unprovenQuery_51_4_XZ89_90(P,I,H,MS,V)
+unprovenQuery_51_4_XZ89_90(q,i,h,ms,v) -> P(q), I(i), H(h), MS(ms), V(v).
+// :outputs: unprovenQuery_51_5_XZ89_91(P,I,H,MS,V)
+unprovenQuery_51_5_XZ89_91(q,i,h,ms,v) -> P(q), I(i), H(h), MS(ms), V(v).
+// :outputs: unprovenQuery_51_2_XZ89_88(P,I,H,MS,P,H,MS,K)
+unprovenQuery_51_2_XZ89_88(q,i,h,ms,p,v_XZ89_0,v_XZ89_1,v_XZ89_2) -> P(q), I(i), H(h), MS(ms), P(p), H(v_XZ89_0), MS(v_XZ89_1), K(v_XZ89_2).
+// :outputs: unprovenQuery_51_3_XZ89_89(P,I,H,MS,V)
+unprovenQuery_51_3_XZ89_89(q,i,h,ms,v) -> P(q), I(i), H(h), MS(ms), V(v).
+// :outputs: path_XZ89_94(P,H)
+path_XZ89_94(p,h) -> P(p), H(h).
+// :outputs: path_XZ89_95(P,H,MS,H,MS,V,MS)
+path_XZ89_95(p,h1,ms1,h2,ms3,v,ms2) -> P(p), H(h1), MS(ms1), H(h2), MS(ms3), V(v), MS(ms2).
+// :outputs: path_XZ89_92(P,M)
+path_XZ89_92(p,m) -> P(p), M(m).
+// :outputs: path_XZ89_93(P,H,MS)
+path_XZ89_93(p,h,ms) -> P(p), H(h), MS(ms).
+// :outputs: path_XZ89_98(P,H,MS,H,MS,V)
+path_XZ89_98(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: pathArg_XZ89_99(P,Z,M,MS,MS,V)
+pathArg_XZ89_99(q,z,m,ms2,ms3,v) -> P(q), Z(z), M(m), MS(ms2), MS(ms3), V(v).
+// :outputs: path_XZ89_96(P,H,MS,H,MS,V)
+path_XZ89_96(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: path_XZ89_97(P,H,MS,H,MS,V,MS)
+path_XZ89_97(p,h1,ms1,h2,ms3,v,ms2) -> P(p), H(h1), MS(ms1), H(h2), MS(ms3), V(v), MS(ms2).
+// :outputs: unprovenQuery_XZ89_100(P,H,I)
+unprovenQuery_XZ89_100(q,h,i) -> P(q), H(h), I(i).
+// :outputs: path_XZ89_3(P,H,MS,H,MS,V)
+path_XZ89_3(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: path_XZ89_2(P,H,MS,H,MS,V,MS)
+path_XZ89_2(p,h1,ms1,h2,ms3,v,ms2) -> P(p), H(h1), MS(ms1), H(h2), MS(ms3), V(v), MS(ms2).
+// :outputs: path_XZ89_1(P,H,MS,H,MS,V,MS)
+path_XZ89_1(p,h1,ms1,h2,ms3,v,ms2) -> P(p), H(h1), MS(ms1), H(h2), MS(ms3), V(v), MS(ms2).
+// :outputs: path_XZ89_0(P,H,MS,H,MS,V)
+path_XZ89_0(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: path_XZ89_7(P,H,MS,H,MS,V)
+path_XZ89_7(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: path_XZ89_6(P,H,MS,H,MS,V,MS)
+path_XZ89_6(p,h1,ms1,h2,ms3,v,ms2) -> P(p), H(h1), MS(ms1), H(h2), MS(ms3), V(v), MS(ms2).
+// :outputs: path_XZ89_5(P,H,MS,H,MS,V)
+path_XZ89_5(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: path_XZ89_4(P,H,MS,H,MS,V,MS)
+path_XZ89_4(p,h1,ms1,h2,ms3,v,ms2) -> P(p), H(h1), MS(ms1), H(h2), MS(ms3), V(v), MS(ms2).
+// :outputs: path_XZ89_18(P,H,MS,H,MS,P)
+path_XZ89_18(p,h1,ms2,h2,ms3,q) -> P(p), H(h1), MS(ms2), H(h2), MS(ms3), P(q).
+// :outputs: path_XZ89_19(P,H,MS,H,MS,V,MS)
+path_XZ89_19(p,h1,ms1,h3,ms5,v,ms2) -> P(p), H(h1), MS(ms1), H(h3), MS(ms5), V(v), MS(ms2).
+// :outputs: pathArgInit_XZ89_16(P,MS,H,H,MS,K)
+pathArgInit_XZ89_16(q,ms1,h1,v_XZ89_0,v_XZ89_1,v_XZ89_2) -> P(q), MS(ms1), H(h1), H(v_XZ89_0), MS(v_XZ89_1), K(v_XZ89_2).
+// :outputs: pathArgLast_XZ89_17(P,M,MS,H,MS,H,K)
+pathArgLast_XZ89_17(q,m,ms1,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) -> P(q), M(m), MS(ms1), H(v_XZ89_0), MS(v_XZ89_1), H(v_XZ89_2), K(v_XZ89_3).
+// :outputs: path_XZ89_22(P,H,MS,H,MS,V)
+path_XZ89_22(p,h1,ms1,h3,ms2,v) -> P(p), H(h1), MS(ms1), H(h3), MS(ms2), V(v).
+// :outputs: path_XZ89_23(P,H,MS,H,MS,M,H,MS,K)
+path_XZ89_23(p,h1,ms1,h3,ms2,m,h2,ms3,v_XZ89_0) -> P(p), H(h1), MS(ms1), H(h3), MS(ms2), M(m), H(h2), MS(ms3), K(v_XZ89_0).
+// :outputs: path_XZ89_20(P,H,MS,H,MS,V)
+path_XZ89_20(p,h1,ms1,h3,ms2,v) -> P(p), H(h1), MS(ms1), H(h3), MS(ms2), V(v).
+// :outputs: path_XZ89_21(P,H,MS,H,MS,V,MS)
+path_XZ89_21(p,h1,ms1,h3,ms5,v,ms2) -> P(p), H(h1), MS(ms1), H(h3), MS(ms5), V(v), MS(ms2).
+// :outputs: pathArg_XZ89_10(P,Z,M,MS,V)
+pathArg_XZ89_10(q,z,m,ms2,u) -> P(q), Z(z), M(m), MS(ms2), V(u).
+// :outputs: pathArg_XZ89_11(P,Z,M,MS,MS,V,MS)
+pathArg_XZ89_11(q,z2,m,ms2,ms4,v,ms3) -> P(q), Z(z2), M(m), MS(ms2), MS(ms4), V(v), MS(ms3).
+// :outputs: pathArgInit_XZ89_8(P,MS,H,H,MS,K)
+pathArgInit_XZ89_8(q,ms1,h1,v_XZ89_0,v_XZ89_1,v_XZ89_2) -> P(q), MS(ms1), H(h1), H(v_XZ89_0), MS(v_XZ89_1), K(v_XZ89_2).
+// :outputs: pathArg_XZ89_9(P,Z,M,MS,V)
+pathArg_XZ89_9(q,z,m,ms2,v) -> P(q), Z(z), M(m), MS(ms2), V(v).
+// :outputs: pathArgLast_XZ89_14(P,M,MS,MS,Z)
+pathArgLast_XZ89_14(q,m,ms1,ms2,z) -> P(q), M(m), MS(ms1), MS(ms2), Z(z).
+// :outputs: path_XZ89_15(P,H,MS,H,MS)
+path_XZ89_15(p,h1,ms2,h2,ms3) -> P(p), H(h1), MS(ms2), H(h2), MS(ms3).
+// :outputs: pathArg_XZ89_12(P,Z,M,MS,MS,V)
+pathArg_XZ89_12(q,z2,m,ms2,ms3,v) -> P(q), Z(z2), M(m), MS(ms2), MS(ms3), V(v).
+// :outputs: pathArg_XZ89_13(P,Z,M,MS,MS,V)
+pathArg_XZ89_13(q,z2,m,ms2,ms3,u) -> P(q), Z(z2), M(m), MS(ms2), MS(ms3), V(u).
+// :outputs: path_11_2_XZ89_37(P,V,H,MS,H,MS,V)
+path_11_2_XZ89_37(p,v,h1,ms1,h2,ms2,u) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), V(u).
+// :outputs: path_11_1_XZ89_36(P,V,V,H,MS,H,MS,P)
+path_11_1_XZ89_36(p,v,u,h1,ms1,h2,ms2,q) -> P(p), V(v), V(u), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_12_1_XZ89_39(P,V,V,H,MS,H,MS,P)
+path_12_1_XZ89_39(p,v,u,h1,ms1,h2,ms2,q) -> P(p), V(v), V(u), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_11_3_XZ89_38(P,V,H,MS,H,MS)
+path_11_3_XZ89_38(p,v,h1,ms1,h2,ms2) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_9_1_XZ89_33(P,V,H,MS,H,MS,P)
+path_9_1_XZ89_33(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_8_2_XZ89_32(P,H,V)
+path_8_2_XZ89_32(p,h,v) -> P(p), H(h), V(v).
+// :outputs: path_10_1_XZ89_35(P,V,H,MS,H,MS,P)
+path_10_1_XZ89_35(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_9_2_XZ89_34(P,V,H,MS,H,MS)
+path_9_2_XZ89_34(p,v,h1,ms1,h2,ms2) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_7_2_XZ89_29(P,V,H)
+path_7_2_XZ89_29(p,v,h) -> P(p), V(v), H(h).
+// :outputs: path_7_1_XZ89_28(P,V,H,P)
+path_7_1_XZ89_28(p,v,h,q) -> P(p), V(v), H(h), P(q).
+// :outputs: path_8_1_XZ89_31(P,V,H,P)
+path_8_1_XZ89_31(p,v,h,q) -> P(p), V(v), H(h), P(q).
+// :outputs: path_7_3_XZ89_30(P,H,MS,V)
+path_7_3_XZ89_30(p,h,ms,v) -> P(p), H(h), MS(ms), V(v).
+// :outputs: path_XZ89_25(P,H,MS,H,MS,V)
+path_XZ89_25(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: path_XZ89_24(P,H,MS,H,MS,V)
+path_XZ89_24(p,h1,ms1,h2,ms2,v) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), V(v).
+// :outputs: path_XZ89_27(P,H,MS,H,MS,K,P)
+path_XZ89_27(p,h1,ms1,h2,ms2,k,q) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), K(k), P(q).
+// :outputs: summary_XZ89_26(M,H,MS,H,K,P,MS)
+summary_XZ89_26(m,h1,ms1,h2,k,p,v_XZ89_0) -> M(m), H(h1), MS(ms1), H(h2), K(k), P(p), MS(v_XZ89_0).
+// :outputs: path_19_1_XZ89_52(P,V,H,MS,H,MS,P)
+path_19_1_XZ89_52(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_19_2_XZ89_53(P,V,H,MS,H,MS)
+path_19_2_XZ89_53(p,v,h1,ms1,h2,ms2) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_20_1_XZ89_54(P,V,H,MS,H,MS,P)
+path_20_1_XZ89_54(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: pathArg_22_2_XZ89_55(M,V,V,Z,P,MS,H,MS,H,K)
+pathArg_22_2_XZ89_55(m,v,u,z,q,ms2,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) -> M(m), V(v), V(u), Z(z), P(q), MS(ms2), H(v_XZ89_0), MS(v_XZ89_1), H(v_XZ89_2), K(v_XZ89_3).
+// :outputs: path_16_1_XZ89_48(P,V,H,MS,H,MS,P)
+path_16_1_XZ89_48(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_17_1_XZ89_49(P,V,H,MS,H,MS,P)
+path_17_1_XZ89_49(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_17_2_XZ89_50(P,V,H,MS,H,MS)
+path_17_2_XZ89_50(p,v,h1,ms1,h2,ms2) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_18_1_XZ89_51(P,V,H,MS,H,MS,P)
+path_18_1_XZ89_51(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_14_2_XZ89_44(P,V,H,MS,H,MS,V)
+path_14_2_XZ89_44(p,v,h1,ms1,h2,ms2,u) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), V(u).
+// :outputs: path_14_3_XZ89_45(P,V,H,MS,H,MS)
+path_14_3_XZ89_45(p,v,h1,ms1,h2,ms2) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_15_1_XZ89_46(P,V,H,MS,H,MS,P)
+path_15_1_XZ89_46(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_15_2_XZ89_47(P,V,H,MS,H,MS)
+path_15_2_XZ89_47(p,v,h1,ms1,h2,ms2) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_12_2_XZ89_40(P,V,H,MS,H,MS,V)
+path_12_2_XZ89_40(p,v,h1,ms1,h2,ms2,u) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), V(u).
+// :outputs: path_13_1_XZ89_41(P,V,V,H,MS,H,MS,P)
+path_13_1_XZ89_41(p,v,u,h1,ms1,h2,ms2,q) -> P(p), V(v), V(u), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_13_2_XZ89_42(P,V,H,MS,H,MS,V)
+path_13_2_XZ89_42(p,v,h1,ms1,h2,ms2,u) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), V(u).
+// :outputs: path_14_1_XZ89_43(P,V,V,H,MS,H,MS,P)
+path_14_1_XZ89_43(p,v,u,h1,ms1,h2,ms2,q) -> P(p), V(v), V(u), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_33_2_XZ89_71(P,M,V,H,MS,H,MS,MS,P)
+path_33_2_XZ89_71(p,m,v,h1,ms1,h2,ms2,ms3,q) -> P(p), M(m), V(v), H(h1), MS(ms1), H(h2), MS(ms2), MS(ms3), P(q).
+// :outputs: path_33_1_XZ89_70(P,M,V,P,H,MS,H,MS)
+path_33_1_XZ89_70(p,m,v,q,h1,ms1,h2,ms2) -> P(p), M(m), V(v), P(q), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_29_2_XZ89_69(MS,H,P,MS)
+path_29_2_XZ89_69(ms2,h1,p,ms3) -> MS(ms2), H(h1), P(p), MS(ms3).
+// :outputs: path_29_1_XZ89_68(MS,H,P,M)
+path_29_1_XZ89_68(ms2,h1,p,m) -> MS(ms2), H(h1), P(p), M(m).
+// :outputs: path_29_0_XZ89_67(M,MS,H,P,MS)
+path_29_0_XZ89_67(m,ms2,h1,q,ms1) -> M(m), MS(ms2), H(h1), P(q), MS(ms1).
+// :outputs: pathArg_27_2_XZ89_66(M,V,Z,P,MS,MS,Z)
+pathArg_27_2_XZ89_66(m,u,z2,q,ms2,ms3,z1) -> M(m), V(u), Z(z2), P(q), MS(ms2), MS(ms3), Z(z1).
+// :outputs: pathArg_26_3_XZ89_65(M,V,Z,P,MS,MS,V)
+pathArg_26_3_XZ89_65(m,v,z2,q,ms2,ms3,u) -> M(m), V(v), Z(z2), P(q), MS(ms2), MS(ms3), V(u).
+// :outputs: pathArg_26_2_XZ89_64(M,V,V,Z,P,MS,MS,Z)
+pathArg_26_2_XZ89_64(m,v,u,z2,q,ms2,ms3,z1) -> M(m), V(v), V(u), Z(z2), P(q), MS(ms2), MS(ms3), Z(z1).
+// :outputs: pathArg_25_4_XZ89_63(M,V,Z,P,MS,MS)
+pathArg_25_4_XZ89_63(m,v,z2,q,ms2,ms3) -> M(m), V(v), Z(z2), P(q), MS(ms2), MS(ms3).
+// :outputs: pathArg_25_3_XZ89_62(M,V,Z,P,MS,MS,V)
+pathArg_25_3_XZ89_62(m,v,z2,q,ms2,ms3,u) -> M(m), V(v), Z(z2), P(q), MS(ms2), MS(ms3), V(u).
+// :outputs: pathArg_25_2_XZ89_61(M,V,V,Z,P,MS,MS,Z)
+pathArg_25_2_XZ89_61(m,v,u,z2,q,ms2,ms3,z1) -> M(m), V(v), V(u), Z(z2), P(q), MS(ms2), MS(ms3), Z(z1).
+// :outputs: pathArg_24_2_XZ89_60(M,V,Z,P,MS,H,MS,H,K)
+pathArg_24_2_XZ89_60(m,u,z,q,ms2,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) -> M(m), V(u), Z(z), P(q), MS(ms2), H(v_XZ89_0), MS(v_XZ89_1), H(v_XZ89_2), K(v_XZ89_3).
+// :outputs: pathArg_23_3_XZ89_59(M,V,Z,P,MS,V)
+pathArg_23_3_XZ89_59(m,v,z,q,ms2,u) -> M(m), V(v), Z(z), P(q), MS(ms2), V(u).
+// :outputs: pathArg_23_2_XZ89_58(M,V,V,Z,P,MS,H,MS,H,K)
+pathArg_23_2_XZ89_58(m,v,u,z,q,ms2,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) -> M(m), V(v), V(u), Z(z), P(q), MS(ms2), H(v_XZ89_0), MS(v_XZ89_1), H(v_XZ89_2), K(v_XZ89_3).
+// :outputs: pathArg_22_4_XZ89_57(M,V,Z,P,MS)
+pathArg_22_4_XZ89_57(m,v,z,q,ms2) -> M(m), V(v), Z(z), P(q), MS(ms2).
+// :outputs: pathArg_22_3_XZ89_56(M,V,Z,P,MS,V)
+pathArg_22_3_XZ89_56(m,v,z,q,ms2,u) -> M(m), V(v), Z(z), P(q), MS(ms2), V(u).
+// :outputs: path_38_1_XZ89_86(P,V,H,MS,H,MS,P)
+path_38_1_XZ89_86(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_39_1_XZ89_87(P,V,H,MS,H,MS,P)
+path_39_1_XZ89_87(p,v,h1,ms1,h2,ms2,q) -> P(p), V(v), H(h1), MS(ms1), H(h2), MS(ms2), P(q).
+// :outputs: path_37_3_XZ89_84(P,M,P,H,MS,H,MS)
+path_37_3_XZ89_84(p,m,q,h1,ms1,h2,ms2) -> P(p), M(m), P(q), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_37_4_XZ89_85(P,M,H,MS,H,MS,MS,P)
+path_37_4_XZ89_85(p,m,h1,ms1,h2,ms2,ms3,q) -> P(p), M(m), H(h1), MS(ms1), H(h2), MS(ms2), MS(ms3), P(q).
+// :outputs: path_36_2_XZ89_82(P,M,V,H,MS,H,MS,MS,P)
+path_36_2_XZ89_82(p,m,v,h1,ms1,h2,ms2,ms3,q) -> P(p), M(m), V(v), H(h1), MS(ms1), H(h2), MS(ms2), MS(ms3), P(q).
+// :outputs: path_36_3_XZ89_83(P,V,H,MS,MS,H,M,H,MS)
+path_36_3_XZ89_83(p,v,h1,ms1,ms2,h3,m,h2,ms3) -> P(p), V(v), H(h1), MS(ms1), MS(ms2), H(h3), M(m), H(h2), MS(ms3).
+// :outputs: path_35_4_XZ89_80(P,V,H,MS,MS,H)
+path_35_4_XZ89_80(p,v,h1,ms1,ms2,h3) -> P(p), V(v), H(h1), MS(ms1), MS(ms2), H(h3).
+// :outputs: path_36_1_XZ89_81(P,M,V,P,H,MS,H,MS)
+path_36_1_XZ89_81(p,m,v,q,h1,ms1,h2,ms2) -> P(p), M(m), V(v), P(q), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_35_2_XZ89_78(P,M,V,H,MS,H,MS,MS,P)
+path_35_2_XZ89_78(p,m,v,h1,ms1,h2,ms2,ms3,q) -> P(p), M(m), V(v), H(h1), MS(ms1), H(h2), MS(ms2), MS(ms3), P(q).
+// :outputs: path_35_3_XZ89_79(P,V,H,MS,MS,H,M,H,MS)
+path_35_3_XZ89_79(p,v,h1,ms1,ms2,h3,m,h2,ms3) -> P(p), V(v), H(h1), MS(ms1), MS(ms2), H(h3), M(m), H(h2), MS(ms3).
+// :outputs: path_34_3_XZ89_76(P,V,H,MS,MS,H,M,H,MS)
+path_34_3_XZ89_76(p,v,h1,ms1,ms2,h3,m,h2,ms3) -> P(p), V(v), H(h1), MS(ms1), MS(ms2), H(h3), M(m), H(h2), MS(ms3).
+// :outputs: path_35_1_XZ89_77(P,M,V,P,H,MS,H,MS)
+path_35_1_XZ89_77(p,m,v,q,h1,ms1,h2,ms2) -> P(p), M(m), V(v), P(q), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_34_1_XZ89_74(P,M,V,P,H,MS,H,MS)
+path_34_1_XZ89_74(p,m,v,q,h1,ms1,h2,ms2) -> P(p), M(m), V(v), P(q), H(h1), MS(ms1), H(h2), MS(ms2).
+// :outputs: path_34_2_XZ89_75(P,M,V,H,MS,H,MS,MS,P)
+path_34_2_XZ89_75(p,m,v,h1,ms1,h2,ms2,ms3,q) -> P(p), M(m), V(v), H(h1), MS(ms1), H(h2), MS(ms2), MS(ms3), P(q).
+// :outputs: path_33_3_XZ89_72(P,V,H,MS,MS,H,M,H,MS)
+path_33_3_XZ89_72(p,v,h1,ms1,ms2,h3,m,h2,ms3) -> P(p), V(v), H(h1), MS(ms1), MS(ms2), H(h3), M(m), H(h2), MS(ms3).
+// :outputs: path_33_4_XZ89_73(P,V,H,MS,MS,H)
+path_33_4_XZ89_73(p,v,h1,ms1,ms2,h3) -> P(p), V(v), H(h1), MS(ms1), MS(ms2), H(h3).
+
+// #Original rules
+PInvkInst(p,m,v,u,z) <- PI(p,i), IM(i,m), IinvkArg(i,z,u), MmethArg(m,z,v).
+PInvkRetInst(p,m,v,u) <- PI(p,i), IM(i,m), IinvkRet(i,z,v), MmethRet(m,z,u).
+PInvkRetInstFilter(p,m) <- PInvkRetInst(p,m,_,_).
+PInvkRetInstNotFilter(p,m) <- !PInvkRetInstFilter(p,m).
+IMFilter(i) <- IM(i,_).
+PInvkSkip(p) <- PI(p,i), !IMFilter(i).
+//path(p,0,0,0,0,0) <- reachableM(m), MPhead(m,p).
+path(p,h0,ms0,h0,ms0,k0) <- reachableM(m), MPhead(m,p), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+//path(p,0,0,h,ms,0) <- path_7_3(p,h,ms), trackedH(h).
+path(p,h0,ms0,h,ms,k0) <- path_7_3(p,h,ms), trackedH(h), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+//path(p,0,0,h,0,0) <- path_8_2(p,h), trackedH(h).
+path(p,h0,ms0,h,ms0,k0) <- path_8_2(p,h), trackedH(h), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms3,0) <- path_9_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- path_9_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- path_10_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- path_10_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms3,0) <- path_11_3(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- path_11_3(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- path_12_2(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- path_12_2(p,v,h1,ms1,h2,ms2), !contain(v,ms2), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- path_13_2(p,v,h1,ms1,h2,ms2), deny(v).
+path(p,h1,ms1,h2,ms2,k0) <- path_13_2(p,v,h1,ms1,h2,ms2), deny(v), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms3,0) <- path_14_3(p,v,h1,ms1,h2,ms2), gen(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- path_14_3(p,v,h1,ms1,h2,ms2), gen(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms3,0) <- path_15_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- path_15_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- path_16_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- path_16_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms3,0) <- path_17_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- path_17_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- path_18_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- path_18_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms3,0) <- path_19_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- path_19_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- path_20_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- path_20_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2), K_index[k0] = 0.
+pathArgInit(q,ms1,h1) <- pathArgInit_21_1(q), path(q,_,_,h1,ms1,_).
+//pathArg(q,z,m,ms2,ms3) <- pathArg_22_4(m,v,z,q,ms2), gen(0,v,ms3).
+pathArg(q,z,m,ms2,ms3) <- pathArg_22_4(m,v,z,q,ms2), gen(ms0,v,ms3), MS_index[ms0] = 0.
+//pathArg(q,z,m,ms2,0) <- pathArg_23_3(m,v,z,q,ms2), deny(v).
+pathArg(q,z,m,ms2,ms0) <- pathArg_23_3(m,v,z,q,ms2), deny(v), MS_index[ms0] = 0.
+//pathArg(q,z,m,ms2,0) <- pathArg_24_2(m,u,z,q,ms2), !contain(u,ms2).
+pathArg(q,z,m,ms2,ms0) <- pathArg_24_2(m,u,z,q,ms2), !contain(u,ms2), MS_index[ms0] = 0.
+pathArg(q,z2,m,ms2,ms4) <- pathArg_25_4(m,v,z2,q,ms2,ms3), gen(ms3,v,ms4).
+pathArg(q,z2,m,ms2,ms3) <- pathArg_26_3(m,v,z2,q,ms2,ms3), deny(v).
+pathArg(q,z2,m,ms2,ms3) <- pathArg_27_2(m,u,z2,q,ms2,ms3), !contain(u,ms2).
+pathArgLast(q,m,ms1,ms2) <- pathArg(q,z,m,ms1,ms2), MZlast(m,z).
+//path(p,h1,ms2,h2,ms3,0) <- path_29_2(ms2,h1,p,ms3), h1=h2.
+path(p,h1,ms2,h2,ms3,k0) <- path_29_2(ms2,h1,p,ms3), h1=h2, K_index[k0] = 0.
+pathArgInit(q,ms1,h1) <- pathArgInit_30_3(q), path(q,_,_,h1,ms1,_).
+//pathArgLast(q,m,ms1,0) <- pathArgLast_31_3(m,q), path(q,_,_,_,ms1,_).
+pathArgLast(q,m,ms1,ms0) <- pathArgLast_31_3(m,q), path(q,_,_,_,ms1,_), MS_index[ms0] = 0.
+//path(p,h1,ms2,h2,ms3,0) <- path_32_0(p,q), path(q,h1,ms2,h2,ms3,0).
+path(p,h1,ms2,h2,ms3,k0) <- path_32_0(p,q), path(q,h1,ms2,h2,ms3,0), K_index[k0] = 0.
+//path(p,h1,ms1,h3,ms5,0) <- path_33_4(p,v,h1,ms1,ms2,h3), kill(ms2,v,ms5).
+path(p,h1,ms1,h3,ms5,k0) <- path_33_4(p,v,h1,ms1,ms2,h3), kill(ms2,v,ms5), K_index[k0] = 0.
+//path(p,h1,ms1,h3,ms2,0) <- path_34_3(p,v,h1,ms1,ms2,h3), !contain(v,ms2).
+path(p,h1,ms1,h3,ms2,k0) <- path_34_3(p,v,h1,ms1,ms2,h3), !contain(v,ms2), K_index[k0] = 0.
+//path(p,h1,ms1,h3,ms5,0) <- path_35_4(p,v,h1,ms1,ms2,h3), gen(ms2,v,ms5).
+path(p,h1,ms1,h3,ms5,k0) <- path_35_4(p,v,h1,ms1,ms2,h3), gen(ms2,v,ms5), K_index[k0] = 0.
+//path(p,h1,ms1,h3,ms2,0) <- path_36_3(p,v,h1,ms1,ms2,h3), deny(v).
+path(p,h1,ms1,h3,ms2,k0) <- path_36_3(p,v,h1,ms1,ms2,h3), deny(v), K_index[k0] = 0.
+//path(p,h1,ms1,h3,ms2,0) <- path_37_4(p,m,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,_).
+path(p,h1,ms1,h3,ms2,k0) <- path_37_4(p,m,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,_), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,1) <- path_38_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k1) <- path_38_1(p,v,h1,ms1,h2,ms2), contain(v,ms2), K_index[k1] = 1.
+//path(p,h1,ms1,h2,ms2,0) <- path_39_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- path_39_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2), K_index[k0] = 0.
+summary(m,h1,ms1,h2,k) <- MPtail(m,p), path(p,h1,ms1,h2,_,k).
+relevantP(p) <- PobjValAsgnInst(p,_,_).
+relevantP(p) <- PobjVarAsgnInst(p,_,_).
+relevantP(p) <- PobjNullAsgnInst(p,_).
+relevantP(p) <- PgetInstFldInst(p,_,_,_).
+relevantP(p) <- PgetStatFldInst(p,_,_).
+relevantP(p) <- PI(p,_).
+relevantP(p) <- PobjRetInst(p,_).
+relevantP(p) <- MPhead(_,p).
+nonRelevantP(p) <- PP(_,p), !relevantP(p).
+path(p,h1,ms1,h2,ms2,k) <- path_50_0(p,q), path(q,h1,ms1,h2,ms2,k).
+unprovenQuery(q,h) <- unprovenQuery_51_5(q,i,h), !checkExcludedI(i).
+path_7_0(p,v,h,q) <- PobjValAsgnInst(p,v,h), PP(q,p).
+//path_7_1(p,v,h) <- path_7_0(p,v,h,q), path(q,0,0,0,0,0).
+path_7_1(p,v,h) <- path_7_0(p,v,h,q), path(q,h0,ms0,h0,ms0,k0), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+path_7_2(p,v,h) <- path_7_1(p,v,h), allow(v).
+//path_7_3(p,h,ms) <- path_7_2(p,v,h), gen(0,v,ms).
+path_7_3(p,h,ms) <- path_7_2(p,v,h), gen(ms0,v,ms), MS_index[ms0] = 0.
+path_8_0(p,v,h,q) <- PobjValAsgnInst(p,v,h), PP(q,p).
+//path_8_1(p,v,h) <- path_8_0(p,v,h,q), path(q,0,0,0,0,0).
+path_8_1(p,v,h) <- path_8_0(p,v,h,q), path(q,h0,ms0,h0,ms0,k0), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+path_8_2(p,h) <- path_8_1(p,v,h), deny(v).
+path_9_0(p,v,q) <- PobjValAsgnInst(p,v,_), PP(q,p).
+//path_9_1(p,v,h1,ms1,h2,ms2) <- path_9_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_9_1(p,v,h1,ms1,h2,ms2) <- path_9_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_9_2(p,v,h1,ms1,h2,ms2) <- path_9_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+path_10_0(p,v,q) <- PobjValAsgnInst(p,v,_), PP(q,p).
+//path_10_1(p,v,h1,ms1,h2,ms2) <- path_10_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_10_1(p,v,h1,ms1,h2,ms2) <- path_10_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_11_0(p,v,u,q) <- PobjVarAsgnInst(p,v,u), PP(q,p).
+//path_11_1(p,v,u,h1,ms1,h2,ms2) <- path_11_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_11_1(p,v,u,h1,ms1,h2,ms2) <- path_11_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_11_2(p,v,h1,ms1,h2,ms2) <- path_11_1(p,v,u,h1,ms1,h2,ms2), !contain(u,ms2).
+path_11_3(p,v,h1,ms1,h2,ms2) <- path_11_2(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+path_12_0(p,v,u,q) <- PobjVarAsgnInst(p,v,u), PP(q,p).
+//path_12_1(p,v,u,h1,ms1,h2,ms2) <- path_12_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_12_1(p,v,u,h1,ms1,h2,ms2) <- path_12_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_12_2(p,v,h1,ms1,h2,ms2) <- path_12_1(p,v,u,h1,ms1,h2,ms2), !contain(u,ms2).
+path_13_0(p,v,u,q) <- PobjVarAsgnInst(p,v,u), PP(q,p).
+//path_13_1(p,v,u,h1,ms1,h2,ms2) <- path_13_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_13_1(p,v,u,h1,ms1,h2,ms2) <- path_13_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_13_2(p,v,h1,ms1,h2,ms2) <- path_13_1(p,v,u,h1,ms1,h2,ms2), contain(u,ms2).
+path_14_0(p,v,u,q) <- PobjVarAsgnInst(p,v,u), PP(q,p).
+//path_14_1(p,v,u,h1,ms1,h2,ms2) <- path_14_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_14_1(p,v,u,h1,ms1,h2,ms2) <- path_14_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_14_2(p,v,h1,ms1,h2,ms2) <- path_14_1(p,v,u,h1,ms1,h2,ms2), contain(u,ms2).
+path_14_3(p,v,h1,ms1,h2,ms2) <- path_14_2(p,v,h1,ms1,h2,ms2), allow(v).
+path_15_0(p,v,q) <- PobjNullAsgnInst(p,v), PP(q,p).
+//path_15_1(p,v,h1,ms1,h2,ms2) <- path_15_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_15_1(p,v,h1,ms1,h2,ms2) <- path_15_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_15_2(p,v,h1,ms1,h2,ms2) <- path_15_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+path_16_0(p,v,q) <- PobjNullAsgnInst(p,v), PP(q,p).
+//path_16_1(p,v,h1,ms1,h2,ms2) <- path_16_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_16_1(p,v,h1,ms1,h2,ms2) <- path_16_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_17_0(p,v,q) <- PgetInstFldInst(p,v,_,_), PP(q,p).
+//path_17_1(p,v,h1,ms1,h2,ms2) <- path_17_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_17_1(p,v,h1,ms1,h2,ms2) <- path_17_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_17_2(p,v,h1,ms1,h2,ms2) <- path_17_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+path_18_0(p,v,q) <- PgetInstFldInst(p,v,_,_), PP(q,p).
+//path_18_1(p,v,h1,ms1,h2,ms2) <- path_18_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_18_1(p,v,h1,ms1,h2,ms2) <- path_18_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_19_0(p,v,q) <- PgetStatFldInst(p,v,_), PP(q,p).
+//path_19_1(p,v,h1,ms1,h2,ms2) <- path_19_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_19_1(p,v,h1,ms1,h2,ms2) <- path_19_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_19_2(p,v,h1,ms1,h2,ms2) <- path_19_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+path_20_0(p,v,q) <- PgetStatFldInst(p,v,_), PP(q,p).
+//path_20_1(p,v,h1,ms1,h2,ms2) <- path_20_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_20_1(p,v,h1,ms1,h2,ms2) <- path_20_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+pathArgInit_21_0(p) <- PInvkInst(p,m,_,_,z), MZfirst(m,z).
+pathArgInit_21_1(q) <- pathArgInit_21_0(p), PP(q,p).
+pathArg_22_0(m,v,u,z,q) <- PInvkInst(p,m,v,u,z), PP(q,p).
+pathArg_22_1(m,v,u,z,q) <- pathArg_22_0(m,v,u,z,q), MZfirst(m,z).
+pathArg_22_2(m,v,u,z,q,ms2) <- pathArg_22_1(m,v,u,z,q), path(q,_,_,_,ms2,_).
+pathArg_22_3(m,v,z,q,ms2) <- pathArg_22_2(m,v,u,z,q,ms2), contain(u,ms2).
+pathArg_22_4(m,v,z,q,ms2) <- pathArg_22_3(m,v,z,q,ms2), allow(v).
+pathArg_23_0(m,v,u,z,q) <- PInvkInst(p,m,v,u,z), PP(q,p).
+pathArg_23_1(m,v,u,z,q) <- pathArg_23_0(m,v,u,z,q), MZfirst(m,z).
+pathArg_23_2(m,v,u,z,q,ms2) <- pathArg_23_1(m,v,u,z,q), path(q,_,_,_,ms2,_).
+pathArg_23_3(m,v,z,q,ms2) <- pathArg_23_2(m,v,u,z,q,ms2), contain(u,ms2).
+pathArg_24_0(m,u,z,q) <- PInvkInst(p,m,_,u,z), PP(q,p).
+pathArg_24_1(m,u,z,q) <- pathArg_24_0(m,u,z,q), MZfirst(m,z).
+pathArg_24_2(m,u,z,q,ms2) <- pathArg_24_1(m,u,z,q), path(q,_,_,_,ms2,_).
+pathArg_25_0(m,v,u,z2,q) <- PInvkInst(p,m,v,u,z2), PP(q,p).
+pathArg_25_1(m,v,u,z2,q,z1) <- pathArg_25_0(m,v,u,z2,q), MZZ(m,z1,z2).
+pathArg_25_2(m,v,u,z2,q,ms2,ms3) <- pathArg_25_1(m,v,u,z2,q,z1), pathArg(q,z1,m,ms2,ms3).
+pathArg_25_3(m,v,z2,q,ms2,ms3) <- pathArg_25_2(m,v,u,z2,q,ms2,ms3), contain(u,ms2).
+pathArg_25_4(m,v,z2,q,ms2,ms3) <- pathArg_25_3(m,v,z2,q,ms2,ms3), allow(v).
+pathArg_26_0(m,v,u,z2,q) <- PInvkInst(p,m,v,u,z2), PP(q,p).
+pathArg_26_1(m,v,u,z2,q,z1) <- pathArg_26_0(m,v,u,z2,q), MZZ(m,z1,z2).
+pathArg_26_2(m,v,u,z2,q,ms2,ms3) <- pathArg_26_1(m,v,u,z2,q,z1), pathArg(q,z1,m,ms2,ms3).
+pathArg_26_3(m,v,z2,q,ms2,ms3) <- pathArg_26_2(m,v,u,z2,q,ms2,ms3), contain(u,ms2).
+pathArg_27_0(m,u,z2,q) <- PInvkInst(p,m,_,u,z2), PP(q,p).
+pathArg_27_1(m,u,z2,q,z1) <- pathArg_27_0(m,u,z2,q), MZZ(m,z1,z2).
+pathArg_27_2(m,u,z2,q,ms2,ms3) <- pathArg_27_1(m,u,z2,q,z1), pathArg(q,z1,m,ms2,ms3).
+path_29_0(m,ms2,h1) <- pathArgLast(q,m,ms1,ms2), pathArgInit(q,ms1,h1).
+path_29_1(ms2,h1,p) <- path_29_0(m,ms2,h1), MPhead(m,p).
+path_29_2(ms2,h1,p,ms3) <- path_29_1(ms2,h1,p), ms2=ms3.
+pathArgInit_30_0(p,m) <- PI(p,i), IM(i,m).
+pathArgInit_30_1(m,q) <- pathArgInit_30_0(p,m), PP(q,p).
+pathArgInit_30_2(q,k) <- pathArgInit_30_1(m,q), MK(m,k).
+pathArgInit_30_3(q) <- pathArgInit_30_2(q,k), k=0.
+pathArgLast_31_0(p,m) <- PI(p,i), IM(i,m).
+pathArgLast_31_1(m,q) <- pathArgLast_31_0(p,m), PP(q,p).
+pathArgLast_31_2(m,q,k) <- pathArgLast_31_1(m,q), MK(m,k).
+pathArgLast_31_3(m,q) <- pathArgLast_31_2(m,q,k), k=0.
+path_32_0(p,q) <- PInvkSkip(p), PP(q,p).
+path_33_0(p,m,v,q) <- PInvkRetInst(p,m,v,_), PP(q,p).
+//path_33_1(p,m,v,q,h1,ms1,h2,ms2) <- path_33_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_33_1(p,m,v,q,h1,ms1,h2,ms2) <- path_33_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_33_2(p,m,v,h1,ms1,h2,ms2,ms3) <- path_33_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+//path_33_3(p,v,h1,ms1,ms2,h3) <- path_33_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,0).
+path_33_3(p,v,h1,ms1,ms2,h3) <- path_33_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k0), K_index[k0] = 0.
+path_33_4(p,v,h1,ms1,ms2,h3) <- path_33_3(p,v,h1,ms1,ms2,h3), contain(v,ms2).
+path_34_0(p,m,v,q) <- PInvkRetInst(p,m,v,_), PP(q,p).
+//path_34_1(p,m,v,q,h1,ms1,h2,ms2) <- path_34_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_34_1(p,m,v,q,h1,ms1,h2,ms2) <- path_34_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_34_2(p,m,v,h1,ms1,h2,ms2,ms3) <- path_34_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+//path_34_3(p,v,h1,ms1,ms2,h3) <- path_34_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,0).
+path_34_3(p,v,h1,ms1,ms2,h3) <- path_34_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k0), K_index[k0] = 0.
+path_35_0(p,m,v,q) <- PInvkRetInst(p,m,v,_), PP(q,p).
+//path_35_1(p,m,v,q,h1,ms1,h2,ms2) <- path_35_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_35_1(p,m,v,q,h1,ms1,h2,ms2) <- path_35_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_35_2(p,m,v,h1,ms1,h2,ms2,ms3) <- path_35_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+path_35_3(p,v,h1,ms1,ms2,h3) <- path_35_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k1), K_index[k1] = 1.
+path_35_4(p,v,h1,ms1,ms2,h3) <- path_35_3(p,v,h1,ms1,ms2,h3), allow(v).
+path_36_0(p,m,v,q) <- PInvkRetInst(p,m,v,_), PP(q,p).
+//path_36_1(p,m,v,q,h1,ms1,h2,ms2) <- path_36_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_36_1(p,m,v,q,h1,ms1,h2,ms2) <- path_36_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_36_2(p,m,v,h1,ms1,h2,ms2,ms3) <- path_36_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+path_36_3(p,v,h1,ms1,ms2,h3) <- path_36_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k1), K_index[k1] = 1.
+path_37_0(p,m) <- PI(p,i), IM(i,m).
+path_37_1(p,m) <- path_37_0(p,m), PInvkRetInstNotFilter(p,m).
+path_37_2(p,m,q) <- path_37_1(p,m), PP(q,p).
+//path_37_3(p,m,q,h1,ms1,h2,ms2) <- path_37_2(p,m,q), path(q,h1,ms1,h2,ms2,0).
+path_37_3(p,m,q,h1,ms1,h2,ms2) <- path_37_2(p,m,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_37_4(p,m,h1,ms1,h2,ms2,ms3) <- path_37_3(p,m,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+path_38_0(p,v,q) <- PobjRetInst(p,v), PP(q,p).
+//path_38_1(p,v,h1,ms1,h2,ms2) <- path_38_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_38_1(p,v,h1,ms1,h2,ms2) <- path_38_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_39_0(p,v,q) <- PobjRetInst(p,v), PP(q,p).
+//path_39_1(p,v,h1,ms1,h2,ms2) <- path_39_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_39_1(p,v,h1,ms1,h2,ms2) <- path_39_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_50_0(p,q) <- nonRelevantP(p), PP(q,p).
+unprovenQuery_51_0(q,i) <- PI(q,i), virtIM(i,_).
+unprovenQuery_51_1(q,i,p) <- unprovenQuery_51_0(q,i), PP(p,q).
+unprovenQuery_51_2(q,i,h,ms) <- unprovenQuery_51_1(q,i,p), path(p,_,_,h,ms,_).
+//unprovenQuery_51_3(q,i,h,ms,v) <- unprovenQuery_51_2(q,i,h,ms), IinvkArg(i,0,v).
+unprovenQuery_51_3(q,i,h,ms,v) <- unprovenQuery_51_2(q,i,h,ms), IinvkArg(i,z0,v), Z_index[z0] = 0.
+unprovenQuery_51_4(q,i,h,ms,v) <- unprovenQuery_51_3(q,i,h,ms,v), VH(v,h).
+unprovenQuery_51_5(q,i,h) <- unprovenQuery_51_4(q,i,h,ms,v), !contain(v,ms).
+
+// #Instrumented rules
+path_XZ89_0(p,h1,ms1,h2,ms2,v) <- path_13_2(p,v,h1,ms1,h2,ms2), deny(v).
+path_XZ89_1(p,h1,ms1,h2,ms3,v,ms2) <- path_14_3(p,v,h1,ms1,h2,ms2), gen(ms2,v,ms3).
+path_XZ89_2(p,h1,ms1,h2,ms3,v,ms2) <- path_15_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path_XZ89_3(p,h1,ms1,h2,ms2,v) <- path_16_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path_XZ89_4(p,h1,ms1,h2,ms3,v,ms2) <- path_17_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path_XZ89_5(p,h1,ms1,h2,ms2,v) <- path_18_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path_XZ89_6(p,h1,ms1,h2,ms3,v,ms2) <- path_19_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path_XZ89_7(p,h1,ms1,h2,ms2,v) <- path_20_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+pathArgInit_XZ89_8(q,ms1,h1,v_XZ89_0,v_XZ89_1,v_XZ89_2) <- pathArgInit_21_1(q), path(q,v_XZ89_0,v_XZ89_1,h1,ms1,v_XZ89_2).
+pathArg_XZ89_9(q,z,m,ms2,v) <- pathArg_23_3(m,v,z,q,ms2), deny(v).
+pathArg_XZ89_10(q,z,m,ms2,u) <- pathArg_24_2(m,u,z,q,ms2), !contain(u,ms2).
+pathArg_XZ89_11(q,z2,m,ms2,ms4,v,ms3) <- pathArg_25_4(m,v,z2,q,ms2,ms3), gen(ms3,v,ms4).
+pathArg_XZ89_12(q,z2,m,ms2,ms3,v) <- pathArg_26_3(m,v,z2,q,ms2,ms3), deny(v).
+pathArg_XZ89_13(q,z2,m,ms2,ms3,u) <- pathArg_27_2(m,u,z2,q,ms2,ms3), !contain(u,ms2).
+pathArgLast_XZ89_14(q,m,ms1,ms2,z) <- pathArg(q,z,m,ms1,ms2), MZlast(m,z).
+path_XZ89_15(p,h1,ms2,h2,ms3) <- path_29_2(ms2,h1,p,ms3), h1=h2.
+pathArgInit_XZ89_16(q,ms1,h1,v_XZ89_0,v_XZ89_1,v_XZ89_2) <- pathArgInit_30_3(q), path(q,v_XZ89_0,v_XZ89_1,h1,ms1,v_XZ89_2).
+pathArgLast_XZ89_17(q,m,ms1,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) <- pathArgLast_31_3(m,q), path(q,v_XZ89_0,v_XZ89_1,v_XZ89_2,ms1,v_XZ89_3).
+//path_XZ89_18(p,h1,ms2,h2,ms3,q) <- path_32_0(p,q), path(q,h1,ms2,h2,ms3,0).
+path_XZ89_18(p,h1,ms2,h2,ms3,q) <- path_32_0(p,q), path(q,h1,ms2,h2,ms3,k0), K_index[k0] = 0.
+path_XZ89_19(p,h1,ms1,h3,ms5,v,ms2) <- path_33_4(p,v,h1,ms1,ms2,h3), kill(ms2,v,ms5).
+path_XZ89_20(p,h1,ms1,h3,ms2,v) <- path_34_3(p,v,h1,ms1,ms2,h3), !contain(v,ms2).
+path_XZ89_21(p,h1,ms1,h3,ms5,v,ms2) <- path_35_4(p,v,h1,ms1,ms2,h3), gen(ms2,v,ms5).
+path_XZ89_22(p,h1,ms1,h3,ms2,v) <- path_36_3(p,v,h1,ms1,ms2,h3), deny(v).
+path_XZ89_23(p,h1,ms1,h3,ms2,m,h2,ms3,v_XZ89_0) <- path_37_4(p,m,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,v_XZ89_0).
+path_XZ89_24(p,h1,ms1,h2,ms2,v) <- path_38_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+path_XZ89_25(p,h1,ms1,h2,ms2,v) <- path_39_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+summary_XZ89_26(m,h1,ms1,h2,k,p,v_XZ89_0) <- MPtail(m,p), path(p,h1,ms1,h2,v_XZ89_0,k).
+path_XZ89_27(p,h1,ms1,h2,ms2,k,q) <- path_50_0(p,q), path(q,h1,ms1,h2,ms2,k).
+//path_7_1_XZ89_28(p,v,h,q) <- path_7_0(p,v,h,q), path(q,0,0,0,0,0).
+path_7_1_XZ89_28(p,v,h,q) <- path_7_0(p,v,h,q), path(q,h0,ms0,h0,ms0,k0), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+path_7_2_XZ89_29(p,v,h) <- path_7_1(p,v,h), allow(v).
+//path_7_3_XZ89_30(p,h,ms,v) <- path_7_2(p,v,h), gen(0,v,ms).
+path_7_3_XZ89_30(p,h,ms,v) <- path_7_2(p,v,h), gen(ms0,v,ms), MS_index[ms0] = 0.
+//path_8_1_XZ89_31(p,v,h,q) <- path_8_0(p,v,h,q), path(q,0,0,0,0,0).
+path_8_1_XZ89_31(p,v,h,q) <- path_8_0(p,v,h,q), path(q,h0,ms0,h0,ms0,k0), , H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+path_8_2_XZ89_32(p,h,v) <- path_8_1(p,v,h), deny(v).
+//path_9_1_XZ89_33(p,v,h1,ms1,h2,ms2,q) <- path_9_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_9_1_XZ89_33(p,v,h1,ms1,h2,ms2,q) <- path_9_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_9_2_XZ89_34(p,v,h1,ms1,h2,ms2) <- path_9_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+//path_10_1_XZ89_35(p,v,h1,ms1,h2,ms2,q) <- path_10_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_10_1_XZ89_35(p,v,h1,ms1,h2,ms2,q) <- path_10_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+//path_11_1_XZ89_36(p,v,u,h1,ms1,h2,ms2,q) <- path_11_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_11_1_XZ89_36(p,v,u,h1,ms1,h2,ms2,q) <- path_11_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_11_2_XZ89_37(p,v,h1,ms1,h2,ms2,u) <- path_11_1(p,v,u,h1,ms1,h2,ms2), !contain(u,ms2).
+path_11_3_XZ89_38(p,v,h1,ms1,h2,ms2) <- path_11_2(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+//path_12_1_XZ89_39(p,v,u,h1,ms1,h2,ms2,q) <- path_12_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_12_1_XZ89_39(p,v,u,h1,ms1,h2,ms2,q) <- path_12_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_12_2_XZ89_40(p,v,h1,ms1,h2,ms2,u) <- path_12_1(p,v,u,h1,ms1,h2,ms2), !contain(u,ms2).
+//path_13_1_XZ89_41(p,v,u,h1,ms1,h2,ms2,q) <- path_13_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_13_1_XZ89_41(p,v,u,h1,ms1,h2,ms2,q) <- path_13_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_13_2_XZ89_42(p,v,h1,ms1,h2,ms2,u) <- path_13_1(p,v,u,h1,ms1,h2,ms2), contain(u,ms2).
+//path_14_1_XZ89_43(p,v,u,h1,ms1,h2,ms2,q) <- path_14_0(p,v,u,q), path(q,h1,ms1,h2,ms2,0).
+path_14_1_XZ89_43(p,v,u,h1,ms1,h2,ms2,q) <- path_14_0(p,v,u,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_14_2_XZ89_44(p,v,h1,ms1,h2,ms2,u) <- path_14_1(p,v,u,h1,ms1,h2,ms2), contain(u,ms2).
+path_14_3_XZ89_45(p,v,h1,ms1,h2,ms2) <- path_14_2(p,v,h1,ms1,h2,ms2), allow(v).
+//path_15_1_XZ89_46(p,v,h1,ms1,h2,ms2,q) <- path_15_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_15_1_XZ89_46(p,v,h1,ms1,h2,ms2,q) <- path_15_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_15_2_XZ89_47(p,v,h1,ms1,h2,ms2) <- path_15_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+//path_16_1_XZ89_48(p,v,h1,ms1,h2,ms2,q) <- path_16_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_16_1_XZ89_48(p,v,h1,ms1,h2,ms2,q) <- path_16_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+//path_17_1_XZ89_49(p,v,h1,ms1,h2,ms2,q) <- path_17_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_17_1_XZ89_49(p,v,h1,ms1,h2,ms2,q) <- path_17_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_17_2_XZ89_50(p,v,h1,ms1,h2,ms2) <- path_17_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+//path_18_1_XZ89_51(p,v,h1,ms1,h2,ms2,q) <- path_18_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_18_1_XZ89_51(p,v,h1,ms1,h2,ms2,q) <- path_18_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+//path_19_1_XZ89_52(p,v,h1,ms1,h2,ms2,q) <- path_19_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_19_1_XZ89_52(p,v,h1,ms1,h2,ms2,q) <- path_19_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_19_2_XZ89_53(p,v,h1,ms1,h2,ms2) <- path_19_1(p,v,h1,ms1,h2,ms2), contain(v,ms2).
+//path_20_1_XZ89_54(p,v,h1,ms1,h2,ms2,q) <- path_20_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_20_1_XZ89_54(p,v,h1,ms1,h2,ms2,q) <- path_20_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+pathArg_22_2_XZ89_55(m,v,u,z,q,ms2,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) <- pathArg_22_1(m,v,u,z,q), path(q,v_XZ89_0,v_XZ89_1,v_XZ89_2,ms2,v_XZ89_3).
+pathArg_22_3_XZ89_56(m,v,z,q,ms2,u) <- pathArg_22_2(m,v,u,z,q,ms2), contain(u,ms2).
+pathArg_22_4_XZ89_57(m,v,z,q,ms2) <- pathArg_22_3(m,v,z,q,ms2), allow(v).
+pathArg_23_2_XZ89_58(m,v,u,z,q,ms2,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) <- pathArg_23_1(m,v,u,z,q), path(q,v_XZ89_0,v_XZ89_1,v_XZ89_2,ms2,v_XZ89_3).
+pathArg_23_3_XZ89_59(m,v,z,q,ms2,u) <- pathArg_23_2(m,v,u,z,q,ms2), contain(u,ms2).
+pathArg_24_2_XZ89_60(m,u,z,q,ms2,v_XZ89_0,v_XZ89_1,v_XZ89_2,v_XZ89_3) <- pathArg_24_1(m,u,z,q), path(q,v_XZ89_0,v_XZ89_1,v_XZ89_2,ms2,v_XZ89_3).
+pathArg_25_2_XZ89_61(m,v,u,z2,q,ms2,ms3,z1) <- pathArg_25_1(m,v,u,z2,q,z1), pathArg(q,z1,m,ms2,ms3).
+pathArg_25_3_XZ89_62(m,v,z2,q,ms2,ms3,u) <- pathArg_25_2(m,v,u,z2,q,ms2,ms3), contain(u,ms2).
+pathArg_25_4_XZ89_63(m,v,z2,q,ms2,ms3) <- pathArg_25_3(m,v,z2,q,ms2,ms3), allow(v).
+pathArg_26_2_XZ89_64(m,v,u,z2,q,ms2,ms3,z1) <- pathArg_26_1(m,v,u,z2,q,z1), pathArg(q,z1,m,ms2,ms3).
+pathArg_26_3_XZ89_65(m,v,z2,q,ms2,ms3,u) <- pathArg_26_2(m,v,u,z2,q,ms2,ms3), contain(u,ms2).
+pathArg_27_2_XZ89_66(m,u,z2,q,ms2,ms3,z1) <- pathArg_27_1(m,u,z2,q,z1), pathArg(q,z1,m,ms2,ms3).
+path_29_0_XZ89_67(m,ms2,h1,q,ms1) <- pathArgLast(q,m,ms1,ms2), pathArgInit(q,ms1,h1).
+path_29_1_XZ89_68(ms2,h1,p,m) <- path_29_0(m,ms2,h1), MPhead(m,p).
+path_29_2_XZ89_69(ms2,h1,p,ms3) <- path_29_1(ms2,h1,p), ms2=ms3.
+//path_33_1_XZ89_70(p,m,v,q,h1,ms1,h2,ms2) <- path_33_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_33_1_XZ89_70(p,m,v,q,h1,ms1,h2,ms2) <- path_33_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_33_2_XZ89_71(p,m,v,h1,ms1,h2,ms2,ms3,q) <- path_33_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+//path_33_3_XZ89_72(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_33_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,0).
+path_33_3_XZ89_72(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_33_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k0), K_index[k0] = 0.
+path_33_4_XZ89_73(p,v,h1,ms1,ms2,h3) <- path_33_3(p,v,h1,ms1,ms2,h3), contain(v,ms2).
+//path_34_1_XZ89_74(p,m,v,q,h1,ms1,h2,ms2) <- path_34_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_34_1_XZ89_74(p,m,v,q,h1,ms1,h2,ms2) <- path_34_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_34_2_XZ89_75(p,m,v,h1,ms1,h2,ms2,ms3,q) <- path_34_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+//path_34_3_XZ89_76(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_34_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,0).
+path_34_3_XZ89_76(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_34_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k0), K_index[k0] = 0.
+//path_35_1_XZ89_77(p,m,v,q,h1,ms1,h2,ms2) <- path_35_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_35_1_XZ89_77(p,m,v,q,h1,ms1,h2,ms2) <- path_35_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_35_2_XZ89_78(p,m,v,h1,ms1,h2,ms2,ms3,q) <- path_35_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+//path_35_3_XZ89_79(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_35_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,1).
+path_35_3_XZ89_79(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_35_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k1), K_index[k1] = 1.
+path_35_4_XZ89_80(p,v,h1,ms1,ms2,h3) <- path_35_3(p,v,h1,ms1,ms2,h3), allow(v).
+//path_36_1_XZ89_81(p,m,v,q,h1,ms1,h2,ms2) <- path_36_0(p,m,v,q), path(q,h1,ms1,h2,ms2,0).
+path_36_1_XZ89_81(p,m,v,q,h1,ms1,h2,ms2) <- path_36_0(p,m,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_36_2_XZ89_82(p,m,v,h1,ms1,h2,ms2,ms3,q) <- path_36_1(p,m,v,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+//path_36_3_XZ89_83(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_36_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,1).
+path_36_3_XZ89_83(p,v,h1,ms1,ms2,h3,m,h2,ms3) <- path_36_2(p,m,v,h1,ms1,h2,ms2,ms3), summary(m,h2,ms3,h3,k1), K_index[k1] = 1.
+//path_37_3_XZ89_84(p,m,q,h1,ms1,h2,ms2) <- path_37_2(p,m,q), path(q,h1,ms1,h2,ms2,0).
+path_37_3_XZ89_84(p,m,q,h1,ms1,h2,ms2) <- path_37_2(p,m,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+path_37_4_XZ89_85(p,m,h1,ms1,h2,ms2,ms3,q) <- path_37_3(p,m,q,h1,ms1,h2,ms2), pathArgLast(q,m,ms2,ms3).
+//path_38_1_XZ89_86(p,v,h1,ms1,h2,ms2,q) <- path_38_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_38_1_XZ89_86(p,v,h1,ms1,h2,ms2,q) <- path_38_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+//path_39_1_XZ89_87(p,v,h1,ms1,h2,ms2,q) <- path_39_0(p,v,q), path(q,h1,ms1,h2,ms2,0).
+path_39_1_XZ89_87(p,v,h1,ms1,h2,ms2,q) <- path_39_0(p,v,q), path(q,h1,ms1,h2,ms2,k0), K_index[k0] = 0.
+unprovenQuery_51_2_XZ89_88(q,i,h,ms,p,v_XZ89_0,v_XZ89_1,v_XZ89_2) <- unprovenQuery_51_1(q,i,p), path(p,v_XZ89_0,v_XZ89_1,h,ms,v_XZ89_2).
+//unprovenQuery_51_3_XZ89_89(q,i,h,ms,v) <- unprovenQuery_51_2(q,i,h,ms), IinvkArg(i,0,v).
+unprovenQuery_51_3_XZ89_89(q,i,h,ms,v) <- unprovenQuery_51_2(q,i,h,ms), IinvkArg(i,z0,v), Z_index[z0] = 0.
+unprovenQuery_51_4_XZ89_90(q,i,h,ms,v) <- unprovenQuery_51_3(q,i,h,ms,v), VH(v,h).
+unprovenQuery_51_5_XZ89_91(q,i,h,ms,v) <- unprovenQuery_51_4(q,i,h,ms,v), !contain(v,ms).
+path_XZ89_92(p,m) <- reachableM(m), MPhead(m,p).
+path_XZ89_93(p,h,ms) <- path_7_3(p,h,ms), trackedH(h).
+path_XZ89_94(p,h) <- path_8_2(p,h), trackedH(h).
+path_XZ89_95(p,h1,ms1,h2,ms3,v,ms2) <- path_9_2(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path_XZ89_96(p,h1,ms1,h2,ms2,v) <- path_10_1(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+path_XZ89_97(p,h1,ms1,h2,ms3,v,ms2) <- path_11_3(p,v,h1,ms1,h2,ms2), kill(ms2,v,ms3).
+path_XZ89_98(p,h1,ms1,h2,ms2,v) <- path_12_2(p,v,h1,ms1,h2,ms2), !contain(v,ms2).
+//pathArg_XZ89_99(q,z,m,ms2,ms3,v) <- pathArg_22_4(m,v,z,q,ms2), gen(0,v,ms3).
+pathArg_XZ89_99(q,z,m,ms2,ms3,v) <- pathArg_22_4(m,v,z,q,ms2), gen(ms0,v,ms3), MS_index[ms0] = 0.
+unprovenQuery_XZ89_100(q,h,i) <- unprovenQuery_51_5(q,i,h), !checkExcludedI(i).
diff -Nur jchord/main/src/chord/analyses/provenance/typestate/typestate.logic jchord/main/src/chord/analyses/provenance/typestate/typestate.logic
--- jchord/main/src/chord/analyses/provenance/typestate/typestate.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/provenance/typestate/typestate.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,243 @@
+// Created by convert.py from ./src/chord/analyses/provenance/typestate/typestate.dlog on 2015-04-20 13:08:42.315005
+// # Author: Ravi Mangal, Xin Zhang
+// :name: typestate-dlog
+
+// :domains: I
+// :domains: M
+// :domains: P
+// :domains: V
+// :domains: Z
+// :domains: H
+// :domains: MS
+// :domains: K
+// :domains: F
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: PP(P,P)
+// :inputs: PI(P,I)
+// :inputs: IM(I,M)
+// :inputs: PobjValAsgnInst(P,V,H)
+// :inputs: PobjVarAsgnInst(P,V,V)
+// :inputs: MPhead(M,P)
+// :inputs: rootM(M)
+// :inputs: PobjNullAsgnInst(P,V)
+// :inputs: PgetInstFldInst(P,V,V,F)
+// :inputs: PgetStatFldInst(P,V,F)
+// :inputs: MmethArg(M,Z,V)
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: MP(M,P)
+// :inputs: MPtail(M,P)
+// :inputs: IinvkRet(I,Z,V)
+// :inputs: MmethRet(M0,Z0,V1)
+// :inputs: MZfirst(M,Z)
+// :inputs: MZlast(M,Z)
+// :inputs: MZZ(M,Z,Z)
+// :inputs: MK(M,K)
+// :inputs: gen(MS,V,MS)
+// :inputs: kill(MS,V,MS)
+// :inputs: contain(V,MS)
+// :inputs: virtIM(I,M)
+// :inputs: specIM(I,M)
+// :inputs: PobjRetInst(P,V)
+// :inputs: checkExcludedH(H)
+// :inputs: checkExcludedI(I)
+// :inputs: VH(V,H)
+// :inputs: reachableM(M)
+// :inputs: trackedH(H)
+
+// :inputs: allow(V)
+// :inputs: deny(V)
+
+// :outputs: path(P,H,MS,H,MS,K)
+path(p,h1,ms1,h2,ms2,k) -> P(p), H(h1), MS(ms1), H(h2), MS(ms2), K(k).
+// :outputs: summary(M,H,MS,H,K)
+summary(m,h,ms1,h2,k) -> M(m), H(h), MS(ms1), H(h2), K(k).
+// :outputs: pathArg(P,Z,M,MS,MS)
+pathArg(p,z,m,ms1,ms2) -> P(p), Z(z), M(m), MS(ms1), MS(ms2).
+// #VVMZ(v:V,u:V,m:M,z:Z)
+// #VVMZRet(v:V,u:V,m:M)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: PInvkInst(P,M,V,V,Z)
+PInvkInst(p,m,v,u,z) -> P(p), M(m), V(v), V(u), Z(z).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: PInvkRetInst(P,M,V,V)
+PInvkRetInst(p,m,v,u) -> P(p), M(m), V(v), V(u).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: PInvkRetInstFilter(P,M)
+PInvkRetInstFilter(p,m) -> P(p), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: PInvkRetInstNotFilter(P,M)
+PInvkRetInstNotFilter(p,m) -> P(p), M(m).
+// :outputs: nonRelevantP(P)
+nonRelevantP(p) -> P(p).
+// :outputs: relevantP(P)
+relevantP(p) -> P(p).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: pathArgInit(P,MS,H)
+pathArgInit(p,ms1,h) -> P(p), MS(ms1), H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: pathArgLast(P,M,MS,MS)
+pathArgLast(p,m,ms1,ms2) -> P(p), M(m), MS(ms1), MS(ms2).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: PInvkSkip(P)
+PInvkSkip(p) -> P(p).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: IMFilter(I)
+IMFilter(i) -> I(i).
+
+// :outputs: unprovenQuery(P,H)
+unprovenQuery(p,h) -> P(p), H(h).
+
+
+// ###
+// # Constraints
+// ###
+// ## Assuming throughout that no instruction will be processed
+// ## after a return instruction for any path edge.
+
+// #VVMZ(v,u,m,z) :- IinvkArg(i,z,u), IM(i,m),  MmethArg(m,z,v).
+// #VVMZRet(v,u,m) :- IinvkRet(i,z,v), IM(i,m),  MmethRet(m,z,u).
+PInvkInst(p,m,v,u,z) <- PI(p,i), IM(i,m), IinvkArg(i,z,u), MmethArg(m,z,v).
+PInvkRetInst(p,m,v,u) <- PI(p,i), IM(i,m), IinvkRet(i,z,v), MmethRet(m,z,u).
+PInvkRetInstFilter(p,m) <- PInvkRetInst(p,m,_,_).
+PInvkRetInstNotFilter(p,m) <- !PInvkRetInstFilter(p,m).
+IMFilter(i) <- IM(i,_).
+PInvkSkip(p) <- PI(p,i), !IMFilter(i).
+
+// #path(p,0,0,0,0,0) :- rootM(m), MPhead(m,p).
+// #path(p,0,0,0,0,0) :- path(q,0,0,0,0,0,0), PP(q,p).
+// #path(p,0,0,0,0,0) :- reachableM(m), MP(m,p).
+// #path(p,0,0,0,0,0) :- reachableM(m), MPtail(m,p).
+
+//path(p,0,0,0,0,0) <- reachableM(m), MPhead(m,p).
+path(p,h0,ms0,h0,ms0,k0) <- reachableM(m), MPhead(m,p), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+
+// ### v = new h
+//path(p,0,0,h,ms,0) <- PobjValAsgnInst(p,v,h), PP(q,p), path(q,0,0,0,0,0), allow(v), gen(0,v,ms), trackedH(h).
+//path(p,0,0,h,0,0) <- PobjValAsgnInst(p,v,h), PP(q,p), path(q,0,0,0,0,0), deny(v), trackedH(h).
+//path(p,h1,ms1,h2,ms3,0) <- PobjValAsgnInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).
+//path(p,h1,ms1,h2,ms2,0) <- PobjValAsgnInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).
+path(p,h0,ms0,h,ms,k0) <- PobjValAsgnInst(p,v,h), PP(q,p), path(q,h0,ms0,h0,ms0,k0), allow(v), gen(k0,v,ms), trackedH(h), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+path(p,h0,ms0,h,ms0,k0) <- PobjValAsgnInst(p,v,h), PP(q,p), path(q,h0,ms0,h0,ms0,k0), deny(v), trackedH(h), H_index[h0] = 0, MS_index[ms0] = 0, K_index[k0] = 0.
+path(p,h1,ms1,h2,ms3,k0) <- PobjValAsgnInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), contain(v,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+path(p,h1,ms1,h2,ms2,k0) <- PobjValAsgnInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), !contain(v,ms2), K_index[k0] = 0.
+
+// ### v = u
+//path(p,h1,ms1,h2,ms3,0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(u,ms2), contain(v,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,k0), !contain(u,ms2), contain(v,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(u,ms2), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,k0), !contain(u,ms2), !contain(v,ms2), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(u,ms2), deny(v).
+path(p,h1,ms1,h2,ms2,k0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,k0), contain(u,ms2), deny(v), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms3,0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(u,ms2), allow(v), gen(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- PobjVarAsgnInst(p,v,u), PP(q,p), path(q,h1,ms1,h2,ms2,k0), contain(u,ms2), allow(v), gen(ms2,v,ms3), K_index[k0] = 0.
+
+// ### v = null
+//path(p,h1,ms1,h2,ms3,0) <- PobjNullAsgnInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- PobjNullAsgnInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,k0), contain(v,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- PobjNullAsgnInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- PobjNullAsgnInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,k0), !contain(v,ms2), K_index[k0] = 0.
+
+// ### v = u.f
+//path(p,h1,ms1,h2,ms3,0) <- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), contain(v,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- PgetInstFldInst(p,v,_,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), !contain(v,ms2), K_index[k0] = 0.
+
+// ### v = f
+//path(p,h1,ms1,h2,ms3,0) <- PgetStatFldInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2), kill(ms2,v,ms3).
+path(p,h1,ms1,h2,ms3,k0) <- PgetStatFldInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), contain(v,ms2), kill(ms2,v,ms3), K_index[k0] = 0.
+//path(p,h1,ms1,h2,ms2,0) <- PgetStatFldInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- PgetStatFldInst(p,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), !contain(v,ms2), K_index[k0] = 0.
+
+// ### Method Call
+pathArgInit(q,ms1,h1) <- PInvkInst(p,m,_,_,z), MZfirst(m,z), PP(q,p), path(q,_,_,h1,ms1,_).
+//pathArg(q,z,m,ms2,ms3) <- PInvkInst(p,m,v,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), contain(u,ms2), 
+//									allow(v), gen(0,v,ms3).
+pathArg(q,z,m,ms2,ms3) <- PInvkInst(p,m,v,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), contain(u,ms2), 
+									allow(v), gen(ms0,v,ms3), MS_index[ms0] = 0.
+//pathArg(q,z,m,ms2,0) <- PInvkInst(p,m,v,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), contain(u,ms2), deny(v).
+pathArg(q,z,m,ms2,ms0) <- PInvkInst(p,m,v,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), contain(u,ms2), deny(v), MS_index[ms0] = 0.
+//pathArg(q,z,m,ms2,0) <- PInvkInst(p,m,_,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), !contain(u,ms2).
+pathArg(q,z,m,ms2,ms0) <- PInvkInst(p,m,_,u,z), PP(q,p), MZfirst(m,z), path(q,_,_,_,ms2,_), !contain(u,ms2), MS_index[ms0] = 0.
+
+pathArg(q,z2,m,ms2,ms4) <- PInvkInst(p,m,v,u,z2), PP(q,p), MZZ(m,z1,z2), pathArg(q,z1,m,ms2,ms3), 
+								 	 contain(u,ms2), allow(v), gen(ms3,v,ms4).
+pathArg(q,z2,m,ms2,ms3) <- PInvkInst(p,m,v,u,z2), PP(q,p), MZZ(m,z1,z2), pathArg(q,z1,m,ms2,ms3), 
+								 	 contain(u,ms2), deny(v).
+pathArg(q,z2,m,ms2,ms3) <- PInvkInst(p,m,_,u,z2), PP(q,p), MZZ(m,z1,z2), pathArg(q,z1,m,ms2,ms3), 
+								 	 !contain(u,ms2).
+
+pathArgLast(q,m,ms1,ms2) <- pathArg(q,z,m,ms1,ms2), MZlast(m,z).
+
+//path(p,h1,ms2,h2,ms3,0) <- pathArgLast(q,m,ms1,ms2), pathArgInit(q,ms1,h1), MPhead(m,p), ms2=ms3, h1=h2.
+path(p,h1,ms2,h2,ms3,k0) <- pathArgLast(q,m,ms1,ms2), pathArgInit(q,ms1,h1), MPhead(m,p), ms2=ms3, h1=h2, K_index[k0] = 0.
+
+
+// # To handle corner case of static method with no reference parameters
+pathArgInit(q,ms1,h1) <- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,h1,ms1,_).
+//pathArgLast(q,m,ms1,0) <- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,_,ms1,_).
+pathArgLast(q,m,ms1,ms0) <- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,_,ms1,_), MS_index[ms0] = 0.
+// #path(p,h1,0,h2,0,0,0) :- PI(p,i), IM(i,m), PP(q,p), MK(m,k), k=0, path(q,_,_,h1,_,_), MPhead(m,p), h1=h2.
+
+// # To handle corner case of invoke instruction with no target method
+//path(p,h1,ms2,h2,ms3,0) <- PInvkSkip(p), PP(q,p), path(q,h1,ms2,h2,ms3,0).
+path(p,h1,ms2,h2,ms3,k0) <- PInvkSkip(p), PP(q,p), path(q,h1,ms2,h2,ms3,k0), K_index[k0] = 0.
+
+// #Applying Summary Edge
+//path(p,h1,ms1,h3,ms5,0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3),  
+//							 summary(m,h2,ms3,h3,0), contain(v,ms2), kill(ms2,v,ms5).
+//path(p,h1,ms1,h3,ms2,0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3), 
+//							 summary(m,h2,ms3,h3,0), !contain(v,ms2).
+//path(p,h1,ms1,h3,ms5,0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3), 
+//							 summary(m,h2,ms3,h3,1), allow(v), gen(ms2,v,ms5).
+//path(p,h1,ms1,h3,ms2,0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3), 
+//							 summary(m,h2,ms3,h3,1), deny(v).
+path(p,h1,ms1,h3,ms5,k0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), pathArgLast(q,m,ms2,ms3), K_index[k0] = 0, 
+							 summary(m,h2,ms3,h3,k0), contain(v,ms2), kill(ms2,v,ms5).
+path(p,h1,ms1,h3,ms2,k0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), pathArgLast(q,m,ms2,ms3), K_index[k0] = 0, 
+							 summary(m,h2,ms3,h3,k0), !contain(v,ms2).
+path(p,h1,ms1,h3,ms5,k0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), pathArgLast(q,m,ms2,ms3), K_index[k0] = 0, 
+							 summary(m,h2,ms3,h3,k1), allow(v), gen(ms2,v,ms5), K_index[k1] = 1.
+path(p,h1,ms1,h3,ms2,k0) <- PInvkRetInst(p,m,v,_), PP(q,p), path(q,h1,ms1,h2,ms2,k0), pathArgLast(q,m,ms2,ms3), K_index[k0] = 0, 
+							 summary(m,h2,ms3,h3,k1), deny(v), K_index[k1] = 1.
+
+// # To handle corner case of invoke instruction with no return value or with no var capturing the returned value;
+// # such instructions are not captured by PInvkRetInst
+//path(p,h1,ms1,h3,ms2,0) <- PI(p,i), IM(i,m), PInvkRetInstNotFilter(p,m), PP(q,p), path(q,h1,ms1,h2,ms2,0), pathArgLast(q,m,ms2,ms3), 
+//							 summary(m,h2,ms3,h3,_).
+path(p,h1,ms1,h3,ms2,k0) <- PI(p,i), IM(i,m), PInvkRetInstNotFilter(p,m), PP(q,p), path(q,h1,ms1,h2,ms2,k0), pathArgLast(q,m,ms2,ms3), K_index[k0] = 0, 
+							 summary(m,h2,ms3,h3,_).
+
+// ### Method Return
+//path(p,h1,ms1,h2,ms2,1) <- PobjRetInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k1) <- PobjRetInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,k0), contain(v,ms2), K_index[k0] = 0, K_index[k1] = 1.
+//path(p,h1,ms1,h2,ms2,0) <- PobjRetInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,0), !contain(v,ms2).
+path(p,h1,ms1,h2,ms2,k0) <- PobjRetInst(p,v), PP(q,p), path(q,h1,ms1,h2,ms2,k0), !contain(v,ms2), K_index[k0] = 0.
+// #path(p,h1,ms1,h2,ms2,r,k) :- path(q,h1,ms1,h2,ms2,r,k), PP(q,p), MPtail(m,p). #Handled by nonRelevantP
+summary(m,h1,ms1,h2,k) <- MPtail(m,p), path(p,h1,ms1,h2,_,k).
+
+// ### All remaining instructions
+relevantP(p) <- PobjValAsgnInst(p,_,_).
+relevantP(p) <- PobjVarAsgnInst(p,_,_).
+relevantP(p) <- PobjNullAsgnInst(p,_).
+relevantP(p) <- PgetInstFldInst(p,_,_,_).
+relevantP(p) <- PgetStatFldInst(p,_,_).
+relevantP(p) <- PI(p,_).
+relevantP(p) <- PobjRetInst(p,_).
+relevantP(p) <- MPhead(_,p).
+
+// #nonRelevantP(p) :- PP(_,p), !PobjValAsgnInst(p,_,_), !PobjVarAsgnInst(p,_,_), !PobjNullAsgnInst(p,_), !PgetInstFldInst(p,_,_,_), \
+// #				   !PgetStatFldInst(p,_,_), !PI(p,_), !PobjRetInst(p,_).
+nonRelevantP(p) <- PP(_,p), !relevantP(p).
+path(p,h1,ms1,h2,ms2,k) <- nonRelevantP(p), PP(q,p), path(q,h1,ms1,h2,ms2,k).
+
+
+// ### Query
+//unprovenQuery(q,h) <- PI(q,i), virtIM(i,_), PP(p,q), path(p,_,_,h,ms,_), IinvkArg(i,0,v), VH(v,h), !contain(v,ms), !checkExcludedI(i).
+unprovenQuery(q,h) <- PI(q,i), virtIM(i,_), PP(p,q), path(p,_,_,h,ms,_), IinvkArg(i,z0,v), VH(v,h), !contain(v,ms), !checkExcludedI(i), Z_index[z0] = 0.
+// #unprovenQuery(q,h) :- PI(q,i), specIM(i,_), PP(p,q), path(p,_,_,h,ms,_), IinvkArg(i,0,v), VH(v,h), !contain(v,ms), !checkExcludedI(i).
diff -Nur jchord/main/src/chord/analyses/thread/reachableAM.logic jchord/main/src/chord/analyses/thread/reachableAM.logic
--- jchord/main/src/chord/analyses/thread/reachableAM.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/thread/reachableAM.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,37 @@
+// Created by convert.py from ./src/chord/analyses/thread/reachableAM.dlog on 2015-04-20 13:08:42.317509
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: reachableAM-dlog
+
+// :domains: M
+// :domains: I
+// :domains: A
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: IM(I,M)
+// :inputs: threadAM(A,M)
+// :inputs: MI(M,I)
+// :inputs: threadStartI(I)
+
+// :outputs: reachableAM(A,M)
+reachableAM(t,m) -> A(t), M(m).
+// :outputs: threadReachableM(M)
+threadReachableM(m) -> M(m).
+
+// ###
+// # Constraints
+// ###
+
+reachableAM(t,m) <- threadAM(t,m).
+reachableAM(t,n) <- reachableAM(t,m), MI(m,i), IM(i,n), !threadStartI(i).
+
+threadReachableM(m) <- reachableAM(_,m).
+
diff -Nur jchord/main/src/chord/analyses/thread/thrSenCICG.logic jchord/main/src/chord/analyses/thread/thrSenCICG.logic
--- jchord/main/src/chord/analyses/thread/thrSenCICG.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/thread/thrSenCICG.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,46 @@
+// Created by convert.py from ./src/chord/analyses/thread/thrSenCICG.dlog on 2015-04-20 13:08:42.319060
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: thrSenCICG-dlog
+
+// :domains: I
+// :domains: M
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: rootM(M)
+// :inputs: threadIM(I,M)
+// :inputs: threadStartI(I)
+// :inputs: IM(I,M)
+// :inputs: MI(M,I)
+
+// :outputs: thrSenRootM(M)
+thrSenRootM(m) -> M(m).
+// :outputs: thrSenReachableM(M)
+thrSenReachableM(m) -> M(m).
+// :outputs: thrSenIM(I,M)
+thrSenIM(i,m) -> I(i), M(m).
+// :outputs: thrSenMM(M,M)
+thrSenMM(m,n) -> M(m), M(n).
+
+// ###
+// # Constraints
+// ###
+
+thrSenRootM(m) <- rootM(m).
+thrSenRootM(m) <- threadIM(_,m).
+
+thrSenReachableM(m) <- thrSenRootM(m).
+thrSenReachableM(n) <- thrSenIM(_,n).
+
+thrSenIM(i,n) <- thrSenReachableM(m), MI(m,i), IM(i,n), !threadStartI(i).
+thrSenMM(m,n) <- thrSenIM(i,n), MI(m,i).
+
+
diff -Nur jchord/main/src/chord/analyses/thread/threadIM.logic jchord/main/src/chord/analyses/thread/threadIM.logic
--- jchord/main/src/chord/analyses/thread/threadIM.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/thread/threadIM.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,69 @@
+// Created by convert.py from ./src/chord/analyses/thread/threadIM.dlog on 2015-04-20 13:08:42.318107
+// # Copyright (c) 2008-2010, Intel Corporation.
+// # Copyright (c) 2006-2007, The Trustees of Stanford University.
+// # All rights reserved.
+// # Licensed under the terms of the New BSD License.
+
+// # Author: Mayur Naik (mhn@cs.stanford.edu)
+// :name: threadIM-dlog
+
+// :domains: M
+// :domains: V
+// :domains: H
+// :domains: Z
+// :domains: I
+// :domains: T
+
+
+// ###
+// # Relations
+// ###
+
+// :inputs: IinvkArg(I0,Z0,V1)
+// :inputs: cha(M1,T1,M0)
+// :inputs: VH(V,H)
+// :inputs: HT(H0,T1)
+// :inputs: threadAllocI(I)
+// :inputs: threadStartI(I)
+// :inputs: excludeThreadStartI(I)
+
+// convert.py: following intermediate relation converted to output relation
+// :outputs: runCHA(H,M)
+runCHA(h,m) -> H(h), M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: threadRunM(M)
+threadRunM(m) -> M(m).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: threadAllocIH0(I,H)
+threadAllocIH0(i,h) -> I(i), H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: threadAllocIH1(I,H)
+threadAllocIH1(i,h) -> I(i), H(h).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: threadStartIH0(I,H)
+threadStartIH0(i,h) -> I(i), H(h).
+
+// :outputs: threadIM(I,M)
+threadIM(i,m) -> I(i), M(m).
+// :outputs: nonMainThreadM(M)
+nonMainThreadM(m) -> M(m).
+
+// ###
+// # Constraints
+// ###
+
+//runCHA(h,n) <- cha("run:()V@java.lang.Runnable",t,n), HT(h,t).
+runCHA(h,n) <- cha(m,t,n), HT(h,t), M_string[m] = "run:()V@java.lang.Runnable".
+
+//threadRunM("run:()V@java.lang.Thread").
+threadRunM(m) <- M_string[m] = "run:()V@java.lang.Thread".
+
+threadAllocIH0(i,h) <- threadAllocI(i), IinvkArg(i,z0,v), Z_index[z0] = 0, VH(v,h).
+threadAllocIH1(i,h) <- threadAllocI(i), IinvkArg(i,z1,v), Z_index[z1] = 1, VH(v,h).
+threadAllocIH1(i,h) <- threadAllocI(i), IinvkArg(i,z2,v), Z_index[z2] = 2, VH(v,h).
+threadStartIH0(i,h) <- threadStartI(i), IinvkArg(i,z0,v), Z_index[z0] = 0, VH(v,h), !excludeThreadStartI(i).
+
+threadIM(i,m) <- threadStartIH0(i,h), runCHA(h,m), !threadRunM(m).
+threadIM(i,n) <- threadStartIH0(i,h), runCHA(h,m), threadRunM(m), threadAllocIH0(i2,h), threadAllocIH1(i2,h2), runCHA(h2,n).
+nonMainThreadM(m) <- threadIM(_,m).
+
diff -Nur jchord/main/src/chord/analyses/typestate/TypeStateAnalysis.java jchord/main/src/chord/analyses/typestate/TypeStateAnalysis.java
--- jchord/main/src/chord/analyses/typestate/TypeStateAnalysis.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/analyses/typestate/TypeStateAnalysis.java	2015-11-02 22:26:25.000000000 -0800
@@ -67,6 +67,7 @@
  * 4. Whether use of may-bit is enabled or not in the analysis
  *    chord.typestate.usemaybit (default value: true)
  */
+
 @Chord(name = "typestate-java",
 consumes = {"modMF", "sub", "checkExcludedT", "checkIncludedI"}
 )
diff -Nur jchord/main/src/chord/analyses/typestate/modMF.logic jchord/main/src/chord/analyses/typestate/modMF.logic
--- jchord/main/src/chord/analyses/typestate/modMF.logic	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/analyses/typestate/modMF.logic	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,37 @@
+// Created by convert.py from ./src/chord/analyses/typestate/modMF.dlog on 2015-04-20 13:08:42.319717
+// :name: modMF-dlog
+
+// :domains: M
+// :domains: E
+// :domains: F
+// :domains: I
+
+
+// :inputs: writeE(E)
+// :inputs: instF(F)
+// :inputs: ME(M,E)
+// :inputs: MI(M,I)
+// :inputs: IM(I,M)
+// :inputs: EF(E,F)
+// convert.py: following intermediate relation converted to output relation
+// :outputs: reachMM(M,M)
+reachMM(m1,m2) -> M(m1), M(m2).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: callsMM(M,M)
+callsMM(m1,m2) -> M(m1), M(m2).
+// convert.py: following intermediate relation converted to output relation
+// :outputs: writeEF(E,F)
+writeEF(e,f) -> E(e), F(f).
+
+// # relation containing each (m,f) such that f is an instance field (cannot be array element or static field)
+// # and some method reachable from m writes to f
+// :outputs: modMF(M,F)
+modMF(m,f) -> M(m), F(f).
+
+callsMM(m1,m2) <- MI(m1,i), IM(i,m2).
+reachMM(m,m2) <- m=m2.
+reachMM(m,m3) <- reachMM(m,m2), callsMM(m2,m3). 
+
+writeEF(e,f) <- writeE(e), EF(e,f), instF(f).
+modMF(m,f) <- reachMM(m,m2), ME(m2,e), writeEF(e,f).
+
diff -Nur jchord/main/src/chord/bddbddb/BDDBDDBParser.java jchord/main/src/chord/bddbddb/BDDBDDBParser.java
--- jchord/main/src/chord/bddbddb/BDDBDDBParser.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/bddbddb/BDDBDDBParser.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,280 @@
+package chord.bddbddb;
+
+import gnu.trove.list.array.TIntArrayList;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import chord.core.DatalogMetadata;
+import chord.core.IDatalogParser;
+import chord.project.Messages;
+import chord.util.Utils;
+
+/**
+ * Parser for <a href="http://bddbddb.sourceforge.net/"><tt>bddbddb</tt></a>-style Datalog files.  
+ * 
+ * Most of this code is adapted from the original <tt>DlogAnalysis</tt> 
+ * implementation.
+ */
+public class BDDBDDBParser implements IDatalogParser {
+    
+    /**
+     * Temporary state during a call to {@link BDDBDDBParser#parseMetadata(File)}.
+     */
+    private static class ParserState {
+        DatalogMetadata meta = new DatalogMetadata();
+
+        Set<String> majorDomNames = new HashSet<String>();
+        Map<String, RelSign> consumedRels = new HashMap<String, RelSign>();
+        Map<String, RelSign> producedRels = new HashMap<String, RelSign>();
+        List<String> minorDomNames = new ArrayList<String>();
+
+        String order;
+        String fileName;
+        int lineNum;
+        
+        ParserState(File file) {
+            fileName = file.getPath();
+            meta.setFileName(fileName);
+        }
+
+        void error(String errMsg) {
+            Messages.log("ERROR: DlogAnalysis: " + fileName + ": line " + lineNum + ": " + errMsg);
+            meta.setHasNoErrors(false);
+        }
+        
+        /**
+         * Sets all the temporary state onto the metadata and returns it.
+         * @return
+         */
+        DatalogMetadata finish() {
+            meta.setConsumedRels(consumedRels);
+            meta.setProducedRels(producedRels);
+            meta.setMajorDomNames(majorDomNames);
+            meta.setMinorDomNames(minorDomNames);
+            meta.setBddOrder(order);
+            return meta;
+        }
+    }
+
+    public BDDBDDBParser() {
+    }
+    
+    /**
+     * Parses the Datalog analysis in the specified file.
+     * 
+     * @param    fileName A file containing a Datalog analysis.
+     * 
+     * @return    true iff the Datalog analysis parses successfully.
+     */
+    @SuppressWarnings("resource") // closed by Utils.close in finally block
+    public DatalogMetadata parseMetadata(File file) throws IOException {
+        ParserState state = new ParserState(file);
+        
+        Set<String> majorDomNames = state.majorDomNames;
+        Map<String, RelSign> consumedRels = state.consumedRels;
+        Map<String, RelSign> producedRels = state.producedRels;
+        List<String> minorDomNames = state.minorDomNames;
+        BufferedReader in = null;
+        try {
+            in = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
+            
+            Pattern p = Pattern.compile("(\\w)+\\((\\w)+:(\\w)+(,(\\w)+:(\\w)+)*\\)((input)|(output))");
+            for (state.lineNum = 1; true; state.lineNum++) {
+                String s;
+                s = in.readLine();
+                if (s == null)
+                    break;
+                if (s.startsWith("#")) {
+                    if (s.startsWith("# name=")) {
+                        if (state.meta.getDlogName() == null)
+                            state.meta.setDlogName(s.trim().substring(7));
+                        else
+                            state.error("Name redeclared via # name=...");
+                    }
+                    continue;
+                }
+                int k = s.indexOf('#');
+                if (k != -1) s = s.substring(0, k);
+                s = s.trim();
+                if (s.length() == 0)
+                     continue;
+                // strip all whitespaces from line
+                StringBuffer t = new StringBuffer(s.length());
+                for (int i = 0; i < s.length(); i++) {
+                    char c = s.charAt(i);
+                    if (!Character.isWhitespace(c))
+                        t.append(c);
+                }
+                s = t.toString();
+                if (s.startsWith(".bddvarorder")) {
+                    if (state.order != null) {
+                        state.error(".bddvarorder redefined.");
+                        continue;
+                    }
+                    state.order = s.substring(12);
+                    String[] a = state.order.split("_|x");
+                    for (String minorDomName : a) {
+                        if (minorDomNames.contains(minorDomName)) {
+                            state.error("Domain name '" + minorDomName + "' occurs multiple times in .bddvarorder; " +
+                                "considering first occurrence.");
+                        } else {
+                            minorDomNames.add(minorDomName);
+                            String majorDomName = Utils.trimNumSuffix(minorDomName);
+                            majorDomNames.add(majorDomName);
+                        }
+                    }
+                    continue;
+                }
+                Matcher m = p.matcher(s);
+                if (!m.matches())
+                    continue;
+                if (state.order == null) {
+                    state.error(".bddvarorder not defined before first relation declared");
+                    return state.finish();
+                }
+                int i = s.indexOf('(');
+                String relName = s.substring(0, i);
+                if (consumedRels.containsKey(relName)) {
+                    state.error("Relation '" + relName + "' redeclared");
+                    continue;
+                }
+                if (producedRels.containsKey(relName)) {
+                    state.error("Relation '" + relName + "' redeclared");
+                    continue;
+                }
+                s = s.substring(i + 1);
+                boolean done = false;
+                boolean ignore = false;
+                List<String> relMinorDomNames = new ArrayList<String>();
+                List<String> relMajorDomNames = new ArrayList<String>();
+                TIntArrayList indices = new TIntArrayList();
+                while (!done) {
+                    i = s.indexOf(':');
+                    assert (i != -1);
+                    s = s.substring(i + 1);
+                    i = s.indexOf(',');
+                    if (i == -1) {
+                        i = s.indexOf(')');
+                        assert (i != -1);
+                        done = true;
+                    }
+                    String domName = s.substring(0, i);
+                    String minorDomName;
+                    String majorDomName;
+                    int index;
+                    if (!Character.isDigit(domName.charAt(i - 1))) {
+                        majorDomName = domName;
+                        index = 0;
+                        int num = indices.size();
+                        while (true) {
+                            int j = 0;
+                            for (String majorDomName2 : relMajorDomNames) {
+                                if (majorDomName2.equals(majorDomName) &&
+                                        indices.get(j) == index) {
+                                    index++;
+                                    break;
+                                }
+                                j++;
+                            }
+                            if (j == num)
+                                break;
+                        }
+                        minorDomName = majorDomName + Integer.toString(index);
+                    } else {
+                        minorDomName = domName;
+                        int j = i - 1;
+                        while (true) {
+                            char c = domName.charAt(j);
+                            if (Character.isDigit(c))
+                                j--;
+                            else
+                                break;
+                        }
+                        majorDomName = domName.substring(0, j + 1);
+                        index = Integer.parseInt(domName.substring(j + 1, i));
+                    }
+                    if (relMinorDomNames.contains(minorDomName)) {
+                        state.error("Domain name '" + minorDomName + "' occurs multiple times in declaration of " +
+                            "relation '" + relName + "'");
+                        ignore = true;
+                    } else if (!minorDomNames.contains(minorDomName)) {
+                        state.error("Domain name '" + domName + "' in declaration of relation '" + relName +
+                            "' does not occur in .bddvarorder");
+                        ignore = true;
+                    } else {
+                        relMinorDomNames.add(minorDomName);
+                        relMajorDomNames.add(majorDomName);
+                        indices.add(index);
+                    }
+                    s = s.substring(i + 1);
+                }
+                if (ignore)
+                    continue;
+                int numDoms = relMinorDomNames.size();
+                String[] domNames = new String[numDoms];
+                String domOrder = getSubOrder(relMinorDomNames, state);
+                for (int j = 0; j < numDoms; j++)
+                    domNames[j] = relMinorDomNames.get(j);
+                Map<String, RelSign> map = null;
+                if (s.equals("input"))
+                    map = consumedRels;
+                else if (s.equals("output"))
+                    map = producedRels;
+                else
+                    assert false; 
+                RelSign relSign;
+                try {
+                    relSign = new RelSign(domNames, domOrder);
+                } catch (RuntimeException ex) {
+                    state.error(ex.getMessage());
+                    continue;
+                }
+                map.put(relName, relSign);
+            }
+            
+            return state.finish();
+
+        } catch (IOException ex) {
+            Messages.log(ex.getMessage());
+            throw ex;
+        } finally {
+            Utils.close(in);
+        }
+    }
+    
+    private String getSubOrder(List<String> relMinorDomNames, ParserState state) {
+        String order = state.order;
+        int orderLen = order.length();
+        String subOrder = null;
+        char lastSep = ' ';
+        int i = 0;
+        for (String domName : state.minorDomNames) {
+            i += domName.length();
+            if (relMinorDomNames.contains(domName)) {
+                if (subOrder == null)
+                    subOrder = domName;
+                else
+                    subOrder = subOrder + lastSep + domName;
+                if (i != orderLen)
+                    lastSep = order.charAt(i);
+            } else {
+                if (i != orderLen && order.charAt(i) == '_')
+                    lastSep = '_';
+            }
+            i++;
+        }
+        return subOrder;
+    }
+}
diff -Nur jchord/main/src/chord/bddbddb/Dom.java jchord/main/src/chord/bddbddb/Dom.java
--- jchord/main/src/chord/bddbddb/Dom.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/bddbddb/Dom.java	2015-11-02 22:26:25.000000000 -0800
@@ -1,5 +1,11 @@
 package chord.bddbddb;
 
+import java.io.File;
+import java.io.IOException;
+import java.io.PrintStream;
+import java.io.PrintWriter;
+
+import chord.logicblox.LogicBloxExporter;
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import java.io.File;
@@ -16,7 +22,8 @@
  * <li> The domain is next built in memory by repeatedly calling {@link #getOrAdd(Object)} with the argument in each call being a value
  * to be added to the domain.  If the value already exists in the domain then the call does not have any effect.  Otherwise, the value
  * is mapped to integer K in the domain where K is the number of values already in the domain. </li>
- * <li> The domain built in memory is reflected onto disk by calling {@link #save(String,boolean)}. </li>
+ * <li> The domain built in memory is reflected onto disk by calling either 
+ *     {@link #saveToBDD(String,boolean)} or {@link #saveToLogicBlox(String)}. </li>
  * <li> The domain on disk can be read by a Datalog program. </li>
  * <li> The domain in memory can be read by calling any of the following:
  * <ul>
@@ -41,17 +48,18 @@
     public String getName() {
         return name;
     }
+    
     /**
      * Reflects the domain in memory onto disk.
      */
-    public void save(String dirName, boolean saveDomMap) throws IOException {
+    public void saveToBDD(String dirName, boolean saveDomMap) throws IOException {
         String mapFileName = "";
         if (saveDomMap) {
             mapFileName = name + ".map";
             File file = new File(dirName, mapFileName);
             PrintWriter out = new PrintWriter(file);
             int size = size();
-                for (int i = 0; i < size; i++) {
+            for (int i = 0; i < size; i++) {
                 T val = get(i);
                 out.println(toUniqueString(val));
             }
@@ -64,6 +72,21 @@
         out.println(name + " " + size + " " + mapFileName);
         out.close();
     }
+    
+    /**
+     *  Saves this domain in a format suitable for loading into LogicBlox.
+     *  For a domain named <tt>N</tt>, two files will be created in <tt>chord.logicblox.work.dir</tt>: 
+     *  <tt>N.type</tt>, which contains predicate definitions and <tt>N.csv</tt>, which 
+     *  contains <tt>chord.logicblox.delim</tt>-delimited (index, string) pairs.
+     *  
+     *  @throws ChordException if an error occurs
+     */
+    public void saveToLogicBlox(String dirName) {
+        LogicBloxExporter exporter = new LogicBloxExporter();
+        exporter.setWorkDir(dirName);
+        exporter.saveDomain(this);
+    }
+    
     // subclasses may override
     public String toUniqueString(T val) {
         return val == null ? "null" : val.toString();
diff -Nur jchord/main/src/chord/bddbddb/Rel.java jchord/main/src/chord/bddbddb/Rel.java
--- jchord/main/src/chord/bddbddb/Rel.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/bddbddb/Rel.java	2015-11-02 22:26:25.000000000 -0800
@@ -4,10 +4,10 @@
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileReader;
-import java.io.PrintWriter;
-import java.io.PrintStream;
 import java.io.FileWriter;
 import java.io.IOException;
+import java.io.PrintStream;
+import java.io.PrintWriter;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.LinkedList;
@@ -24,6 +24,20 @@
 import net.sf.javabdd.BDDDomain;
 import net.sf.javabdd.BDDException;
 import net.sf.javabdd.BDDFactory;
+import chord.logicblox.LogicBloxExporter;
+import chord.logicblox.LogicBloxImporter;
+import chord.project.ChordException;
+import chord.project.Config;
+import chord.util.tuple.integer.IntHext;
+import chord.util.tuple.integer.IntPair;
+import chord.util.tuple.integer.IntPent;
+import chord.util.tuple.integer.IntQuad;
+import chord.util.tuple.integer.IntTrio;
+import chord.util.tuple.object.Hext;
+import chord.util.tuple.object.Pair;
+import chord.util.tuple.object.Pent;
+import chord.util.tuple.object.Quad;
+import chord.util.tuple.object.Trio;
 
 /**
  * Generic implementation of a BDD-based relation.
@@ -50,7 +64,7 @@
  *       </ul>
  *   </li>
  *   <li>
- *    The relation built in memory is reflected onto disk by calling {@link #save(String)}, which also
+ *    The relation built in memory is reflected onto disk by calling {@link #saveToBDD(String)}, which also
  *       removes the relation from memory (i.e., BDDs allocated for the relation in memory are freed).
  *   </li>
  *   <li>
@@ -228,10 +242,11 @@
         initialize();
         bdd = factory.zero();
     }
+    
     /**
      * Copies this relation from disk to memory.
      */
-    public void load(String dirName) {
+    public void loadFromBDDBDDB(String dirName) {
         initialize();
         try {
             File file = new File(dirName, name + ".bdd");
@@ -279,6 +294,14 @@
             throw new RuntimeException(ex);
         }
     }
+    
+    public void loadFromLogicBlox(String workspace) {
+        initialize();
+        LogicBloxImporter importer = new LogicBloxImporter();
+        importer.setWorkspace(workspace);
+        importer.importRelation(this);
+    }
+    
     /**
      * Frees this relation from memory.
      */
@@ -288,10 +311,11 @@
         factory.done();
         bdd = null;
     }
+    
     /**
      * Copies the relation from memory to disk and frees it from memory.
      */
-    public void save(String dirName) {
+    public void saveToBDD(String dirName) {
         if (bdd == null)
             throw new RuntimeException("");
         try {
@@ -314,6 +338,20 @@
         }
         close();
     }
+    
+    /**
+     * Saves the relation to disk in LogicBlox format.
+     * 
+     * @param dirName the directory name
+     */
+    public void saveToLogicBlox(String dirName) {
+        if (bdd == null)
+            throw new ChordException("bdd not initialized");
+        LogicBloxExporter exporter = new LogicBloxExporter();
+        exporter.setWorkDir(dirName);
+        exporter.saveRelation(this);
+    }
+    
     public void print(String dirName) {
         if (bdd == null)
             throw new RuntimeException("");
@@ -652,24 +690,24 @@
     protected void checkRange(Object val, int domIdx) {
         int idx = doms[domIdx].indexOf(val);
         if (idx == -1)
-            throw new RuntimeException("Cannot find value '" + val +
+            throw new ChordException("Cannot find value '" + val +
                 "' in domain #" + domIdx + " named '" + doms[domIdx] +
                 "' in relation named '" + name + "'.");
         int size = doms[domIdx].size();
         if (idx >= size) {
-            throw new RuntimeException("Object " + val + " has out of range index " + idx +
+            throw new ChordException("Object " + val + " has out of range index " + idx +
                 " in domain #" + domIdx + " named '" + doms[domIdx] + "' of size " + size +
                 " in relation named '" + name + "'.");
         }
     }
     protected void checkRange(int idx, int domIdx) {
         if (idx == -1)
-            throw new RuntimeException("Cannot find value" +
+            throw new ChordException("Cannot find value" +
                 " in domain #" + domIdx + " named '" + doms[domIdx] +
                 "' in relation named '" + name + "'.");
         int size = doms[domIdx].size();
         if (idx >= size) {
-            throw new RuntimeException("Value has out of range index " + idx +
+            throw new ChordException("Value has out of range index " + idx +
                 " in domain #" + domIdx + " named '" + doms[domIdx] + "' of size " + size +
                 " in relation named '" + name + "'.");
         }
@@ -1941,18 +1979,67 @@
     public void add(Object[] vals) {
         if (bdd == null)
             throw new RuntimeException("");
-        throw new UnsupportedOperationException();
+        if (vals == null) throw new NullPointerException("vals is null");
+        int size = vals.length;
+        int[] indexes = new int[size];
+        for (int i = 0; i < size; ++i)
+            indexes[i] = doms[i].indexOf(vals[i]);
+        add(indexes);
     }
+    
     public void add(int[] idxs) {
         if (bdd == null)
             throw new RuntimeException("");
-        throw new UnsupportedOperationException();
+        if (idxs == null) throw new NullPointerException("idxs is null");
+        int size = idxs.length;
+        if (size < 1) throw new IllegalArgumentException("Invalid size: " + size);
+        switch (size) {
+        // delegate to unrolled instances if possible
+        case 1: add(idxs[0]); break;
+        case 2: add(idxs[0], idxs[1]); break;
+        case 3: add(idxs[0], idxs[1], idxs[2]); break;
+        case 4: add(idxs[0], idxs[1], idxs[2], idxs[3]); break;
+        case 5: add(idxs[0], idxs[1], idxs[2], idxs[3], idxs[4]); break;
+        case 6: add(idxs[0], idxs[1], idxs[2], idxs[3], idxs[4], idxs[5]); break;
+        default:
+            try {
+                BDD tmp = domBdds[0].ithVar(idxs[0]);
+                for (int i = 1; i < size; ++i) {
+                    tmp = tmp.andWith(domBdds[i].ithVar(i));
+                }
+                bdd.orWith(tmp);
+            } catch (BDDException e) {
+                for (int i = 0; i < size; ++i)
+                    checkRange(idxs[i], i);
+                throw new ChordException(e);
+            }
+        }
     }
+    
     public boolean contains(Object[] vals) {
         if (bdd == null)
             throw new RuntimeException("");
-        throw new UnsupportedOperationException();
+        if (vals == null) throw new NullPointerException("vals is null");
+        
+        final int size = vals.length;
+        switch (size) {
+        case 0: throw new ChordException("vals must have at least one element.");
+        // delegate to unrolled versions if possible
+        case 1: return contains(vals[0]);
+        case 2: return contains(vals[0], vals[1]);
+        case 3: return contains(vals[0], vals[1], vals[2]);
+        case 4: return contains(vals[0], vals[1], vals[2], vals[3]);
+        case 5: return contains(vals[0], vals[1], vals[2], vals[3], vals[4]);
+        case 6: return contains(vals[0], vals[1], vals[2], vals[3], vals[4], vals[5]);
+        default:
+            BDD tmp = domBdds[0].ithVar(doms[0].indexOf(vals[0]));
+            for (int i = 1; i < size; ++i) {
+                tmp = tmp.andWith(domBdds[i].ithVar(doms[i].indexOf(vals[i])));
+            }
+            return !bdd.id().andWith(tmp).isZero();
+        }
     }
+    
     public AryNIterable getAryNValTuples() {
         if (bdd == null)
             throw new RuntimeException("");
diff -Nur jchord/main/src/chord/core/DatalogMetadata.java jchord/main/src/chord/core/DatalogMetadata.java
--- jchord/main/src/chord/core/DatalogMetadata.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/core/DatalogMetadata.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,97 @@
+package chord.core;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import chord.bddbddb.RelSign;
+
+/**
+ * A simple container for Datalog analysis metadata.  This data 
+ * could be produced from either BDD or LogicBlox style of files.
+ */
+public class DatalogMetadata {
+    // absolute filename of the datalog program
+    private String fileName;
+    private Set<String> domNames;
+    private Map<String, RelSign> consumedRels;
+    private Map<String, RelSign> producedRels;
+    private String dlogName;
+    private List<String> minorDomNames;
+    
+    /** The BDD variable order, not applicable for LogicBlox. */
+    private String bddOrder;
+    
+    private boolean hasNoErrors = true;
+
+    public DatalogMetadata() {
+    }
+
+    public String getFileName() {
+        return fileName;
+    }
+
+    public void setFileName(String fileName) {
+        this.fileName = fileName;
+    }
+
+    public Set<String> getMajorDomNames() {
+        return domNames;
+    }
+
+    public void setMajorDomNames(Set<String> majorDomNames) {
+        this.domNames = majorDomNames;
+    }
+
+    public Map<String, RelSign> getConsumedRels() {
+        return consumedRels;
+    }
+
+    public void setConsumedRels(Map<String, RelSign> consumedRels) {
+        this.consumedRels = consumedRels;
+    }
+
+    public Map<String, RelSign> getProducedRels() {
+        return producedRels;
+    }
+
+    public void setProducedRels(Map<String, RelSign> producedRels) {
+        this.producedRels = producedRels;
+    }
+
+    public String getDlogName() {
+        return dlogName;
+    }
+
+    public void setDlogName(String dlogName) {
+        this.dlogName = dlogName;
+    }    
+    
+    public void setHasNoErrors(boolean hasNoErrors) {
+        this.hasNoErrors = hasNoErrors;
+    }
+    
+    public boolean hasNoErrors() { return hasNoErrors; }
+    
+    public void setMinorDomNames(List<String> minorDomNames) {
+        this.minorDomNames = minorDomNames;
+    }
+    
+    public List<String> getMinorDomNames() {
+        return minorDomNames;
+    }
+    
+    /**
+     * Returns the BDD variable order.  This returns <code>null</code> for 
+     * if this is produced for LogicBlox.
+     * @return
+     */
+    public String getBddOrder() {
+        return bddOrder;
+    }
+    
+    public void setBddOrder(String bddOrder) {
+        this.bddOrder = bddOrder;
+    }
+
+}
diff -Nur jchord/main/src/chord/core/IDatalogParser.java jchord/main/src/chord/core/IDatalogParser.java
--- jchord/main/src/chord/core/IDatalogParser.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/core/IDatalogParser.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,19 @@
+package chord.core;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * An interface for classes that parse metadata from 
+ * specific variants of Datalog.
+ */
+public interface IDatalogParser {
+    /**
+     * Parses a datalog file and returns the extracted metadata.
+     * 
+     * @param file the file to parse, must exist and be readable
+     * @return the extracted metadata
+     * @throws IOException if there is a problem reading the file
+     */
+    public DatalogMetadata parseMetadata(File file) throws IOException;
+}
diff -Nur jchord/main/src/chord/logicblox/LogicBloxExporter.java jchord/main/src/chord/logicblox/LogicBloxExporter.java
--- jchord/main/src/chord/logicblox/LogicBloxExporter.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/logicblox/LogicBloxExporter.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,314 @@
+package chord.logicblox;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.PrintWriter;
+
+import chord.bddbddb.Dom;
+import chord.bddbddb.Rel;
+import chord.project.ChordException;
+import chord.project.Config;
+import chord.project.Config.DatalogEngineType;
+import chord.util.Utils;
+
+/**
+ * A class for exporting domains and relations to LogicBlox in a generic way. 
+ *
+ * @author Jake Cobb <tt>&lt;jake.cobb@gatech.edu&gt;</tt>
+ */
+public class LogicBloxExporter extends LogicBloxIOBase {
+    // configuration variables
+    private String delim = Config.logicbloxInputDelim;
+    private String workDir = Config.logicbloxWorkDirName;
+    
+    public LogicBloxExporter() {
+        super();
+    }
+    
+    public LogicBloxExporter(DatalogEngineType engineType) {
+        super(engineType);
+    }
+    
+    /**
+     * Saves the given domain to file and loads it into the LB workspace.
+     * 
+     * @param dom the domain to save
+     * @throws ChordException if an error occurs
+     */
+    public void saveDomain(Dom<?> dom) {
+        String domName = dom.getName();
+        File factsFile = new File(workDir, domName + ".csv");
+        saveDomainData(dom, factsFile);
+        
+        File typeFile = new File(workDir, domName + ".type");
+        saveDomainType(dom, typeFile);
+        
+        File importFile = new File(workDir, domName + ".import");
+        saveDomainImport(dom, importFile, factsFile);
+        
+        LogicBloxUtils.addBlock(typeFile);
+        LogicBloxUtils.execFile(importFile);   
+    }
+    
+    /**
+     * Saves a given relation to file and loads it into the LB workspace.
+     * 
+     * @param relation the relation to save
+     */
+    public void saveRelation(Rel relation) {
+        String relName = relation.getName();
+        File factsFile = new File(workDir, relName + ".csv");
+        saveRelationData(relation, factsFile);
+        
+        File typeFile = new File(workDir, relName + ".type");
+        saveRelationType(relation, typeFile);
+        
+        File importFile = new File(workDir, relName + ".import");
+        saveRelationImport(relation, importFile, factsFile);
+        
+        LogicBloxUtils.addBlock(typeFile);
+        LogicBloxUtils.execFile(importFile);
+    }
+    
+    /**
+     * Writes domain data to a delimited file suitable for import.  
+     * Data is written as pairs of (index, unique-string).
+     * 
+     * @param dom        the domain to save
+     * @param factsFile  the destination file
+     * @throws ChordException if an error occurs saving the data
+     */
+    private void saveDomainData(Dom<?> dom, File factsFile) {
+        final String DELIM = this.delim;
+        PrintWriter out = createPrintWriter(factsFile);
+        for (int i = 0, size = dom.size(); i < size; ++i) {
+            out.print(i);
+            out.print(DELIM);
+            out.println(dom.toUniqueString(i));
+        }
+        Utils.close(out);
+        if (out.checkError()) {
+            throw new ChordException("Error writing " + dom.getName() 
+                + " domain facts to " + factsFile.getAbsolutePath());
+        }
+    }
+    
+    private PrintWriter createPrintWriter(File outFile) { return createPrintWriter(outFile, false); }
+    private PrintWriter createPrintWriter(File outFile, boolean autoFlush) {
+        try {
+            return new PrintWriter(new OutputStreamWriter(new FileOutputStream(outFile), "UTF-8"), autoFlush);
+        } catch (IOException e) {
+            throw new ChordException(e);
+        }
+    }
+    
+    /**
+     * Saves the domain's type declaration to file.
+     * 
+     * @param dom       the domain
+     * @param typeFile  the output file
+     * @throws ChordException if an error occurs writing the file
+     */
+    private void saveDomainType(Dom<?> dom, File typeFile) {
+        String name    = dom.getName();
+
+        // a new entity type with ref-mode of index
+        StringBuilder type = new StringBuilder(name).append("(x), ")
+            .append(name).append("_index(x:index) -> ").append(getIntType()).append("(index).\n");
+        
+        // and a map to the string representation
+        type.append(name).append("_string[x] = s -> ").append(name).append("(x), string(s).\n");
+        
+        if (isLB3()) {
+            // have to make scalable, values other than ScalableSparse are not
+            // documented
+            type.append("lang:physical:storageModel[`").append(name)
+                .append("] = \"ScalableSparse\".\n")
+                .append("lang:physical:capacity[`").append(name).append("] = ")
+                .append(dom.size()).append(".\n");
+        }
+        
+        PrintWriter out = createPrintWriter(typeFile, true);
+        out.println(type.toString());
+        Utils.close(out);
+        if (out.checkError()) {
+            throw new ChordException("Error writing " + name + " domain type to " 
+                + typeFile.getAbsolutePath());
+        }
+    }
+
+    
+    /**
+     * Saves import declarations for a domain.
+     * 
+     * @param dom         the domain to import
+     * @param importFile  the output file
+     * @param factsFile   the delimited data file that will be imported
+     * @throws ChordException if an error occurs writing the file
+     */
+    private void saveDomainImport(Dom<?> dom, File importFile, File factsFile) {
+        String name = dom.getName();
+        PrintWriter out = createPrintWriter(importFile);
+        out.println(createImportRelation("id, val",  getIntType() + "(id), string(val)", factsFile));
+        out.println();
+        out.println("+" + name + "(x), +" + name + "_index[x] = id, +" + name + "_string[x] = val <- _in(" + 
+                (isLB3() ? "" : "_; ") + "id, val).");
+        Utils.close(out);
+        if (out.checkError()) {
+            throw new ChordException("An error occurred writing import declaration of domain " 
+                + name + " to " + importFile.getAbsolutePath());
+        }
+    }
+    
+    /**
+     * Creates the type signature for <code>relation</code> and saves it 
+     * to <code>typeFile</code>.
+     * 
+     * @param relation the relation to save
+     * @param typeFile the output file
+     * @throws ChordException if an error occurs writing the file
+     */
+    private void saveRelationType(Rel relation, File typeFile) {
+        String relName           = relation.getName();
+        String domainConstraints = getDomainConstraints(relation);
+        String domainVars        = getRelationVariablesList(relation);
+        
+        PrintWriter out = createPrintWriter(typeFile, true);
+        out.println(relName + "(" + domainVars + ") -> " + domainConstraints + ".");
+        Utils.close(out);
+        if (out.checkError()) {
+            throw new ChordException("An error occurred writing relation type for " + 
+                relName + " to " + typeFile.getAbsolutePath());
+        }
+    }
+    
+    /**
+     * Saves relation data to a delimited file suitable for use by 
+     * the LB file-predicate import mechanism.
+     *  
+     * @param relation      the relation data to export
+     * @param destination   the output file
+     * @throws ChordException if an error occurs writing the file
+     */
+    private void saveRelationData(Rel relation, File destination) {
+        final String DELIM = this.delim;
+        PrintWriter out = createPrintWriter(destination);
+
+        StringBuilder sb = new StringBuilder();
+        for (int[] row: relation.getAryNIntTuples()) {
+            sb.setLength(0);
+            for (int col: row)
+                sb.append(col).append(DELIM);
+            sb.setLength(sb.length() - DELIM.length()); // remove trailing delim
+            out.println(sb.toString());
+        }
+        
+        out.flush();
+        Utils.close(out);
+        if (out.checkError()) {
+            throw new ChordException("An error occurred writing relation " + 
+                relation.getName() + " data to " + destination.getAbsolutePath());
+        }
+    }
+    
+    /**
+     * Saves a set of import commands suitable for use with <tt>lb exec</tt> to 
+     * import the relation data into the LB workspace.
+     * 
+     * @param relation    the relation to import
+     * @param importFile  the output file
+     * @param factsFile   the delimited file containing the actual data
+     * @throws ChordException if an error occurs writing the file
+     */
+    private void saveRelationImport(Rel relation, File importFile, File factsFile) {
+        Dom<?>[] doms            = relation.getDoms();
+        String relName           = relation.getName();
+        String domainVars        = getRelationVariablesList(relation);
+        boolean isLB3 = isLB3();
+        
+        PrintWriter out = createPrintWriter(importFile);
+        String idList = makeVarList("id", doms.length);
+        String intType = getIntType();
+        
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0, size = doms.length; i < size; ++i)
+            sb.append(intType).append("(id").append(i).append("),");
+        sb.setLength(sb.length() - 1);
+        String idConstraints = sb.toString();
+        
+        out.println(createImportRelation(idList, idConstraints, factsFile));
+        
+        sb = new StringBuilder("+");
+        sb.append(relName).append('(').append(domainVars).append(") <- _in(");
+        if (!isLB3)
+            sb.append("_; ");
+        sb.append(idList);
+        sb.append("), ");
+        for (int i = 0, size = doms.length; i < size; ++i) {
+            Dom<?> dom = doms[i];
+            String domName = dom.getName();
+            sb.append(domName).append("_index[d").append(i).append("] = id").append(i).append(',');
+        }
+        sb.setLength(sb.length() - 1);
+        sb.append(".\n");
+        out.println(sb.toString());
+        
+        Utils.close(out);
+        if (out.checkError()) {
+            throw new ChordException("There as an error writing the import command for " 
+                + relName + " to " + importFile.getAbsolutePath());
+        }
+    }
+    
+    /**
+     * Builds the import relation definitions used to import delimited-file data to LogicBlox.
+     * <p>
+     * This declares a predicate <code>_in</code> using the variable list and type constraints 
+     * given.  It also handles LB 3 vs LB 4 differences and various <code>lang:physical:*</code> 
+     * declarations that are required.
+     * <p>
+     * For example, use <code>varList</code> = "v1, v2" and <code>typeConstraints</code> = 
+     * "int(v1), string(v2)".  
+     * 
+     * @param varList           the list of input predicate variables
+     * @param typeConstraints   the type constraints of these variables
+     * @param factsFile         the delimited file containing the data to import
+     * @return the import relation definitions
+     */
+    private String createImportRelation(String varList, String typeConstraints, File factsFile) {
+        StringBuilder sb = new StringBuilder("_in(");
+        final boolean isLB3 = isLB3();
+        if (!isLB3)
+            sb.append("offset; ");
+        sb.append(varList).append(") -> ");
+        if (!isLB3)
+            sb.append(getIntType()).append("(offset),");
+        sb.append(typeConstraints).append(".\n");
+        sb.append("lang:physical:filePath[`_in] = \"").append(factsFile.getAbsolutePath()).append("\".\n");
+        if (isLB3)
+            sb.append("lang:physical:storageModel[`_in] = \"DelimitedFile\".\n");
+        else
+            sb.append("lang:physical:fileMode[`_in] = \"import\".\n");
+        sb.append("lang:physical:delimiter[`_in] = \"").append(this.delim).append("\".\n");
+        return sb.toString();
+    }
+    
+    public String getDelim() {
+        return delim;
+    }
+
+    public void setDelim(String delim) {
+        this.delim = delim;
+    }
+
+    public String getWorkDir() {
+        return workDir;
+    }
+
+    public void setWorkDir(String workDir) {
+        this.workDir = workDir;
+    }
+    
+}
diff -Nur jchord/main/src/chord/logicblox/LogicBloxIOBase.java jchord/main/src/chord/logicblox/LogicBloxIOBase.java
--- jchord/main/src/chord/logicblox/LogicBloxIOBase.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/logicblox/LogicBloxIOBase.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,111 @@
+package chord.logicblox;
+
+import chord.bddbddb.Dom;
+import chord.bddbddb.Rel;
+import chord.project.Config;
+import chord.project.Config.DatalogEngineType;
+
+/**
+ * Convenience base class for {@link LogicBloxImporter} and {@link LogicBloxExporter}.
+ */
+public abstract class LogicBloxIOBase {
+
+    protected String workspace = Config.logicbloxWorkspace;
+    protected DatalogEngineType engineType;
+
+    public LogicBloxIOBase() {
+        this(Config.datalogEngine);
+    }
+    
+    public LogicBloxIOBase(DatalogEngineType engineType) {
+        setEngineType(engineType);
+    }
+
+    /**
+     * Builds the type constraints for the domains of a relation.
+     * 
+     * Return values look like:<br />
+     * <code>D0(d0), D1(d1), ...</code>
+     * 
+     * @param relation the relation to generate a type constraint string for
+     * @return the type constraints
+     */
+    protected String getDomainConstraints(Rel relation) {
+        StringBuilder sb = new StringBuilder();
+        Dom<?>[] doms = relation.getDoms();
+        for (int i = 0, size = doms.length; i < size; ++i) {
+            Dom<?> dom = doms[i];
+            sb.append(dom.getName()).append("(d").append(i).append("),");
+        }
+        sb.setLength(sb.length() - 1);
+        return sb.toString();
+    }
+
+    /**
+     * Creates a list of generic variables numbered from 0, e.g. 
+     * "v0, v1, ..." if <code>varPrefix</code> is "v".
+     * 
+     * @param varPrefix the variable prefix
+     * @param size      the length of the variable sequence
+     * @return the variable list
+     */
+    protected String makeVarList(String varPrefix, int size) {
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < size; ++i)
+            sb.append(varPrefix).append(i).append(',');
+        sb.setLength(sb.length() - 1);
+        return sb.toString();
+    }
+
+    /**
+     * Returns the variables for a generic relation, which is 
+     * of the form "d0, d1, ...".
+     * 
+     * @param relation the relation to generate the list for
+     * @return the variable list
+     */
+    protected String getRelationVariablesList(Rel relation) {
+        return makeVarList("d", relation.getDoms().length);
+    }
+
+    /**
+     * Returns the integer type depending on the LB version.
+     * @return the int type
+     */
+    protected String getIntType() {
+        return engineType == DatalogEngineType.LOGICBLOX3 ? "uint[64]" : "int";
+    }
+
+    protected boolean isLB3() { return engineType == DatalogEngineType.LOGICBLOX3; }
+
+    public String getWorkspace() {
+        return workspace;
+    }
+
+    public void setWorkspace(String workspace) {
+        this.workspace = workspace;
+    }
+
+    public DatalogEngineType getEngineType() {
+        return engineType;
+    }
+
+    /**
+     * Sets the engine type to use.
+     * 
+     * @param engineType the engine type
+     * @throws IllegalArgumentException if <code>engineType</code> is not a LogicBlox engine
+     */
+    public void setEngineType(DatalogEngineType engineType) {
+        if( engineType == null ) throw new NullPointerException("engineType is null");
+        switch (engineType) {
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            this.engineType = engineType;
+            break;
+        default:
+            throw new IllegalArgumentException("Not a LogicBlox engine type: " + engineType);
+        }
+    }
+
+}
\ No newline at end of file
diff -Nur jchord/main/src/chord/logicblox/LogicBloxImporter.java jchord/main/src/chord/logicblox/LogicBloxImporter.java
--- jchord/main/src/chord/logicblox/LogicBloxImporter.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/logicblox/LogicBloxImporter.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,108 @@
+package chord.logicblox;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.util.regex.Pattern;
+
+import chord.bddbddb.Dom;
+import chord.bddbddb.Rel;
+import chord.project.ChordException;
+import chord.project.Config;
+import chord.project.Config.DatalogEngineType;
+import chord.project.Messages;
+import chord.util.ProcessExecutor.StreamGobbler;
+import chord.util.Utils;
+
+/**
+ * An importer for loading data from a LogicBlox workspace.
+ * 
+ * @author Jake Cobb <tt>&lt;jake.cobb@gatech.edu&gt;</tt>
+ */
+public class LogicBloxImporter extends LogicBloxIOBase {
+    private static final Pattern rowOfIntsPattern = Pattern.compile("^\\d+(\\s+\\d+)*$");
+    
+    // lb query prints these around the results
+    private static final Pattern headerOrFooter = 
+        Pattern.compile("[/\\\\]--------------- _ ---------------[/\\\\]");
+
+    public LogicBloxImporter() {
+        super();
+    }
+    
+    public LogicBloxImporter(DatalogEngineType engineType) {
+        super(engineType);
+    }
+    
+    /**
+     * Imports a relation from the workspace.
+     * <p>
+     * The passed relation is emptied out and then populated by querying it's data 
+     * by name from the workspace.
+     * 
+     * @param relation the relation to load
+     * @throws ChordException if an error occurs loading the data
+     */
+    public void importRelation(Rel relation) {
+        if( relation == null ) throw new NullPointerException("relation is null");
+        relation.zero();
+        
+        String[] cmds = {Config.logicbloxCommand, "query", "--readonly", workspace, buildQuery(relation)};
+        try {
+            Process proc = Runtime.getRuntime().exec(cmds);
+            new StreamGobbler(proc.getErrorStream(), System.err).start();
+            Utils.close(proc.getOutputStream());
+            
+            BufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream(), "UTF-8"));
+            String line;
+            while (null != (line = reader.readLine())) {
+                line = line.trim();
+                if (!rowOfIntsPattern.matcher(line).matches()) {
+                    if (!headerOrFooter.matcher(line).matches())
+                        Messages.warn("Ignoring unexpected lb query line: %s", line);
+                    continue;
+                }
+                int[] indexes = parseIntRow(line);
+                relation.add(indexes);
+            }
+            Utils.close(reader);
+        } catch (IOException e) {
+            throw new ChordException(e);
+        }
+    }
+    
+    /**
+     * Builds the query for a relation.
+     * <p>
+     * By example, a relation VH(v,h) over domains V and H will generate the following query:<br />
+     * <code>_(id0, id1) &lt;- VH(d0, d1), V_index[d0] = id0, H_index[d1] = id1.</code>
+     * 
+     * @param relation the relation to query for
+     * @return the LB query string
+     */
+    private String buildQuery(Rel relation) {
+        Dom<?>[] doms = relation.getDoms();
+        StringBuilder sb = new StringBuilder();
+        
+        String idList  = makeVarList("id", doms.length);
+        String varList = getRelationVariablesList(relation);
+        sb.append("_(").append(idList).append(") <- ");
+        sb.append(relation.getName()).append('(').append(varList).append("), ");
+        for (int i = 0, size = doms.length; i < size; ++i) {
+            Dom<?> dom = doms[i];
+            sb.append(dom.getName()).append("_index[d").append(i).append("] = id").append(i).append(',');
+        }
+        sb.setCharAt(sb.length() - 1, '.');
+        
+        return sb.toString();
+    }
+    
+    private int[] parseIntRow(String line) {
+        String[] parts = line.split("\\s+");
+        int size = parts.length;
+        int[] result = new int[size];
+        for (int i = 0; i < size; ++i)
+            result[i] = Integer.parseInt(parts[i], 10);
+        return result;
+    }
+}
diff -Nur jchord/main/src/chord/logicblox/LogicBloxParser.java jchord/main/src/chord/logicblox/LogicBloxParser.java
--- jchord/main/src/chord/logicblox/LogicBloxParser.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/logicblox/LogicBloxParser.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,206 @@
+package chord.logicblox;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.UnsupportedEncodingException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Locale;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import chord.bddbddb.RelSign;
+import chord.core.DatalogMetadata;
+import chord.core.IDatalogParser;
+import chord.project.ChordException;
+import chord.project.Messages;
+import chord.util.Utils;
+
+/**
+ * A simple parser for LogiQL files.
+ * 
+ * <p>
+ * This does not implement the full LogiQL language.  
+ * We support specially formatted comments that hold metadata 
+ * which would be contained in the BDD versions of these files.
+ * <p>
+ * Domains are a comma separated list of names, for example:<br/>
+ * <tt>// :domains: A,B,C</tt>
+ * <p>
+ * Inputs and outputs are a comma separated list of signatures, each of 
+ * the form <i>Rel</i>(<i>Dom</i><sub>1</sub>, ..., <i>Dom</i><sub>n</sub>), 
+ * for example:<br />
+ * <tt> // :inputs: Foo(A,B), Bar(C)</tt><br />
+ * <tt> // :outputs: Baz(A,B,C)</tt>
+ * <p>
+ * The task name is given by:<br />
+ * <tt> // :name: taskname</tt>
+ * 
+ * @author Jake Cobb <tt>&lt;jake.cobb@gatech.edu&gt;</tt>
+ */
+public class LogicBloxParser implements IDatalogParser {
+    private static final Pattern metaCommentPattern = 
+        Pattern.compile("^\\s*//\\s*:(inputs|outputs|domains|name):\\s*(.+)\\s*$", Pattern.CASE_INSENSITIVE);
+    private static final Pattern relationSignaturePattern =
+        Pattern.compile("([a-zA-Z][^!=:\\-\\s<>(),]+)\\(([^\\)]+)\\)");
+    
+    // for error messages
+    private File currentFile;
+    private String currentRelation;
+
+    public LogicBloxParser() {
+    }
+    
+
+    @SuppressWarnings("resource") // closed by Utils.close
+    public DatalogMetadata parseMetadata(File file) throws IOException {
+        BufferedReader in = null;
+        try {
+            currentFile = file;
+            in = new BufferedReader(new InputStreamReader(new FileInputStream(file), "UTF-8"));
+            
+            DatalogMetadata metadata = new DatalogMetadata();
+            metadata.setFileName(file.getAbsolutePath());
+            
+            HashSet<String> domNames = new HashSet<String>();
+
+            HashMap<String, RelSign> consumedRels = new HashMap<String, RelSign>(),
+                                     producedRels = new HashMap<String, RelSign>();
+            
+            
+            String line;
+            // FIXME this is ok for //-style comments but rule definitions can span lines or be multiple per line
+            while (null != (line = in.readLine())) {
+                Matcher metaMatcher = metaCommentPattern.matcher(line);
+                if (!metaMatcher.matches())
+                    continue;
+                String type = metaMatcher.group(1).toLowerCase(Locale.US),
+                       data = metaMatcher.group(2).trim();
+                if ("inputs".equals(type)) {
+                    addRelSigns(consumedRels, data);
+                } else if ("outputs".equals(type)) {
+                    addRelSigns(producedRels, data);
+                } else if ("domains".equals(type)) {
+                    for (String domName: data.split(","))
+                        domNames.add(domName.trim());
+                } else if ("name".equals(type)) {
+                    if (metadata.getDlogName() != null)
+                        throw new ChordException("Got duplicate name entry in: " + file.getAbsolutePath());
+                    metadata.setDlogName(data);
+                } else {
+                    throw new ChordException("Unrecognized metadata type: " + type);
+                }
+            }
+            
+            metadata.setMajorDomNames(domNames);
+            metadata.setConsumedRels(consumedRels);
+            metadata.setProducedRels(producedRels);
+            
+            return metadata;
+            
+        } catch (UnsupportedEncodingException e) {
+            // by standard, utf-8 is always supported
+            throw new ChordException("UTF-8 not supported?", e);
+        } finally {
+            currentRelation = null;
+            currentFile = null;
+            Utils.close(in);
+        }
+    }
+    
+    /**
+     * Adds the relation signatures corresponding to an <tt>inputs</tt> or 
+     * <tt>outputs</tt> declaration.
+     * 
+     * @param signMap the signature map to populate
+     * @param data    the signature list in string format
+     */
+    private void addRelSigns(Map<String, RelSign> signMap, String data) {
+        Matcher sigMatcher = relationSignaturePattern.matcher(data);
+        while (sigMatcher.find()) {
+            String relName = sigMatcher.group(1),
+                    sigData = sigMatcher.group(2);
+            currentRelation = relName;
+            RelSign sign = parseRelationSignature(sigData);
+            if (signMap.containsKey(relName)) {
+                Messages.warn("%s has multiple signatures, replacing %s with %s.", relName, signMap.get(relName), sign);
+            }
+            signMap.put(relName, sign);
+        }
+    }
+    
+    /**
+     * Parses the domain names out of a signature list.
+     *   
+     * <p>Unless manually specified, minor numbers are assigned in order 
+     * of occurrence of a particular name starting from 0.
+     * <p>
+     * For a list should be of the form:<br />
+     * <tt>A, B, A</tt><br />
+     * Will return a signature with:<br />
+     * <tt>A0, B0, A1</tt>
+     * <p>
+     * If any minor number is specified for a given relation, then all minor numbers must 
+     * be specified.
+     * <p>
+     * The returned signature will have an arbitrary domain order (which is a BDD-specific concept).
+     * 
+     * @param signature the signature to parse
+     * @return the relation signature
+     */
+    private RelSign parseRelationSignature(String signature) {
+        String[] sigParts = signature.split(",");
+        for (int i = 0; i < sigParts.length; ++i)
+            sigParts[i] = sigParts[i].trim();
+        
+        String[] domNames;
+        if (areMinorsSpecified(sigParts)) {
+            domNames = sigParts;
+        } else {
+            HashMap<String, Integer> numMap = new HashMap<String, Integer>();
+            domNames = new String[sigParts.length];
+            for (int i = 0; i < sigParts.length; ++i) {
+                String domain = sigParts[i];
+                Integer num = numMap.get(domain);
+                if (num == null)
+                    num = 0;
+                domNames[i] = domain + num;
+                numMap.put(domain, num + 1);
+            }
+        }
+        
+        // LB has no concept of var order, so we just make one up
+        String varOrder = Utils.join(Arrays.asList(domNames), "x"); 
+        return new RelSign(domNames, varOrder);
+    }
+    
+    /**
+     * Checks whether all or no minor numbers are specified.  If they 
+     * are only partially specified an exception is thrown.
+     * 
+     * @param domains the domain specs to check
+     * @return <code>true</code> if all minors are specified or <code>false</code> is none are
+     * @throws ChordException if minors are only partially specified
+     */
+    private boolean areMinorsSpecified(String[] domains) {
+        String first = domains[0];
+        boolean firstHasMinors = Character.isDigit(first.charAt(first.length() - 1));
+        for (int i = 1; i < domains.length; ++i) {
+            String sigPart = domains[i];
+            boolean hasMinor = Character.isDigit(sigPart.charAt(sigPart.length() - 1));
+            if (hasMinor != firstHasMinors) {
+               throw new ChordException(String.format(
+                   "Minor domains only partially specified for relation %s in %s", 
+                   currentRelation, currentFile
+               ));
+            }
+        }
+        return firstHasMinors;
+    }
+
+}
diff -Nur jchord/main/src/chord/logicblox/LogicBloxUtils.java jchord/main/src/chord/logicblox/LogicBloxUtils.java
--- jchord/main/src/chord/logicblox/LogicBloxUtils.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/logicblox/LogicBloxUtils.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,110 @@
+package chord.logicblox;
+
+import java.io.File;
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import chord.project.ChordException;
+import chord.project.Config;
+import chord.project.Messages;
+import chord.project.OutDirUtils;
+import chord.util.ProcessExecutor;
+import chord.util.Timer;
+
+/**
+ * Utilities for interacting with the LogicBlox engine.
+ * 
+ * @author Jake Cobb <tt>&lt;jake.cobb@gatech.edu&gt;</tt>
+ */
+public class LogicBloxUtils {
+    private static final char[] alphabet = "abcdefghijklmnopqrstuvwxyzABCEDFGHIJKLMNOPQRSTUVWXYZ0123456789_-".toCharArray();
+    static {
+        assert alphabet.length == 64 : "Alphabet is not 64 characters long.";
+    }
+    
+    private static String toAlphabetString(int data) {
+        final int BOUND = alphabet.length;
+        char[] buf = new char[BOUND];
+        int charPos = BOUND;
+        while (data != 0) {
+            buf[--charPos] = alphabet[data & 63];
+            data >>>= 6;
+        };
+        return new String(buf, charPos, (BOUND - charPos));
+    }
+    
+    public static void initializeWorkspace() { 
+        initializeWorkspace(Config.logicbloxWorkspace); 
+    }
+    
+    public static void initializeWorkspace(String workspace) {
+        ProcessExecutor.Result result = OutDirUtils.executeCaptureWithFailOnError(
+            Config.logicbloxCommand,
+            "create",
+            "--overwrite",
+            workspace
+        );
+        
+        Messages.log("LogicBlox workspace initialized: %s" , workspace);
+    }
+    
+    /**
+     * Generates a workspace name by hashing some input string, intended to 
+     * be the absolute path of Chord's working directory.
+     * 
+     * @param seed a seed input
+     * @return the workspace name
+     */
+    public static String generateWorkspaceName(String seed) {
+        try {
+            MessageDigest md5 = MessageDigest.getInstance("MD5");
+            byte[] hash = md5.digest(seed.getBytes("UTF-8"));
+            StringBuilder sb = new StringBuilder("chord:");
+            for (int i = 0; i < hash.length; i += 2) {
+                int next = (i + 1 < hash.length ? hash[i + 1] : 0) & 0xFF;
+                int unsigned = ((hash[i] & 0xFF) << 8) | next;
+                sb.append(toAlphabetString(unsigned));
+            }
+            return sb.toString();
+        } catch (NoSuchAlgorithmException e) {
+            throw new ChordException(e);
+        } catch (UnsupportedEncodingException e) {
+            throw new ChordException(e);
+        }
+    }
+    
+    public static void addBlock(File definitionFile) {
+        addBlock(Config.logicbloxWorkspace, definitionFile);
+    }
+    
+    public static void addBlock(String workspace, File definitionFile) {
+        String path = definitionFile.getAbsolutePath();
+        Timer timer = new Timer("lb addblock --file " + path);
+        timer.init();
+        ProcessExecutor.Result result = OutDirUtils.executeCaptureWithFailOnError(
+            Config.logicbloxCommand, "addblock", "--file", path, workspace
+        );
+        timer.done();
+        
+        Messages.log("Successfully added block file: %s", definitionFile);
+        Messages.log("%s", timer.getInclusiveTimeStr());
+    }
+    
+    public static void execFile(File file) {
+        execFile(Config.logicbloxWorkspace, file);
+    }
+
+    public static void execFile(String workspace, File file) {
+        String path = file.getAbsolutePath();
+        Timer timer = new Timer("lb exec --file " + path);
+        timer.init();
+        ProcessExecutor.Result result = OutDirUtils.executeCaptureWithFailOnError(
+            Config.logicbloxCommand, "exec", "--file", path, workspace
+        );
+        timer.done();
+        
+        Messages.log("Successfully executed logic file: %s", file);
+        Messages.log("%s", timer.getInclusiveTimeStr());
+    }
+}
diff -Nur jchord/main/src/chord/project/ChordException.java jchord/main/src/chord/project/ChordException.java
--- jchord/main/src/chord/project/ChordException.java	1969-12-31 16:00:00.000000000 -0800
+++ jchord/main/src/chord/project/ChordException.java	2015-11-02 22:26:25.000000000 -0800
@@ -0,0 +1,28 @@
+package chord.project;
+
+/**
+ * A base class for Chord's runtime exceptions.
+ */
+public class ChordException extends RuntimeException {
+	private static final long serialVersionUID = 1L;
+	
+	public ChordException() {
+	}
+
+	public ChordException(String message) {
+		super(message);
+	}
+
+	public ChordException(Throwable cause) {
+		super(cause);
+	}
+
+	public ChordException(String message, Throwable cause) {
+		super(message, cause);
+	}
+
+	public ChordException(String message, Throwable cause,
+			boolean enableSuppression, boolean writableStackTrace) {
+		super(message, cause, enableSuppression, writableStackTrace);
+	}
+}
diff -Nur jchord/main/src/chord/project/ClassicProject.java jchord/main/src/chord/project/ClassicProject.java
--- jchord/main/src/chord/project/ClassicProject.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/ClassicProject.java	2015-11-02 22:26:25.000000000 -0800
@@ -2,6 +2,7 @@
 
 import java.io.File;
 import java.io.FilenameFilter;
+import java.util.Collections;
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.FileWriter;
@@ -14,15 +15,16 @@
 import java.util.Map;
 import java.util.Set;
 
+import chord.bddbddb.Dom;
+import chord.bddbddb.RelSign;
+import chord.logicblox.LogicBloxUtils;
 import chord.project.analyses.DlogAnalysis;
 import chord.project.analyses.ProgramDom;
 import chord.project.analyses.ProgramRel;
-import chord.project.ITask;
 import chord.util.ArraySet;
-import chord.util.Utils;
 import chord.util.Timer;
-import chord.bddbddb.RelSign;
-import chord.bddbddb.Dom;
+import chord.util.Utils;
+import chord.project.ITask;
 
 /**
  * A Chord project comprising a set of tasks and a set of targets
@@ -72,6 +74,15 @@
         TaskParser taskParser = new TaskParser();
         if (!taskParser.run())
             abort();
+        
+        switch (Config.datalogEngine) {
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            LogicBloxUtils.initializeWorkspace(Config.logicbloxWorkspace);
+            break;
+        case BDDBDDB:
+            break;
+        }
 
         // build nameToTaskMap
         Map<String, Class<ITask>> nameToJavaTaskMap = taskParser.getNameToJavaTaskMap();
@@ -472,6 +483,30 @@
         }
     }
 
+    public Set<String> getTargetNames() {
+        return Collections.unmodifiableSet(nameToTrgtMap.keySet());
+    }
+    
+    public Set<String> getTaskNames() {
+        return Collections.unmodifiableSet(nameToTaskMap.keySet());
+    }
+    
+    public Set<String> getFinishedTargetNames() {
+        HashSet<String> names = new HashSet<String>(Math.max((int) (doneTrgts.size()/.75f) + 1, 16), 0.75f);
+        for (String name: nameToTrgtMap.keySet())
+            if (isTrgtDone(name))
+                names.add(name);
+        return names;
+    }
+    
+    public Set<String> getFinishedTaskNames() {
+        HashSet<String> names = new HashSet<String>(Math.max((int) (doneTasks.size()/.75f) + 1, 16), 0.75f);
+        for (String name: nameToTaskMap.keySet())
+            if (isTrgtDone(name))
+                names.add(name);
+        return names;
+    }
+    
     public void resetTaskDone(String name) {
         resetTaskDone(getTask(name));
     }
diff -Nur jchord/main/src/chord/project/Config.java jchord/main/src/chord/project/Config.java
--- jchord/main/src/chord/project/Config.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/Config.java	2015-11-02 22:26:25.000000000 -0800
@@ -2,6 +2,7 @@
 
 import java.io.File;
 import java.io.IOException;
+import chord.logicblox.LogicBloxUtils;
 import chord.util.Utils;
 
 /**
@@ -106,6 +107,33 @@
     public final static boolean reuseRels =Utils.buildBoolProperty("chord.reuse.rels", false);
     public final static boolean reuseTraces =Utils.buildBoolProperty("chord.reuse.traces", false);
 
+    // datalog engine selection
+    public static enum DatalogEngineType {
+        BDDBDDB,
+        LOGICBLOX3,
+        LOGICBLOX4;
+    }
+
+    public final static DatalogEngineType datalogEngine =
+        Utils.buildEnumProperty("chord.datalog.engine", DatalogEngineType.BDDBDDB);
+    
+    // properties concerning LogicBlox
+    
+    /** <tt>chord.logicblox.delim</tt> : the input delimiter in domain export files. */
+    public final static String logicbloxInputDelim =
+        System.getProperty("chord.logicblox.delim", "\t");
+    /** <tt>chord.logicblox.command</tt> : the main logicblock command (default: <tt>lb</tt>) */
+    public final static String logicbloxCommand =
+        System.getProperty("chord.logicblox.command", "lb");
+    public final static String logicbloxWorkspace;
+    static {
+        String ws = System.getProperty("chord.logicblox.workspace");
+        if (ws == null)
+            ws = LogicBloxUtils.generateWorkspaceName(new File(Config.workDirName).getAbsolutePath());
+        logicbloxWorkspace = ws;
+    }
+    
+
     // properties concerning BDDs
 
     public final static boolean useBuddy =Utils.buildBoolProperty("chord.use.buddy", false);
@@ -125,10 +153,12 @@
     public final static String userClassesDirName = System.getProperty("chord.user.classes.dir", outRel2Abs("user_classes"));
     public final static String instrSchemeFileName = System.getProperty("chord.instr.scheme.file", outRel2Abs("scheme.ser"));
     public final static String traceFileName = System.getProperty("chord.trace.file", outRel2Abs("trace"));
+    public final static String logicbloxWorkDirName = System.getProperty("chord.logicblox.work.dir", outRel2Abs("logicblox"));
 
     static {
         Utils.mkdirs(outDirName);
         Utils.mkdirs(bddbddbWorkDirName);
+        Utils.mkdirs(logicbloxWorkDirName);
     }
 
     // commonly-used constants
@@ -219,6 +249,8 @@
         System.out.println("chord.reuse.traces: " + reuseTraces);
         System.out.println("chord.use.buddy: " + useBuddy);
         System.out.println("chord.bddbddb.max.heap: " + bddbddbMaxHeap);
+        System.out.println("chord.datalog.engine: " + datalogEngine);
+        System.out.println("chord.logicblox.work.dir: " + logicbloxWorkDirName);
     }
 
     public static String outRel2Abs(String fileName) {
diff -Nur jchord/main/src/chord/project/OutDirUtils.java jchord/main/src/chord/project/OutDirUtils.java
--- jchord/main/src/chord/project/OutDirUtils.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/OutDirUtils.java	2015-11-02 22:26:25.000000000 -0800
@@ -1,18 +1,20 @@
 package chord.project;
 
+import java.io.BufferedReader;
 import java.io.File;
-import java.io.IOException;
-import java.io.PrintWriter;
 import java.io.FileNotFoundException;
-import java.util.List;
-import java.util.ArrayList;
+import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
-import java.io.BufferedReader;
+import java.io.PrintWriter;
+import java.util.Arrays;
+import java.util.ArrayList;
+import java.util.List;
 
 import chord.util.IndexMap;
-import chord.util.Utils;
 import chord.util.ProcessExecutor;
+import chord.util.Utils;
+
 
 /**
  * Common operations on files in the directory specified by system property
@@ -129,6 +131,24 @@
         }
         if (Config.verbose >= 1) Messages.log(PROCESS_FINISHED, cmd);
     }
+    
+    public static ProcessExecutor.Result executeCaptureWithFailOnError(String... cmdarray) {
+        boolean verbose = Config.verbose >= 1;
+        String cmd = Utils.join(Arrays.asList(cmdarray), " ");
+        ProcessExecutor.Result result = null;
+        if (verbose) Messages.log(PROCESS_STARTING, cmd);
+        try {
+            result = ProcessExecutor.executeCaptureOutput(cmdarray);
+            if (result.getExitCode() != 0) {
+                Messages.error("Failed process standard output:\n%s", result.getError());
+                throw new ChordException("Process failed with retcode=" + result.getExitCode());
+            }
+        } catch (Exception e) {
+            Messages.fatal(PROCESS_FAILED, cmd, e.getMessage());
+        }
+        if (verbose) Messages.log(PROCESS_FINISHED, cmd);
+        return result;
+    }
 
     public static final void executeWithWarnOnError(List<String> cmdlist, int timeout) {
         String[] cmdarray = new String[cmdlist.size()];
diff -Nur jchord/main/src/chord/project/TaskParser.java jchord/main/src/chord/project/TaskParser.java
--- jchord/main/src/chord/project/TaskParser.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/TaskParser.java	2015-11-02 22:26:25.000000000 -0800
@@ -14,6 +14,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Enumeration;
+import java.util.regex.Pattern;
 import java.util.zip.ZipFile;
 import java.util.zip.ZipEntry;
 import java.util.jar.JarFile;
@@ -27,6 +28,7 @@
 import chord.project.ITask;
 import chord.util.Utils;
 import chord.bddbddb.RelSign;
+import chord.core.DatalogMetadata;
 
 /**
  * A Chord project comprising a set of tasks and a set of targets
@@ -49,6 +51,21 @@
         "ERROR: TaskParser: Ignoring Dlog analysis '%s'; errors were found while parsing it (see above).";
     private static final String IGNORE_JAVA_TASK =
         "ERROR: TaskParser: Ignoring Java analysis '%s'; errors were found in its @Chord annotation (see above).";
+    
+    private static final Pattern datalogFilePattern;
+    static {
+        switch (Config.datalogEngine) {
+        case BDDBDDB:
+            datalogFilePattern = Pattern.compile("\\.(dlog|datalog)$", Pattern.CASE_INSENSITIVE);
+            break;
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            datalogFilePattern = Pattern.compile("\\.logic$", Pattern.CASE_INSENSITIVE);
+            break;
+        default:
+            throw new ChordException("Unhandled datalog engine type: " + Config.datalogEngine);
+        }
+    }
 
     private final Map<String, Class<ITask>> nameToJavaTaskMap =
         new HashMap<String, Class<ITask>>();
@@ -228,7 +245,7 @@
                     processDlogAnalysis(subFile);
                 else {
                     String subFileName = subFile.getAbsolutePath();
-                    if (subFileName.endsWith(".dlog") || subFileName.endsWith(".datalog")) {
+                    if (datalogFilePattern.matcher(subFileName).find()) {
                         processDlogAnalysis(subFileName);
                     }
                 }
@@ -242,7 +259,7 @@
                     while (e.hasMoreElements()) {
                         JarEntry je = (JarEntry) e.nextElement();
                         String fileName2 = je.getName();
-                        if (fileName2.endsWith(".dlog") || fileName2.endsWith(".datalog")) {
+                        if (datalogFilePattern.matcher(fileName2).find()) {
                             InputStream is = jarFile.getInputStream(je);
                             String fileName3 = OutDirUtils.copyResourceByPath(fileName2, is, "dlog");
                             processDlogAnalysis(fileName3);
@@ -254,7 +271,7 @@
                     while (e.hasMoreElements()) {
                         ZipEntry ze = (ZipEntry) e.nextElement();
                         String fileName2 = ze.getName();
-                        if (fileName2.endsWith(".dlog") || fileName2.endsWith(".datalog")) {
+                        if (datalogFilePattern.matcher(fileName2).find()) {
                             InputStream is = zipFile.getInputStream(ze);
                             String fileName3 = OutDirUtils.copyResourceByPath(fileName2, is, "dlog");
                             processDlogAnalysis(fileName3);
@@ -269,8 +286,15 @@
 
     private void processDlogAnalysis(String fileName) {
         DlogAnalysis task = new DlogAnalysis();
-        boolean success = task.parse(fileName);
-        if (!success) {
+        DatalogMetadata meta = null;
+        try {
+            meta = task.parse(fileName);
+            if (!meta.hasNoErrors()) {
+                ignoreDlogTask(fileName);
+                return;
+            }
+        } catch (IOException e) {
+            Messages.log("%s", e.getMessage());
             ignoreDlogTask(fileName);
             return;
         }
diff -Nur jchord/main/src/chord/project/analyses/DlogAnalysis.java jchord/main/src/chord/project/analyses/DlogAnalysis.java
--- jchord/main/src/chord/project/analyses/DlogAnalysis.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/analyses/DlogAnalysis.java	2015-11-02 22:26:25.000000000 -0800
@@ -1,31 +1,39 @@
 package chord.project.analyses;
 
-import java.io.BufferedReader;
 import java.io.File;
-import java.io.FileReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
 import java.io.IOException;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import java.util.Set;
-import java.util.HashSet;
 
 import CnCHJ.api.ItemCollection;
-
-import chord.project.Messages;
+import chord.bddbddb.BDDBDDBParser;
 import chord.bddbddb.RelSign;
 import chord.bddbddb.Solver;
-import chord.project.ICtrlCollection;
+import chord.core.DatalogMetadata;
+import chord.core.IDatalogParser;
+import chord.logicblox.LogicBloxParser;
+import chord.logicblox.LogicBloxUtils;
+import chord.project.ChordException;
+import chord.project.Config;
 import chord.project.IDataCollection;
 import chord.project.IStepCollection;
+import chord.project.Messages;
 import chord.project.ModernProject;
+import chord.project.Config.DatalogEngineType;
 import chord.util.Utils;
 
+import java.io.BufferedReader;
+import java.io.FileReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.HashMap;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.HashSet;
+import chord.project.ICtrlCollection;
+import chord.project.ModernProject;
 import gnu.trove.list.array.TIntArrayList;
 
 /**
@@ -35,20 +43,32 @@
  * @author Mayur Naik (mhn@cs.stanford.edu)
  */
 public class DlogAnalysis extends JavaAnalysis {
-    // absolute filename of the datalog program
-    private String fileName;
-    private Set<String> majorDomNames;
-    private Map<String, RelSign> consumedRels;
-    private Map<String, RelSign> producedRels;
-    private String dlogName;
-    private boolean hasNoErrors = true;
-    // number of line currently being parsed in the datalog program
-    private int lineNum;
-    // bdd ordering of all domains specified using .bddvarorder in the datalog program
-    private String order;
-    // ordered list of all domains specified using .bddvarorder in the datalog program
-    private List<String> minorDomNames;
-    // may return null
+    
+    private DatalogEngineType datalogEngine;
+    private DatalogMetadata metadata;
+    
+    private IDatalogParser parser;
+    
+    public DlogAnalysis() { 
+        this(Config.datalogEngine); 
+    }
+    
+    public DlogAnalysis(DatalogEngineType engineType) {
+        if( engineType == null ) throw new NullPointerException("engineType is null");
+        this.datalogEngine = engineType;
+        switch (engineType) {
+        case BDDBDDB:
+            parser = new BDDBDDBParser();
+            break;
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            parser = new LogicBloxParser();
+            break;
+        default:
+            throw new ChordException("Unhandled datalog engine type: " + Config.datalogEngine);
+        }
+    }
+    
     /**
      * Provides the name of this Datalog analysis.
      * It is specified via a line of the form "# name=..." in the file containing the analysis.
@@ -56,7 +76,7 @@
      * @return    The name of this Datalog analysis.
      */
     public String getDlogName() {
-        return dlogName;
+        return metadata != null ? metadata.getDlogName() : null;
     }
     /**
      * Provides the file containing this Datalog analysis.
@@ -64,221 +84,37 @@
      * @return    The file containing this Datalog analysis.
      */
     public String getFileName() {
-        return fileName.toString();
+        return metadata != null ? metadata.getFileName() : null;
     }
-    /**
-     * Parses the Datalog analysis in the specified file.
-     * 
-     * @param    fileName A file containing a Datalog analysis.
-     * 
-     * @return    true iff the Datalog analysis parses successfully.
-     */
-    public boolean parse(String fileName) {
-        assert (this.fileName == null);
-        this.fileName = fileName;
-        majorDomNames = new HashSet<String>();
-        consumedRels = new HashMap<String, RelSign>();
-        producedRels = new HashMap<String, RelSign>();
-        minorDomNames = new ArrayList<String>();
-        BufferedReader in = null;
-        try {
-            in = new BufferedReader(new FileReader(fileName));
-        } catch (IOException ex) {
-            Messages.log(ex.getMessage());
-            return false;
-        }
-        Pattern p = Pattern.compile("(\\w)+\\((\\w)+:(\\w)+(,(\\w)+:(\\w)+)*\\)((input)|(output))");
-        for (lineNum = 1; true; lineNum++) {
-            String s;
-            try {
-                s = in.readLine();
-            } catch (IOException ex) {
-                Messages.log(ex.getMessage());
-                return false;
-            }
-            if (s == null)
-                break;
-            if (s.startsWith("#")) {
-                if (s.startsWith("# name=")) {
-                    if (dlogName == null)
-                        dlogName = s.trim().substring(7);
-                    else
-                        error("Name redeclared via # name=...");
-                }
-                continue;
-            }
-            int k = s.indexOf('#');
-            if (k != -1) s = s.substring(0, k);
-            s = s.trim();
-            if (s.length() == 0)
-                 continue;
-            // strip all whitespaces from line
-            StringBuffer t = new StringBuffer(s.length());
-            for (int i = 0; i < s.length(); i++) {
-                char c = s.charAt(i);
-                if (!Character.isWhitespace(c))
-                    t.append(c);
-            }
-            s = t.toString();
-            if (s.startsWith(".bddvarorder")) {
-                if (order != null) {
-                    error(".bddvarorder redefined.");
-                    continue;
-                }
-                order = s.substring(12);
-                String[] a = order.split("_|x");
-                for (String minorDomName : a) {
-                    if (minorDomNames.contains(minorDomName)) {
-                        error("Domain name '" + minorDomName + "' occurs multiple times in .bddvarorder; " +
-                            "considering first occurrence.");
-                    } else {
-                        minorDomNames.add(minorDomName);
-                        String majorDomName = Utils.trimNumSuffix(minorDomName);
-                        majorDomNames.add(majorDomName);
-                    }
-                }
-                continue;
-            }
-            Matcher m = p.matcher(s);
-            if (!m.matches())
-                continue;
-            if (order == null) {
-                error(".bddvarorder not defined before first relation declared");
-                return false;
-            }
-            int i = s.indexOf('(');
-            String relName = s.substring(0, i);
-            if (consumedRels.containsKey(relName)) {
-                error("Relation '" + relName + "' redeclared");
-                continue;
-            }
-            if (producedRels.containsKey(relName)) {
-                error("Relation '" + relName + "' redeclared");
-                continue;
-            }
-            s = s.substring(i + 1);
-            boolean done = false;
-            boolean ignore = false;
-            List<String> relMinorDomNames = new ArrayList<String>();
-            List<String> relMajorDomNames = new ArrayList<String>();
-            TIntArrayList indices = new TIntArrayList();
-            while (!done) {
-                i = s.indexOf(':');
-                assert (i != -1);
-                s = s.substring(i + 1);
-                i = s.indexOf(',');
-                if (i == -1) {
-                    i = s.indexOf(')');
-                    assert (i != -1);
-                    done = true;
-                }
-                String domName = s.substring(0, i);
-                String minorDomName;
-                String majorDomName;
-                int index;
-                if (!Character.isDigit(domName.charAt(i - 1))) {
-                    majorDomName = domName;
-                    index = 0;
-                    int num = indices.size();
-                    while (true) {
-                        int j = 0;
-                        for (String majorDomName2 : relMajorDomNames) {
-                            if (majorDomName2.equals(majorDomName) &&
-                                    indices.get(j) == index) {
-                                index++;
-                                break;
-                            }
-                            j++;
-                        }
-                        if (j == num)
-                            break;
-                    }
-                    minorDomName = majorDomName + Integer.toString(index);
-                } else {
-                    minorDomName = domName;
-                    int j = i - 1;
-                    while (true) {
-                        char c = domName.charAt(j);
-                        if (Character.isDigit(c))
-                            j--;
-                        else
-                            break;
-                    }
-                    majorDomName = domName.substring(0, j + 1);
-                    index = Integer.parseInt(domName.substring(j + 1, i));
-                }
-                if (relMinorDomNames.contains(minorDomName)) {
-                    error("Domain name '" + minorDomName + "' occurs multiple times in declaration of " +
-                        "relation '" + relName + "'");
-                    ignore = true;
-                } else if (!minorDomNames.contains(minorDomName)) {
-                    error("Domain name '" + domName + "' in declaration of relation '" + relName +
-                        "' does not occur in .bddvarorder");
-                    ignore = true;
-                } else {
-                    relMinorDomNames.add(minorDomName);
-                    relMajorDomNames.add(majorDomName);
-                    indices.add(index);
-                }
-                s = s.substring(i + 1);
-            }
-            if (ignore)
-                continue;
-            int numDoms = relMinorDomNames.size();
-            String[] domNames = new String[numDoms];
-            String domOrder = getSubOrder(relMinorDomNames);
-            for (int j = 0; j < numDoms; j++)
-                domNames[j] = relMinorDomNames.get(j);
-            Map<String, RelSign> map = null;
-            if (s.equals("input"))
-                map = consumedRels;
-            else if (s.equals("output"))
-                map = producedRels;
-            else
-                assert false; 
-            RelSign relSign;
-            try {
-                relSign = new RelSign(domNames, domOrder);
-            } catch (RuntimeException ex) {
-                error(ex.getMessage());
-                continue;
-            }
-            map.put(relName, relSign);
-        }
-        return hasNoErrors;
+    
+    public DatalogMetadata parse(String fileName) throws IOException {
+        metadata = parser.parseMetadata(new File(fileName));
+        return metadata;
     }
-    private String getSubOrder(List<String> relMinorDomNames) {
-        int orderLen = order.length();
-        String subOrder = null;
-        char lastSep = ' ';
-        int i = 0;
-        for (String domName : minorDomNames) {
-            i += domName.length();
-            if (relMinorDomNames.contains(domName)) {
-                if (subOrder == null)
-                    subOrder = domName;
-                else
-                    subOrder = subOrder + lastSep + domName;
-                if (i != orderLen)
-                    lastSep = order.charAt(i);
-            } else {
-                if (i != orderLen && order.charAt(i) == '_')
-                    lastSep = '_';
-            }
-            i++;
-        }
-        return subOrder;
-    }
-    private void error(String errMsg) {
+    
+    /*private void error(String errMsg) {
         Messages.log("ERROR: DlogAnalysis: " + fileName + ": line " + lineNum + ": " + errMsg);
         hasNoErrors = false;
-    }
+    }*/
     /**
      * Executes this Datalog analysis.
      */
     public void run() {
-        Solver.run(fileName.toString());
+        switch (datalogEngine) {
+        case BDDBDDB:
+            Solver.run(metadata.getFileName());
+            break;
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            if (Config.verbose >= 1)
+                Messages.log("Adding block from: %s", metadata.getFileName());
+            LogicBloxUtils.addBlock(new File(metadata.getFileName()));
+            break;
+        default:
+            throw new ChordException("FIXME: Unhandled datalog engine type: " + datalogEngine);
+        }
     }
+
     public void run(Object ctrl, IStepCollection sc) {
         ModernProject p = ModernProject.g();
         Object[] consumes = p.runPrologue(ctrl, sc);
@@ -312,13 +148,14 @@
             pic.Put(ctrl, rel);
         }
     }
+
     /**
      * Provides the names of all domains of relations consumed/produced by this Datalog analysis.
      * 
      * @return    The names of all domains of relations consumed/produced by this Datalog analysis.
      */
     public Set<String> getDomNames() {
-        return majorDomNames;
+        return metadata != null ? metadata.getMajorDomNames() : null;
     }
     /**
      * Provides the names and signatures of all relations consumed by this Datalog analysis.
@@ -326,7 +163,7 @@
      * @return    The names and signatures of all relations consumed by this Datalog analysis.
      */
     public Map<String, RelSign> getConsumedRels() {
-        return consumedRels;
+        return metadata != null ? metadata.getConsumedRels() : null;
     }
     /**
      * Provides the names and signatures of all relations produced by this Datalog analysis.
@@ -334,6 +171,6 @@
      * @return    The names and signatures of all relations produced by this Datalog analysis.
      */
     public Map<String, RelSign> getProducedRels() {
-        return producedRels;
+        return metadata != null ? metadata.getProducedRels() : null;
     }
 }
diff -Nur jchord/main/src/chord/project/analyses/ProgramDom.java jchord/main/src/chord/project/analyses/ProgramDom.java
--- jchord/main/src/chord/project/analyses/ProgramDom.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/analyses/ProgramDom.java	2015-11-02 22:26:25.000000000 -0800
@@ -7,10 +7,10 @@
 import java.util.List;
 
 import CnCHJ.api.ItemCollection;
-
 import chord.project.ClassicProject;
 import chord.bddbddb.Dom;
 import chord.program.visitors.IClassVisitor;
+import chord.project.ChordException;
 import chord.project.ICtrlCollection;
 import chord.project.IDataCollection;
 import chord.project.IStepCollection;
@@ -55,9 +55,19 @@
         if (Config.verbose >= 1)
             System.out.println("SAVING dom " + name + " size: " + size());
         try {
-            super.save(Config.bddbddbWorkDirName, Config.saveDomMaps);
+            switch (Config.datalogEngine) {
+            case BDDBDDB:
+                super.saveToBDD(Config.bddbddbWorkDirName, Config.saveDomMaps);
+                break;
+            case LOGICBLOX3:
+            case LOGICBLOX4:
+                super.saveToLogicBlox(Config.logicbloxWorkDirName);
+                break;
+            default:
+                throw new ChordException("Unrecognized datalog engine: " + Config.datalogEngine);
+            }
         } catch (IOException ex) {
-            throw new RuntimeException(ex);
+            throw new ChordException(ex);
         }
         if (Config.classic)
             ClassicProject.g().setTrgtDone(this);
diff -Nur jchord/main/src/chord/project/analyses/ProgramRel.java jchord/main/src/chord/project/analyses/ProgramRel.java
--- jchord/main/src/chord/project/analyses/ProgramRel.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/analyses/ProgramRel.java	2015-11-02 22:26:25.000000000 -0800
@@ -1,22 +1,23 @@
 package chord.project.analyses;
 
-import java.util.List;
-import java.io.File;
-
-import chord.project.ClassicProject;
 import chord.bddbddb.Rel;
 import chord.bddbddb.RelSign;
 import chord.program.visitors.IClassVisitor;
+import chord.project.ChordException;
+import chord.project.ClassicProject;
 import chord.project.Config;
-import chord.project.ICtrlCollection;
-import chord.project.IDataCollection;
 import chord.project.IStepCollection;
+import chord.project.ITask;
+import chord.project.Messages;
 import chord.project.ModernProject;
 import chord.project.VisitorHandler;
 import chord.util.Utils;
-import chord.project.Messages;
-import chord.project.ITask;
 
+import java.util.List;
+import java.io.File;
+
+import chord.project.ICtrlCollection;
+import chord.project.IDataCollection;
 import CnCHJ.api.ItemCollection;
 
 /**
@@ -75,12 +76,30 @@
     public void save() {
         if (Config.verbose >= 1)
             System.out.println("SAVING rel " + name + " size: " + size());
-        super.save(Config.bddbddbWorkDirName);
+        switch (Config.datalogEngine) {
+        case BDDBDDB:
+            super.saveToBDD(Config.bddbddbWorkDirName);
+            break;
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            super.saveToLogicBlox(Config.logicbloxWorkDirName);
+            break;
+        }
         if (Config.classic)
             ClassicProject.g().setTrgtDone(this);
     }
     public void load() {
-        super.load(Config.bddbddbWorkDirName);
+        switch (Config.datalogEngine) {
+        case BDDBDDB:
+            super.loadFromBDDBDDB(Config.bddbddbWorkDirName);
+            break;
+        case LOGICBLOX3:
+        case LOGICBLOX4:
+            super.loadFromLogicBlox(Config.logicbloxWorkspace);
+            break;
+        default:
+            throw new ChordException("Unhandled datalog engine: " + Config.datalogEngine);
+        }
     }
     public void fill() {
         if (this instanceof IClassVisitor) {
diff -Nur jchord/main/src/chord/project/analyses/provenance/DlogInstrumenter.java jchord/main/src/chord/project/analyses/provenance/DlogInstrumenter.java
--- jchord/main/src/chord/project/analyses/provenance/DlogInstrumenter.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/project/analyses/provenance/DlogInstrumenter.java	2015-11-02 22:26:25.000000000 -0800
@@ -93,7 +93,7 @@
 			if(o instanceof Dom){
 				Dom d = (Dom)o;
 				try {
-					d.save(Config.bddbddbWorkDirName, Config.saveDomMaps);
+					d.saveToBDD(Config.bddbddbWorkDirName, Config.saveDomMaps);
 				} catch (IOException e) {
 					throw new RuntimeException(e);
 				}
diff -Nur jchord/main/src/chord/util/ProcessExecutor.java jchord/main/src/chord/util/ProcessExecutor.java
--- jchord/main/src/chord/util/ProcessExecutor.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/util/ProcessExecutor.java	2015-11-02 22:26:25.000000000 -0800
@@ -2,15 +2,16 @@
 
 import static chord.util.ExceptionUtil.fail;
 
-import java.io.File;
 import java.io.BufferedReader;
+import java.io.ByteArrayOutputStream;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
-import java.io.PrintStream;
 import java.io.InputStreamReader;
+import java.io.PrintStream;
 import java.io.PrintWriter;
-import java.util.TimerTask;
 import java.util.Timer;
+import java.util.TimerTask;
 
 /**
  * Utility to execute a system command specified as a string in a separate process.
@@ -18,6 +19,29 @@
  * @author Mayur Naik (mhn@cs.stanford.edu)
  */
 public final class ProcessExecutor {
+    
+    public static class Result {
+        private final int exitCode;
+        private final String output;
+        private final String error;
+        public Result(int exitCode, String output, String error) {
+            this.exitCode = exitCode;
+            this.output = output;
+            this.error = error;
+        }
+        
+        public int getExitCode() {
+            return exitCode;
+        }
+        
+        public String getError() {
+            return error;
+        }
+        
+        public String getOutput() {
+            return output;
+        }
+    }
 	/**
 	 * Executes a given system command specified as a string in a separate process.
 	 * <p>
@@ -120,19 +144,90 @@
         return exitValue;
     }
 
-    public static final Process executeAsynch(String[] cmdarray, String[] envp, File dir) throws Throwable {
+    public static final Process executeAsynch(String[] cmdarray, String[] envp, File dir) throws IOException {
+        return executeAsynch(cmdarray, envp, dir, System.out, System.err);
+    }
+    
+    /**
+     * Executes a process asynchronously.
+     * 
+     * @param cmdarray the commands to run
+     * @param envp     the environment
+     * @param dir      the working directory, may be <code>null</code>
+     * @param outStream the stream for output, may not be <code>null</code>
+     * @param errStream the stream for standard error, may not be <code>null</code>
+     * @return the process handle
+     * @throws IOException
+     * @throws NullPointerException if a required argument is <code>null</code>
+     * @see Runtime#exec(String[], String[], File)
+     */
+    public static Process executeAsynch(String[] cmdarray, String[] envp, File dir, 
+            PrintStream outStream, PrintStream errStream) throws IOException {
+        if( outStream == null ) throw new NullPointerException("outStream is null");
+        if( errStream == null ) throw new NullPointerException("errStream is null");
+        
         Process proc = Runtime.getRuntime().exec(cmdarray, envp, dir);
-        StreamGobbler err = new StreamGobbler(proc.getErrorStream(), System.err);
-        StreamGobbler out = new StreamGobbler(proc.getInputStream(), System.out);
+        StreamGobbler err = new StreamGobbler(proc.getErrorStream(), errStream);
+        StreamGobbler out = new StreamGobbler(proc.getInputStream(), outStream);
         err.start();
         out.start();
         return proc;
-    }  
+    }
+    
+    
+    /**
+     * Executes a command and captures the complete result.
+     * 
+     * @param cmds the command and any arguments
+     * @param envp the environment
+     * @param dir  the working directory, may be <code>null</code>
+     * @param timeout the time to wait before aborting, or a negative number to wait forever
+     * @return the result
+     * 
+     * @throws IOException
+     * @throws InterruptedException
+     */
+    public static Result executeCaptureOutput(String... cmds) 
+            throws IOException, InterruptedException {
+        return executeCaptureOutput(cmds, null, null, -1);
+    }
+    
+    /**
+     * Executes a command and captures the complete result.
+     * 
+     * @param cmds the command and any arguments
+     * @param envp the environment
+     * @param dir  the working directory, may be <code>null</code>
+     * @param timeout the time to wait before aborting, or a negative number to wait forever
+     * @return the result
+     * 
+     * @throws IOException
+     * @throws InterruptedException
+     */
+    public static Result executeCaptureOutput(String[] cmds, String[] envp, File dir, int timeout) 
+            throws IOException, InterruptedException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        ByteArrayOutputStream err = new ByteArrayOutputStream();
+        
+        Process proc = executeAsynch(cmds, envp, dir, 
+            new PrintStream(out, true, "UTF-8"),
+            new PrintStream(err, true, "UTF-8"));
+        TimerTask killOnDelay = null;
+        if (timeout > 0) {
+            Timer t = new Timer();
+            killOnDelay = new KillOnTimeout(proc);
+            t.schedule(killOnDelay, timeout);
+        }
+        int exitValue = proc.waitFor();
+        if (timeout > 0)
+            killOnDelay.cancel();
+        return new Result(exitValue, out.toString("UTF-8"), out.toString("UTF-8"));
+    }
   
-    private static class StreamGobbler extends Thread {
+    public static class StreamGobbler extends Thread {
         private final InputStream is;
         private final PrintStream os;
-        private StreamGobbler(InputStream is, PrintStream os) {
+        public StreamGobbler(InputStream is, PrintStream os) {
             this.is = is;
             this.os = os;
             this.setDaemon(true);
diff -Nur jchord/main/src/chord/util/Utils.java jchord/main/src/chord/util/Utils.java
--- jchord/main/src/chord/util/Utils.java	2015-11-18 15:48:06.000000000 -0800
+++ jchord/main/src/chord/util/Utils.java	2015-11-02 22:26:25.000000000 -0800
@@ -1,5 +1,6 @@
 package chord.util;
 
+import java.io.Closeable;
 import java.io.File;
 import java.io.PrintWriter;
 import java.io.FileOutputStream;
@@ -11,10 +12,11 @@
 import java.io.ObjectOutputStream;
 import java.io.ObjectInputStream;
 import java.io.FileReader;
-
 import java.net.MalformedURLException;
 import java.util.Iterator;
 import java.util.Collection;
+import java.util.Locale;
+
 import java.util.StringTokenizer;
 import java.util.ArrayList;
 import java.util.HashMap;
@@ -28,6 +30,8 @@
 
 import org.scannotation.AnnotationDB;
 
+import chord.project.ChordException;
+
 /**
  * Commonly-used utilities.
  *
@@ -552,6 +556,25 @@
         return System.getProperty(propName, Boolean.toString(defaultVal)).equals("true");
     }
     
+    /**
+     * Reads a property as an <tt>enum</tt> value.  The property values are case-insensitive.
+     * 
+     * @param propName    the property name
+     * @param defaultVal  the default enum value
+     * @return
+     */
+    public static <T extends Enum<T>> T buildEnumProperty(String propName, T defaultVal) {
+        String propVal = System.getProperty(propName, null);
+        if (propVal == null)
+            return defaultVal;
+        for (T enumVal : defaultVal.getDeclaringClass().getEnumConstants()) {
+            if (enumVal.name().equalsIgnoreCase(propVal))
+                return enumVal;
+        }
+        throw new ChordException("Property " + propName + " does not specify a valid enum of type "
+            + defaultVal.getDeclaringClass().getName());
+    }
+    
     public static String[] split(String s, String sep, boolean trimWhiteSpace, boolean noEmptyString, int limit) {
         if (trimWhiteSpace == false && noEmptyString == false) {
             return s.split(sep, limit);
@@ -589,4 +612,19 @@
 //        return input.replace("&", "&amp;").replace(">", "&gt;").replace("<", "&lt;")
 //            .replace("'", "&apos;").replaceAll("\"", "&quot;");
     }
+    
+    /**
+     * Silently close a resource, returning any thrown exception.
+     * @param c the resource to close, may be <code>null</code>
+     * @return the thrown exception or <code>null</code>
+     */
+    public static IOException close(Closeable c) {
+        try {
+            if (c != null)
+                c.close();
+        } catch (IOException e) {
+            return e;
+        }
+        return null;
+    }
 }
